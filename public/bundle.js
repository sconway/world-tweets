/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 270);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyFunction = __webpack_require__(10);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  (function () {
    var printWarning = function printWarning(format) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var argIndex = 0;
      var message = 'Warning: ' + format.replace(/%s/g, function () {
        return args[argIndex++];
      });
      if (typeof console !== 'undefined') {
        console.error(message);
      }
      try {
        // --- Welcome to debugging React ---
        // This error was thrown as a convenience so that you can use this stack
        // to find the callsite that caused this warning to fire.
        throw new Error(message);
      } catch (x) {}
    };

    warning = function warning(condition, format) {
      if (format === undefined) {
        throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
      }

      if (format.indexOf('Failed Composite propType: ') === 0) {
        return; // Ignore CompositeComponent proptype check.
      }

      if (!condition) {
        for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
          args[_key2 - 2] = arguments[_key2];
        }

        printWarning.apply(undefined, [format].concat(args));
      }
    };
  })();
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMProperty = __webpack_require__(15);
var ReactDOMComponentFlags = __webpack_require__(86);

var invariant = __webpack_require__(1);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Check if a given node should be cached.
 */
function shouldPrecacheNode(node, nodeID) {
  return node.nodeType === 1 && node.getAttribute(ATTR_NAME) === String(nodeID) || node.nodeType === 8 && node.nodeValue === ' react-text: ' + nodeID + ' ' || node.nodeType === 8 && node.nodeValue === ' react-empty: ' + nodeID + ' ';
}

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (shouldPrecacheNode(childNode, childID)) {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unable to find element with ID %s.', childID) : _prodInvariant('32', childID) : void 0;
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React DOM tree root should always have a node reference.') : _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 7 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(19);

var ReactCurrentOwner = __webpack_require__(12);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  process.env.NODE_ENV !== 'production' ? warning(element, 'ReactComponentTreeHook: Missing React element for debugID %s when ' + 'building stack', id) : void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected hook events to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onSetChildren() to fire for a container child before its parent includes it in onSetChildren().') : _prodInvariant('141') : void 0;
      !nextChild.isMounted ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onMountComponent() to fire for the child before its parent includes it in onSetChildren().') : _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected onBeforeMountComponent() parent and onSetChildren() to be consistent (%s has parents %s and %s).', nextChildID, nextChild.parentID, id) : _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Item must have been set') : _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

if (process.env.NODE_ENV !== 'production') {
  var ReactDebugTool = __webpack_require__(191);
  debugTool = ReactDebugTool;
}

module.exports = { debugTool: debugTool };
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var CallbackQueue = __webpack_require__(84);
var PooledClass = __webpack_require__(17);
var ReactFeatureFlags = __webpack_require__(89);
var ReactReconciler = __webpack_require__(22);
var Transaction = __webpack_require__(37);

var invariant = __webpack_require__(1);

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching strategy') : _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to match dirty-components array length (%s).', len, dirtyComponents.length) : _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context whereupdates are not being batched.') : _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(17);

var emptyFunction = __webpack_require__(10);
var warning = __webpack_require__(2);

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  if (process.env.NODE_ENV !== 'production') {
    // these have a getter/setter for warnings
    delete this.nativeEvent;
    delete this.preventDefault;
    delete this.stopPropagation;
  }

  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    if (process.env.NODE_ENV !== 'production') {
      delete this[propName]; // this has a getter/setter for warnings
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      if (process.env.NODE_ENV !== 'production') {
        Object.defineProperty(this, propName, getPooledWarningPropertyDefinition(propName, Interface[propName]));
      } else {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
    if (process.env.NODE_ENV !== 'production') {
      Object.defineProperty(this, 'nativeEvent', getPooledWarningPropertyDefinition('nativeEvent', null));
      Object.defineProperty(this, 'preventDefault', getPooledWarningPropertyDefinition('preventDefault', emptyFunction));
      Object.defineProperty(this, 'stopPropagation', getPooledWarningPropertyDefinition('stopPropagation', emptyFunction));
    }
  }

});

SyntheticEvent.Interface = EventInterface;

if (process.env.NODE_ENV !== 'production') {
  if (isProxySupported) {
    /*eslint-disable no-func-assign */
    SyntheticEvent = new Proxy(SyntheticEvent, {
      construct: function (target, args) {
        return this.apply(target, Object.create(target.prototype), args);
      },
      apply: function (constructor, that, args) {
        return new Proxy(constructor.apply(that, args), {
          set: function (target, prop, value) {
            if (prop !== 'isPersistent' && !target.constructor.Interface.hasOwnProperty(prop) && shouldBeReleasedProperties.indexOf(prop) === -1) {
              process.env.NODE_ENV !== 'production' ? warning(didWarnForAddedNewProperty || target.isPersistent(), 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re adding a new property in the synthetic event object. ' + 'The property is never released. See ' + 'https://fb.me/react-event-pooling for more information.') : void 0;
              didWarnForAddedNewProperty = true;
            }
            target[prop] = value;
            return true;
          }
        });
      }
    });
    /*eslint-enable no-func-assign */
  }
}
/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    process.env.NODE_ENV !== 'production' ? warning(warningCondition, 'This synthetic event is reused for performance reasons. If you\'re seeing this, ' + 'you\'re %s `%s` on a released/nullified synthetic event. %s. ' + 'If you must keep the original synthetic event around, use event.persist(). ' + 'See https://fb.me/react-event-pooling for more information.', action, propName, result) : void 0;
  }
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

var THREE = { REVISION: '78' };

//

if ( true ) {

	!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {

	module.exports = THREE;

}

// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*(\S*)\s*\(/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

//

Object.assign( THREE, {

	// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button

	MOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },

	// GL STATE CONSTANTS

	CullFaceNone: 0,
	CullFaceBack: 1,
	CullFaceFront: 2,
	CullFaceFrontBack: 3,

	FrontFaceDirectionCW: 0,
	FrontFaceDirectionCCW: 1,

	// SHADOWING TYPES

	BasicShadowMap: 0,
	PCFShadowMap: 1,
	PCFSoftShadowMap: 2,

	// MATERIAL CONSTANTS

	// side

	FrontSide: 0,
	BackSide: 1,
	DoubleSide: 2,

	// shading

	FlatShading: 1,
	SmoothShading: 2,

	// colors

	NoColors: 0,
	FaceColors: 1,
	VertexColors: 2,

	// blending modes

	NoBlending: 0,
	NormalBlending: 1,
	AdditiveBlending: 2,
	SubtractiveBlending: 3,
	MultiplyBlending: 4,
	CustomBlending: 5,

	// custom blending equations
	// (numbers start from 100 not to clash with other
	// mappings to OpenGL constants defined in Texture.js)

	AddEquation: 100,
	SubtractEquation: 101,
	ReverseSubtractEquation: 102,
	MinEquation: 103,
	MaxEquation: 104,

	// custom blending destination factors

	ZeroFactor: 200,
	OneFactor: 201,
	SrcColorFactor: 202,
	OneMinusSrcColorFactor: 203,
	SrcAlphaFactor: 204,
	OneMinusSrcAlphaFactor: 205,
	DstAlphaFactor: 206,
	OneMinusDstAlphaFactor: 207,

	// custom blending source factors

	//ZeroFactor: 200,
	//OneFactor: 201,
	//SrcAlphaFactor: 204,
	//OneMinusSrcAlphaFactor: 205,
	//DstAlphaFactor: 206,
	//OneMinusDstAlphaFactor: 207,
	DstColorFactor: 208,
	OneMinusDstColorFactor: 209,
	SrcAlphaSaturateFactor: 210,

	// depth modes

	NeverDepth: 0,
	AlwaysDepth: 1,
	LessDepth: 2,
	LessEqualDepth: 3,
	EqualDepth: 4,
	GreaterEqualDepth: 5,
	GreaterDepth: 6,
	NotEqualDepth: 7,


	// TEXTURE CONSTANTS

	MultiplyOperation: 0,
	MixOperation: 1,
	AddOperation: 2,

	// Tone Mapping modes

	NoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)
	LinearToneMapping: 1, // only apply exposure.
	ReinhardToneMapping: 2,
	Uncharted2ToneMapping: 3, // John Hable
	CineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson

	// Mapping modes

	UVMapping: 300,

	CubeReflectionMapping: 301,
	CubeRefractionMapping: 302,

	EquirectangularReflectionMapping: 303,
	EquirectangularRefractionMapping: 304,

	SphericalReflectionMapping: 305,
	CubeUVReflectionMapping: 306,
	CubeUVRefractionMapping: 307,

	// Wrapping modes

	RepeatWrapping: 1000,
	ClampToEdgeWrapping: 1001,
	MirroredRepeatWrapping: 1002,

	// Filters

	NearestFilter: 1003,
	NearestMipMapNearestFilter: 1004,
	NearestMipMapLinearFilter: 1005,
	LinearFilter: 1006,
	LinearMipMapNearestFilter: 1007,
	LinearMipMapLinearFilter: 1008,

	// Data types

	UnsignedByteType: 1009,
	ByteType: 1010,
	ShortType: 1011,
	UnsignedShortType: 1012,
	IntType: 1013,
	UnsignedIntType: 1014,
	FloatType: 1015,
	HalfFloatType: 1025,

	// Pixel types

	//UnsignedByteType: 1009,
	UnsignedShort4444Type: 1016,
	UnsignedShort5551Type: 1017,
	UnsignedShort565Type: 1018,

	// Pixel formats

	AlphaFormat: 1019,
	RGBFormat: 1020,
	RGBAFormat: 1021,
	LuminanceFormat: 1022,
	LuminanceAlphaFormat: 1023,
	// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders
	RGBEFormat: THREE.RGBAFormat, //1024;
	DepthFormat: 1026,

	// DDS / ST3C Compressed texture formats

	RGB_S3TC_DXT1_Format: 2001,
	RGBA_S3TC_DXT1_Format: 2002,
	RGBA_S3TC_DXT3_Format: 2003,
	RGBA_S3TC_DXT5_Format: 2004,

	// PVRTC compressed texture formats

	RGB_PVRTC_4BPPV1_Format: 2100,
	RGB_PVRTC_2BPPV1_Format: 2101,
	RGBA_PVRTC_4BPPV1_Format: 2102,
	RGBA_PVRTC_2BPPV1_Format: 2103,

	// ETC compressed texture formats

	RGB_ETC1_Format: 2151,

	// Loop styles for AnimationAction

	LoopOnce: 2200,
	LoopRepeat: 2201,
	LoopPingPong: 2202,

	// Interpolation

	InterpolateDiscrete: 2300,
	InterpolateLinear: 2301,
	InterpolateSmooth: 2302,

	// Interpolant ending modes

	ZeroCurvatureEnding: 2400,
	ZeroSlopeEnding: 2401,
	WrapAroundEnding: 2402,

	// Triangle Draw modes

	TrianglesDrawMode: 0,
	TriangleStripDrawMode: 1,
	TriangleFanDrawMode: 2,

	// Texture Encodings

	LinearEncoding: 3000, // No encoding at all.
	sRGBEncoding: 3001,
	GammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput

	// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.
	// These encodings should not specified as output encodings except in rare situations.
	RGBEEncoding: 3002, // AKA Radiance.
	LogLuvEncoding: 3003,
	RGBM7Encoding: 3004,
	RGBM16Encoding: 3005,
	RGBDEncoding: 3006, // MaxRange is 256.

	// Depth packing strategies

	BasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers
	RGBADepthPacking: 3201 // for packing into RGBA buffers.

} );

// File:src/math/Color.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = THREE.Math.euclideanModulo( h, 1 );
			s = THREE.Math.clamp( s, 0, 1 );
			l = THREE.Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = THREE.ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

};

THREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

// File:src/math/Quaternion.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function setFromUnitVectors( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			return this.normalize();

		};

	}(),

	inverse: function () {

		return this.conjugate().normalize();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

Object.assign( THREE.Quaternion, {

	slerp: function( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function(
			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

// File:src/math/Vector2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	get width() {

		return this.x;

	},

	set width( value ) {

		this.x = value;

	},

	get height() {

		return this.y;

	},

	set height( value ) {

		this.y = value;

	},

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) angle += 2 * Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

// File:src/math/Vector3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( vector ) {

		var scalar = vector.dot( this ) / vector.lengthSq();
	
		return this.copy( vector ).multiplyScalar( scalar );
	
	},

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setFromSpherical: function( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		return this.setFromMatrixColumn( m, 3 );

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		if ( typeof m === 'number' ) {

			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
			var temp = m
			m = index;
			index = temp;

		}

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];

		return this;

	}

};

// File:src/math/Vector4.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset === undefined ) offset = 0;

		index = index * attribute.itemSize + offset;

		this.x = attribute.array[ index ];
		this.y = attribute.array[ index + 1 ];
		this.z = attribute.array[ index + 2 ];
		this.w = attribute.array[ index + 3 ];

		return this;

	}

};

// File:src/math/Euler.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = THREE.Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function setFromQuaternion( q, order, update ) {

			if ( matrix === undefined ) matrix = new THREE.Matrix4();

			matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( matrix, order, update );

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function reorder( newOrder ) {

			q.setFromEuler( this );
			
			return this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new THREE.Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

// File:src/math/Line3.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function closestPointToPointParameter( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

// File:src/math/Box2.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Box3.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector3();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new THREE.Vector3();

		return function setFromObject( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry instanceof THREE.Geometry ) {

						var vertices = geometry.vertices;

						for ( var i = 0, il = vertices.length; i < il; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {

						var positions = geometry.attributes[ 'position' ].array;

						for ( var i = 0, il = positions.length; i < il; i += 3 ) {

							v1.fromArray( positions, i );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
				 point.y < this.min.y || point.y > this.max.y ||
				 point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
				 box.max.y < this.min.y || box.min.y > this.max.y ||
				 box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	intersectsSphere: ( function () {

		var closestPoint;

		return function intersectsSphere( sphere ) {

			if ( closestPoint === undefined ) closestPoint = new THREE.Vector3();

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= plane.constant && max >= plane.constant );

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new THREE.Vector3();

		return function getBoundingSphere( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

// File:src/math/Matrix3.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

THREE.Matrix3 = function () {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	setFromMatrix4: function( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[  8 ],
			me[ 1 ], me[ 5 ], me[  9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function applyToVector3Array( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix3( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix instanceof THREE.Matrix4 ) {

			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();
		}
		
		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
				"- just use .toArray instead." );

		return this.toArray( array, offset );

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	}

};

// File:src/math/Matrix4.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Matrix4 = function () {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new THREE.Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function extractRotation( m ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function lookAt( eye, target, up ) {

			if ( x === undefined ) {

				x = new THREE.Vector3();
				y = new THREE.Vector3();
				z = new THREE.Vector3();

			}

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.z += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function applyToVector3Array( array, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBuffer: function () {

		var v1;

		return function applyToBuffer( buffer, offset, length ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = buffer.length / buffer.itemSize;

			for ( var i = 0, j = offset; i < length; i ++, j ++ ) {

				v1.x = buffer.getX( j );
				v1.y = buffer.getY( j );
				v1.z = buffer.getZ( j );

				v1.applyMatrix4( this );

				buffer.setXYZ( v1.x, v1.y, v1.z );

			}

			return buffer;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset is deprecated " +
				"- just use .toArray instead." );

		return this.toArray( array, offset );

	},

	getPosition: function () {

		var v1;

		return function getPosition() {

			if ( v1 === undefined ) v1 = new THREE.Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			return v1.setFromMatrixColumn( this, 3 );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}
		
		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function decompose( position, quaternion, scale ) {

			if ( vector === undefined ) {

				vector = new THREE.Vector3();
				matrix = new THREE.Matrix4();

			}

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

};

// File:src/math/Ray.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function recast( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new THREE.Vector3();

		return function distanceSqToPoint( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new THREE.Vector3();
		var segDir = new THREE.Vector3();
		var diff = new THREE.Vector3();

		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new THREE.Vector3();

		return function intersectSphere( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},



	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, optionalTarget ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectsBox: ( function () {

		var v = new THREE.Vector3();

		return function intersectsBox( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

// File:src/math/Sphere.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new THREE.Box3();

		return function setFromPoints( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		// We use the following equation to compute the signed distance from
		// the center of the sphere to the plane.
		//
		// distance = q * n - d
		//
		// If this distance is greater than the radius of the sphere,
		// then there is no intersection.

		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();

		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

// File:src/math/Frustum.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function intersectsObject( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSprite: function () {

		var sphere = new THREE.Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function intersectsBox( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

// File:src/math/Plane.js

/**
 * @author bhouston / http://clara.io
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function setFromCoplanarPoints( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	intersectLine: function () {

		var v1 = new THREE.Vector3();

		return function intersectLine( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function applyMatrix4( matrix, optionalNormalMatrix ) {

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			// transform normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			// recalculate constant (like in setFromNormalAndCoplanarPoint)
			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

// File:src/math/Spherical.js

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

THREE.Spherical = function ( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

	return this;

};

THREE.Spherical.prototype = {

	constructor: THREE.Spherical,

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius.copy( other.radius );
		this.phi.copy( other.phi );
		this.theta.copy( other.theta );

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function() {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = vec3.length();

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
			this.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

		}

		return this;

	},

};

// File:src/math/Math.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function generateUUID() {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	random16: function () {

		console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
		return Math.random();

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * THREE.Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * THREE.Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

// File:src/math/Spline.js

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/math/Triangle.js

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function () {

	var v0 = new THREE.Vector3();

	return function normal( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function () {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function () {

	var v1 = new THREE.Vector3();

	return function containsPoint( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function area() {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	closestPointToPoint: function () {

		var plane, edgeList, projectedPoint, closestPoint;

		return function closestPointToPoint( point, optionalTarget ) {

			if ( plane === undefined ) {

				plane = new THREE.Plane();
				edgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];
				projectedPoint = new THREE.Vector3();
				closestPoint = new THREE.Vector3();

			}

			var result = optionalTarget || new THREE.Vector3();
			var minDistance = Infinity;

			// project the point onto the plane of the triangle

			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );

			// check if the projection lies within the triangle

			if( this.containsPoint( projectedPoint ) === true ) {

				// if so, this is the closest point

				result.copy( projectedPoint );

			} else {

				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );

				for( var i = 0; i < edgeList.length; i ++ ) {

					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

					var distance = projectedPoint.distanceToSquared( closestPoint );

					if( distance < minDistance ) {

						minDistance = distance;

						result.copy( closestPoint );

					}

				}

			}

			return result;

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

// File:src/math/Interpolant.js

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

THREE.Interpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

};

THREE.Interpolant.prototype = {

	constructor: THREE.Interpolant,

	evaluate: function( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[   i1   ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {
//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ;) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ;) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[   i1   ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function() {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function( i1, t0, t, t1 ) {

		throw new Error( "call to abstract method" );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function( i1, t0, t1 ) {

		// empty

	}

};

Object.assign( THREE.Interpolant.prototype, {

	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
		THREE.Interpolant.prototype.copySampleValue_,

	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
		THREE.Interpolant.prototype.copySampleValue_

} );

// File:src/math/interpolants/CubicInterpolant.js

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

THREE.CubicInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = -0;
	this._offsetPrev = -0;
	this._weightNext = -0;
	this._offsetNext = -0;

};

THREE.CubicInterpolant.prototype =
		Object.assign( Object.create( THREE.Interpolant.prototype ), {

	constructor: THREE.CubicInterpolant,

	DefaultSettings_: {

		endingStart: 	THREE.ZeroCurvatureEnding,
		endingEnd:		THREE.ZeroCurvatureEnding

	},

	intervalChanged_: function( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case THREE.ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case THREE.WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case THREE.ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case THREE.WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
		var sN =       wN   * ppp   -           wN      * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

// File:src/math/interpolants/DiscreteInterpolant.js

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

THREE.DiscreteInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.DiscreteInterpolant.prototype =
		Object.assign( Object.create( THREE.Interpolant.prototype ), {

	constructor: THREE.DiscreteInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

// File:src/math/interpolants/LinearInterpolant.js

/**
 * @author tschw
 */

THREE.LinearInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.LinearInterpolant.prototype =
		Object.assign( Object.create( THREE.Interpolant.prototype ), {

	constructor: THREE.LinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

// File:src/math/interpolants/QuaternionLinearInterpolant.js

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

THREE.QuaternionLinearInterpolant = function(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	THREE.Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

};

THREE.QuaternionLinearInterpolant.prototype =
		Object.assign( Object.create( THREE.Interpolant.prototype ), {

	constructor: THREE.QuaternionLinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			THREE.Quaternion.slerpFlat( result, 0,
					values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

// File:src/core/Clock.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = ( performance || Date ).now();

		this.oldTime = this.startTime;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = ( performance || Date ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

// File:src/core/EventDispatcher.js

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {};

Object.assign( THREE.EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [], i = 0;
			var length = listenerArray.length;

			for ( i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

// File:src/core/Layers.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Layers = function () {

	this.mask = 1;

};

THREE.Layers.prototype = {

	constructor: THREE.Layers,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

};

// File:src/core/Raycaster.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};

		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
				}
			}
		} );

	};

	function ascSort( a, b ) {

		return a.distance - b.distance;

	}

	function intersectObject( object, raycaster, intersects, recursive ) {

		if ( object.visible === false ) return;

		object.raycast( raycaster, intersects );

		if ( recursive === true ) {

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				intersectObject( children[ i ], raycaster, intersects, true );

			}

		}

	}

	//

	THREE.Raycaster.prototype = {

		constructor: THREE.Raycaster,

		linePrecision: 1,

		set: function ( origin, direction ) {

			// direction is assumed to be normalized (for accurate distance calculations)

			this.ray.set( origin, direction );

		},

		setFromCamera: function ( coords, camera ) {

			if ( camera instanceof THREE.PerspectiveCamera ) {

				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

			} else if ( camera instanceof THREE.OrthographicCamera ) {

				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

			} else {

				console.error( 'THREE.Raycaster: Unsupported camera type.' );

			}

		},

		intersectObject: function ( object, recursive ) {

			var intersects = [];

			intersectObject( object, this, intersects, recursive );

			intersects.sort( ascSort );

			return intersects;

		},

		intersectObjects: function ( objects, recursive ) {

			var intersects = [];

			if ( Array.isArray( objects ) === false ) {

				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;

			}

			for ( var i = 0, l = objects.length; i < l; i ++ ) {

				intersectObject( objects[ i ], this, intersects, recursive );

			}

			intersects.sort( ascSort );

			return intersects;

		}

	};

}( THREE ) );

// File:src/core/Object3D.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

THREE.Object3D = function () {

	Object.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = THREE.Object3D.DefaultUp.clone();

	var position = new THREE.Vector3();
	var rotation = new THREE.Euler();
	var quaternion = new THREE.Quaternion();
	var scale = new THREE.Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new THREE.Matrix4()
		},
		normalMatrix: {
			value: new THREE.Matrix3()
		}
	} );

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new THREE.Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

};

THREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );
THREE.Object3D.DefaultMatrixAutoUpdate = true;

Object.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function rotateOnAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function rotateX( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function rotateY( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function rotateZ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function translateOnAxis( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function translateX( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function translateY( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function translateZ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function worldToLocal( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function lookAt( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new THREE.Vector3();
		var scale = new THREE.Vector3();

		return function getWorldQuaternion( optionalTarget ) {

			var result = optionalTarget || new THREE.Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new THREE.Quaternion();

		return function getWorldRotation( optionalTarget ) {

			var result = optionalTarget || new THREE.Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();

		return function getWorldScale( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new THREE.Quaternion();

		return function getWorldDirection( optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		// meta is '' when called from JSON.stringify
		var isRootObject = ( meta === undefined || meta === '' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache ( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

THREE.Object3DIdCount = 0;

// File:src/core/Face3.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

// File:src/core/BufferAttribute.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferAttribute = function ( array, itemSize, normalized ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;
	this.normalized = normalized === true;

};

THREE.BufferAttribute.prototype = {

	constructor: THREE.BufferAttribute,

	get count() {

		return this.array.length / this.itemSize;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new THREE.Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new THREE.Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new THREE.Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new THREE.Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

THREE.Int8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int8Array( array ), itemSize );

};

THREE.Uint8Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8Array( array ), itemSize );

};

THREE.Uint8ClampedAttribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );

};

THREE.Int16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int16Array( array ), itemSize );

};

THREE.Uint16Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint16Array( array ), itemSize );

};

THREE.Int32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Int32Array( array ), itemSize );

};

THREE.Uint32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Uint32Array( array ), itemSize );

};

THREE.Float32Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float32Array( array ), itemSize );

};

THREE.Float64Attribute = function ( array, itemSize ) {

	return new THREE.BufferAttribute( new Float64Array( array ), itemSize );

};


// Deprecated

THREE.DynamicBufferAttribute = function ( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new THREE.BufferAttribute( array, itemSize ).setDynamic( true );

};

// File:src/core/InstancedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {

	THREE.BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;

THREE.InstancedBufferAttribute.prototype.copy = function ( source ) {

	THREE.BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBuffer = function ( array, stride ) {

	this.uuid = THREE.Math.generateUUID();

	this.array = array;
	this.stride = stride;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

};

THREE.InterleavedBuffer.prototype = {

	constructor: THREE.InterleavedBuffer,

	get length () {

		return this.array.length;

	},

	get count () {

		return this.array.length / this.stride;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.stride = source.stride;
		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

// File:src/core/InstancedInterleavedBuffer.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {

	THREE.InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

};

THREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;

THREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	THREE.InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

// File:src/core/InterleavedBufferAttribute.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {

	this.uuid = THREE.Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

};


THREE.InterleavedBufferAttribute.prototype = {

	constructor: THREE.InterleavedBufferAttribute,

	get length() {

		console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
		return this.array.length;

	},

	get count() {

		return this.data.count;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

// File:src/core/Geometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

THREE.Geometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

Object.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		}

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < positions.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new THREE.Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( geometry instanceof THREE.Geometry === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( mesh instanceof THREE.Mesh === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new THREE.Geometry().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

THREE.GeometryIdCount = 0;

// File:src/core/DirectGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'DirectGeometry';

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

};

Object.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {

	computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
	computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,

	computeFaceNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );

	},

	computeVertexNormals: function () {

		console.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );

	},

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

// File:src/core/BufferGeometry.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometry = function () {

	Object.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

};

Object.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new THREE.Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new THREE.Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.center().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object instanceof THREE.Points || object instanceof THREE.Line ) {

			var positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );
			var colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object instanceof THREE.Mesh ) {

			if ( geometry instanceof THREE.Geometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object instanceof THREE.Mesh ) {

			var direct = geometry.__directGeometry;

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		if ( geometry.verticesNeedUpdate === true ) {

			var attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			var attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			var attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			var attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			var attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes.position.array;

		if ( positions !== undefined ) {

			this.boundingBox.setFromArray( positions );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes.position;

			if ( positions ) {

				var array = positions.array;
				var center = this.boundingSphere.center;

				box.setFromArray( array );
				box.center( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = array.length; i < il; i += 3 ) {

					vector.fromArray( array, i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( geometry instanceof THREE.BufferGeometry === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toNonIndexed: function () {

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new THREE.BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			geometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new THREE.BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

THREE.BufferGeometry.MaxIndex = 65535;

// File:src/core/InstancedBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.InstancedBufferGeometry = function () {

	THREE.BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

};

THREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;

THREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {

	this.groups.push( {

		start: start,
		count: count,
		instances: instances

	} );

};

THREE.InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.instances );

	}

	return this;

};

// File:src/core/Uniform.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Uniform = function ( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

	this.dynamic = false;

};

THREE.Uniform.prototype = {

	constructor: THREE.Uniform,

	onUpdate: function ( callback ) {

		this.dynamic = true;
		this.onUpdateCallback = callback;

		return this;

	}

};

// File:src/animation/AnimationAction.js

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

THREE.AnimationAction = function() {

	throw new Error( "THREE.AnimationAction: " +
			"Use mixer.clipAction for construction." );

};

THREE.AnimationAction._new =
		function AnimationAction( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
			endingStart: 	THREE.ZeroCurvatureEnding,
			endingEnd:		THREE.ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants;	// bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null;			// for the memory manager
	this._byClipCacheIndex = null;		// for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = THREE.LoopRepeat;
	this._loopCount = -1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; 		// no. of repetitions when looping

	this.paused = false;				// false -> zero effective time scale
	this.enabled = true;				// true -> zero effective weight

	this.clampWhenFinished 	= false;	// keep feeding the last frame?

	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

};

THREE.AnimationAction._new.prototype = {

	constructor: THREE.AnimationAction._new,

	// State & Scheduling

	play: function() {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function() {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function() {

		this.paused = false;
		this.enabled = true;

		this.time = 0;			// restart clip
		this._loopCount = -1;	// forget previous loops
		this._startTime = null;	// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function() {

		var start = this._startTime;

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function() {

		return this._mixer._isActiveAction( this );

	},

	startAt: function( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function() {

		return this._effectiveWeight;

	},

	fadeIn: function( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function( fadeOutAction, duration, warp ) {

		var mixer = this._mixer;

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function() {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the weight stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 :timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function() {

		return this._effectiveTimeScale;

	},

	setDuration: function( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant(),
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function() {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function() {

		return this._mixer;

	},

	getClip: function() {

		return this._clip;

	},

	getRoot: function() {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function( time, deltaTime, timeDirection, accuIndex ) {
		// called by the mixer

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function( deltaTime ) {

		var time = this.time + deltaTime;

		if ( deltaTime === 0 ) return time;

		var duration = this._clip.duration,

			loop = this.loop,
			loopCount = this._loopCount;

		if ( loop === THREE.LoopOnce ) {

			if ( loopCount === -1 ) {
				// just started

				this.loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else break handle_stop;

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			var pingPong = ( loop === THREE.LoopPingPong );

			if ( loopCount === -1 ) {
				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings(
							true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings(
							this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {
				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending < 0 ) {
					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : -1
					} );

				} else {
					// keep running

					if ( pending === 0 ) {
						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {
				// invert time for the "pong round"

				this.time = time;
				return duration - time;

			}

		}

		this.time = time;
		return time;

	},

	_setEndings: function( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart 	= THREE.ZeroSlopeEnding;
			settings.endingEnd		= THREE.ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ?
						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

			} else {

				settings.endingStart = THREE.WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ?
						THREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = THREE.WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant(),
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

		return this;

	}

};


// File:src/animation/AnimationClip.js

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationClip = function ( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	this.uuid = THREE.Math.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

	// maybe only do these on demand, as doing them here could potentially slow down loading
	// but leaving these here during development as this ensures a lot of testing of these functions
	this.trim();
	this.optimize();

};

THREE.AnimationClip.prototype = {

	constructor: THREE.AnimationClip,

	resetDuration: function() {

		var tracks = this.tracks,
			duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max(
					duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};

// Static methods:

Object.assign( THREE.AnimationClip, {

	parse: function( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new THREE.AnimationClip( json.name, json.duration, tracks );

	},


	toJSON: function( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},


	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = THREE.AnimationUtils.getKeyframeOrder( times );
			times = THREE.AnimationUtils.sortedArray( times, 1, order );
			values = THREE.AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
					new THREE.NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
		}

		return new THREE.AnimationClip( name, -1, tracks );

	},

	findByName: function( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}
		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function( animation, bones, nodeName ) {

		if ( ! animation ) {

			console.error( "  no animation in JSONLoader data" );
			return null;

		}

		var addNonemptyTrack = function(
				trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				THREE.AnimationUtils.flattenJSON(
						animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || -1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets in a way exactly compatible
			// with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[k].morphTargets ) {

						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0;
							m !== animationKeys[k].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[k];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new THREE.NumberKeyframeTrack(
							'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {
				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
						THREE.VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

				addNonemptyTrack(
						THREE.QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

				addNonemptyTrack(
						THREE.VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new THREE.AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );

// File:src/animation/AnimationMixer.js

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.AnimationMixer = function( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

};

Object.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					THREE.AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new THREE.
				AnimationMixer._Action( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					THREE.AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function() {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			if ( action.enabled ) {

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// return this mixer's root target object
	getRoot: function() {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

THREE.AnimationMixer._Action = THREE.AnimationAction._new;

// Implementation details:

Object.assign( THREE.AnimationMixer.prototype, {

	_bindAction: function( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new THREE.PropertyMixer(
						THREE.PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 		knownActions: Array< _Action >	- used as prototypes
		// 		actionByRoot: _Action			- lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() { return scope._actions.length; },
				get inUse() { return scope._nActiveActions; }
			},
			bindings: {
				get total() { return scope._bindings.length; },
				get inUse() { return scope._nActiveBindings; }
			},
			controlInterpolants: {
				get total() { return scope._controlInterpolants.length; },
				get inUse() { return scope._nActiveControlInterpolants; }
			}

		};

	},

	// Memory management for _Action objects

	_isActiveAction: function( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( actions._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		remove_empty_map: {

			for ( var _ in bindingByName ) break remove_empty_map;

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function() {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new THREE.LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 )

} );

// File:src/animation/AnimationObjectGroup.js

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */

THREE.AnimationObjectGroup = function( var_args ) {

	this.uuid = THREE.Math.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0;			// threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices;		// for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = [];					// inside: string
	this._parsedPaths = [];				// inside: { we don't care, here }
	this._bindings = []; 				// inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() { return scope._objects.length; },
			get inUse() { return this.total - scope.nCachedObjects_;  }
		},

		get bindingsPerObject() { return scope._bindings.length; }

	};

};

THREE.AnimationObjectGroup.prototype = {

	constructor: THREE.AnimationObjectGroup,

	add: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push(
							new THREE.PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				var knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new THREE.PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject) {

				console.error( "Different objects with the same UUID " +
						"detected. Clean the caches or recreate your " +
						"infrastructure when reloading scenes..." );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function( path, parsedPath ) {
		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects,
				n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];

			bindingsForPath[ i ] =
					new THREE.PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function( path ) {
		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

};


// File:src/animation/AnimationUtils.js

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

THREE.AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function( array, from, to ) {

		if ( THREE.AnimationUtils.isTypedArray( array ) ) {

			return new array.constructor( array.subarray( from, to ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function( object ) {

		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {
			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {
			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

};

// File:src/animation/KeyframeTrack.js

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.KeyframeTrack = function ( name, times, values, interpolation ) {

	if( name === undefined ) throw new Error( "track name is undefined" );

	if( times === undefined || times.length === 0 ) {

		throw new Error( "no keyframes in track named " + name );

	}

	this.name = name;

	this.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

	this.validate();
	this.optimize();

};

THREE.KeyframeTrack.prototype = {

	constructor: THREE.KeyframeTrack,

	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,

	DefaultInterpolation: THREE.InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function( result ) {

		return new THREE.DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function( result ) {

		return new THREE.LinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function( result ) {

		return new THREE.CubicInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case THREE.InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case THREE.InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case THREE.InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( message );
			return;

		}

		this.createInterpolant = factoryMethod;

	},

	getInterpolation: function() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return THREE.InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return THREE.InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return THREE.InterpolateSmooth;

		}

	},

	getValueSize: function() {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function( timeOffset ) {

		if( timeOffset !== 0.0 ) {

			var times = this.times;

			for( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function( timeScale ) {

		if( timeScale !== 1.0 ) {

			var times = this.times;

			for( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== -1 && times[ to ] > endTime ) -- to;

		++ to; // inclusive -> exclusive bound

		if( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) to = Math.max( to , 1 ), from = to - 1;

			var stride = this.getValueSize();
			this.times = THREE.AnimationUtils.arraySlice( times, from, to );
			this.values = THREE.AnimationUtils.
					arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function() {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( "invalid value size in track", this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if( nKeys === 0 ) {

			console.error( "track is empty", this );
			valid = false;

		}

		var prevTime = null;

		for( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( "time is not a valid number", this, i, currTime );
				valid = false;
				break;

			}

			if( prevTime !== null && prevTime > currTime ) {

				console.error( "out of order keys", this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( THREE.AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( "value is not a valid number", this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function() {

		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),

			writeIndex = 1;

		for( var i = 1, n = times.length - 1; i <= n; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				// remove unnecessary keyframes same as their neighbors
				var offset = i * stride,
					offsetP = offset - stride,
					offsetN = offset + stride;

				for ( var j = 0; j !== stride; ++ j ) {

					var value = values[ offset + j ];

					if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

						keep = true;
						break;

					}

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}


				}

				++ writeIndex;

			}

		}

		if ( writeIndex !== times.length ) {

			this.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		}

		return this;

	}

};

// Static methods:

Object.assign( THREE.KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	parse: function( json ) {

		if( json.type === undefined ) {

			throw new Error( "track type undefined, can not parse" );

		}

		var trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			THREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we asssume a constructor compatible with the base
			return new trackType(
					json.name, json.times, json.values, json.interpolation );

		}

	},

	toJSON: function( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': THREE.AnimationUtils.convertArray( track.times, Array ),
				'values': THREE.AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	},

	_getTrackTypeForValueTypeName: function( typeName ) {

		switch( typeName.toLowerCase() ) {

			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":

				return THREE.NumberKeyframeTrack;

			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":

				return THREE.VectorKeyframeTrack;

			case "color":

				return THREE.ColorKeyframeTrack;

			case "quaternion":

				return THREE.QuaternionKeyframeTrack;

			case "bool":
			case "boolean":

				return THREE.BooleanKeyframeTrack;

			case "string":

				return THREE.StringKeyframeTrack;

		}

		throw new Error( "Unsupported typeName: " + typeName );

	}

} );

// File:src/animation/PropertyBinding.js

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.PropertyBinding = function ( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath ||
			THREE.PropertyBinding.parseTrackName( path );

	this.node = THREE.PropertyBinding.findNode(
			rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

};

THREE.PropertyBinding.prototype = {

	constructor: THREE.PropertyBinding,

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function() {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = THREE.PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

 		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( '  can not bind to material as node does not have a material', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( '  can not bind to objectName of node, undefined', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( "  trying to update property for track: " + nodeName +
					'.' + propertyName + " but it wasn't found.", targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {
			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					return;

				}

				if ( ! targetObject.geometry.morphTargets ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					return;

				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

						propertyIndex = i;
						break;

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( nodeProperty.length !== undefined ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

};

Object.assign( THREE.PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function() {},
	_setValue_unavailable: function() {},

	// initial state of these methods that calls 'bind'
	_getValue_unbound: THREE.PropertyBinding.prototype.getValue,
	_setValue_unbound: THREE.PropertyBinding.prototype.setValue,

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	]

} );

THREE.PropertyBinding.Composite =
		function( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath ||
			THREE.PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

};

THREE.PropertyBinding.Composite.prototype = {

	constructor: THREE.PropertyBinding.Composite,

	getValue: function( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

};

THREE.PropertyBinding.create = function( root, path, parsedPath ) {

	if ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {

		return new THREE.PropertyBinding( root, path, parsedPath );

	} else {

		return new THREE.PropertyBinding.Composite( root, path, parsedPath );

	}

};

THREE.PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//	  .bone[Armature.DEF_cog].position
	// created and tested via https://regex101.com/#javascript

	var re = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/;
	var matches = re.exec( trackName );

	if ( ! matches ) {

		throw new Error( "cannot parse trackName at all: " + trackName );

	}

	if ( matches.index === re.lastIndex ) {

		re.lastIndex++;

	}

	var results = {
		// directoryName: matches[ 1 ], // (tschw) currently unused
		nodeName: matches[ 3 ], 	// allowed to be null, specified root node.
		objectName: matches[ 5 ],
		objectIndex: matches[ 7 ],
		propertyName: matches[ 9 ],
		propertyIndex: matches[ 11 ]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {

		throw new Error( "can not parse propertyName from trackName: " + trackName );

	}

	return results;

};

THREE.PropertyBinding.findNode = function( root, nodeName ) {

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var searchSkeleton = function( skeleton ) {

			for( var i = 0; i < skeleton.bones.length; i ++ ) {

				var bone = skeleton.bones[ i ];

				if ( bone.name === nodeName ) {

					return bone;

				}
			}

			return null;

		};

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var searchNodeSubtree = function( children ) {

			for( var i = 0; i < children.length; i ++ ) {

				var childNode = children[ i ];

				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

					return childNode;

				}

				var result = searchNodeSubtree( childNode.children );

				if ( result ) return result;

			}

			return null;

		};

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;

};

// File:src/animation/PropertyMixer.js

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.PropertyMixer = function ( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':			mixFunction = this._slerp;		break;

		case 'string':
		case 'bool':

			bufferType = Array,		mixFunction = this._select;		break;

		default:					mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

};

THREE.PropertyMixer.prototype = {

	constructor: THREE.PropertyMixer,

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function() {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function() {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		THREE.Quaternion.slerpFlat( buffer, dstOffset,
				buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

};

// File:src/animation/tracks/BooleanKeyframeTrack.js

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.BooleanKeyframeTrack = function ( name, times, values ) {

	THREE.KeyframeTrack.call( this, name, times, values );

};

THREE.BooleanKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: THREE.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

// File:src/animation/tracks/ColorKeyframeTrack.js

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {

	THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.ColorKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited


	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

// File:src/animation/tracks/NumberKeyframeTrack.js

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {

	THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.NumberKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.NumberKeyframeTrack,

	ValueTypeName: 'number',

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

// File:src/animation/tracks/QuaternionKeyframeTrack.js

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {

	THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.QuaternionKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: THREE.InterpolateLinear,

	InterpolantFactoryMethodLinear: function( result ) {

		return new THREE.QuaternionLinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

// File:src/animation/tracks/StringKeyframeTrack.js

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {

	THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.StringKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: THREE.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

// File:src/animation/tracks/VectorKeyframeTrack.js

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

THREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {

	THREE.KeyframeTrack.call( this, name, times, values, interpolation );

};

THREE.VectorKeyframeTrack.prototype =
		Object.assign( Object.create( THREE.KeyframeTrack.prototype ), {

	constructor: THREE.VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

// File:src/audio/Audio.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

THREE.Audio = function ( listener ) {

	THREE.Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;
	this.source = this.context.createBufferSource();
	this.source.onended = this.onEnded.bind( this );

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this.filters = [];

};

THREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.source.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.source.buffer;
		source.loop = this.source.loop;
		source.onended = this.source.onended;
		source.start( 0, this.startTime );
		source.playbackRate.value = this.playbackRate;

		this.isPlaying = true;

		this.source = source;

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = this.context.currentTime;
		this.isPlaying = false;

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = 0;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.value = this.playbackRate;

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.source.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.loop = value;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},


	setVolume: function ( value ) {

		this.gain.gain.value = value;

		return this;

	}

} );

// File:src/audio/AudioAnalyser.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioAnalyser = function ( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

};

Object.assign( THREE.AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

// File:src/audio/AudioContext.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

Object.defineProperty( THREE, 'AudioContext', {

	get: ( function () {

		var context;

		return function get() {

			if ( context === undefined ) {

				context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return context;

		};

	} )()

} );

// File:src/audio/PositionalAudio.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PositionalAudio = function ( listener ) {

	THREE.Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

};

THREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {

	constructor: THREE.PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

	},

	updateMatrixWorld: ( function () {

		var position = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )()


} );

// File:src/audio/AudioListener.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AudioListener = function () {

	THREE.Object3D.call( this );

	this.type = 'AudioListener';

	this.context = THREE.AudioContext;

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

};

THREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.value = value;

	},

	updateMatrixWorld: ( function () {

		var position = new THREE.Vector3();
		var quaternion = new THREE.Quaternion();
		var scale = new THREE.Vector3();

		var orientation = new THREE.Vector3();

		return function updateMatrixWorld( force ) {

			THREE.Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			listener.setPosition( position.x, position.y, position.z );
			listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

		};

	} )()

} );

// File:src/cameras/Camera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );
THREE.Camera.prototype.constructor = THREE.Camera;

THREE.Camera.prototype.getWorldDirection = function () {

	var quaternion = new THREE.Quaternion();

	return function getWorldDirection( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function lookAt( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

THREE.Camera.prototype.copy = function ( source ) {

	THREE.Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

// File:src/cameras/CubeCamera.js

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	var options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera;

// File:src/cameras/OrthographicCamera.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {

	constructor: THREE.OrthographicCamera,

	copy: function ( source ) {

		THREE.Camera.prototype.copy.call( this, source );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null ) {

			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;

			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

	},

	toJSON: function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

// File:src/cameras/PerspectiveCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

THREE.PerspectiveCamera = function( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {

	constructor: THREE.PerspectiveCamera,

	copy: function ( source ) {

		THREE.Camera.prototype.copy.call( this, source );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return THREE.Math.RAD2DEG * 2 * Math.atan(
				Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan(
					THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( view !== null ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makeFrustum(
				left, left + width, top - height, top, near, this.far );

	},

	toJSON: function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

// File:src/cameras/StereoCamera.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.StereoCamera = function () {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.cameraL = new THREE.PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new THREE.PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

};

Object.assign( THREE.StereoCamera.prototype, {

	update: ( function () {

		var focus, fov, aspect, near, far;

		var eyeRight = new THREE.Matrix4();
		var eyeLeft = new THREE.Matrix4();

		return function update( camera ) {

			var needsUpdate = focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far;

			if ( needsUpdate ) {

				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSep = 0.064 / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );
				var xmin, xmax;

				// translate xOffset

				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;

				// for left eye

				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

		};

	} )()

} );

// File:src/lights/Light.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Light = function ( color, intensity ) {

	THREE.Object3D.call( this );

	this.type = 'Light';

	this.color = new THREE.Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

};

THREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Light,

	copy: function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		return data;

	}

} );

// File:src/lights/LightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LightShadow = function ( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new THREE.Vector2( 512, 512 );

	this.map = null;
	this.matrix = new THREE.Matrix4();

};

Object.assign( THREE.LightShadow.prototype, {

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

// File:src/lights/AmbientLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color, intensity ) {

	THREE.Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

};

THREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {

	constructor: THREE.AmbientLight

} );

// File:src/lights/DirectionalLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	this.shadow = new THREE.DirectionalLightShadow();

};

THREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {

	constructor: THREE.DirectionalLight,

	copy: function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

// File:src/lights/DirectionalLightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.DirectionalLightShadow = function ( light ) {

	THREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

};

THREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {

	constructor: THREE.DirectionalLightShadow

} );

// File:src/lights/HemisphereLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.groundColor = new THREE.Color( groundColor );

};

THREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {

	constructor: THREE.HemisphereLight,

	copy: function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

// File:src/lights/PointLight.js

/**
 * @author mrdoob / http://mrdoob.com/
 */


THREE.PointLight = function ( color, intensity, distance, decay ) {

	THREE.Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / ( 4 * Math.PI );
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );

};

THREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {

	constructor: THREE.PointLight,

	copy: function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

// File:src/lights/SpotLight.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {

	THREE.Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.target = new THREE.Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * Math.PI;
		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / Math.PI;
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new THREE.SpotLightShadow();

};

THREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {

	constructor: THREE.SpotLight,

	copy: function ( source ) {

		THREE.Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

// File:src/lights/SpotLightShadow.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SpotLightShadow = function () {

	THREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );

};

THREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {

	constructor: THREE.SpotLightShadow,

	update: function ( light ) {

		var fov = THREE.Math.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || 500;

		var camera = this.camera;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

	}

} );

// File:src/loaders/AudioLoader.js

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

THREE.AudioLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.AudioLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new THREE.XHRLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {

			var context = THREE.AudioContext;

			context.decodeAudioData( buffer, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

} );

// File:src/loaders/Cache.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

// File:src/loaders/Loader.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function createMaterial( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new THREE.Color();
			if ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = THREE.Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = THREE.Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: THREE.Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = THREE[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = THREE.BackSide;
						break;
					case 'doubleSided':
						json.side = THREE.DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = THREE.VertexColors;
						if ( value === 'face' ) json.vertexColors = THREE.FaceColors;
						break;
					default:
						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

THREE.Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

// File:src/loaders/XHRLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.XHRLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = THREE.Cache.get( url );

		if ( cached !== undefined ) {

			if ( onLoad ) {

				setTimeout( function () {

					onLoad( cached );

				}, 0 );

			}

			return cached;

		}

		var request = new XMLHttpRequest();
		request.overrideMimeType( 'text/plain' );
		request.open( 'GET', url, true );

		request.addEventListener( 'load', function ( event ) {

			var response = event.target.response;

			THREE.Cache.add( url, response );

			if ( this.status === 200 ) {

				if ( onLoad ) onLoad( response );

				scope.manager.itemEnd( url );

			} else if ( this.status === 0 ) {

				// Some browsers return HTTP Status 0 when using non-http protocol
				// e.g. 'file://' or 'data://'. Handle as success.

				console.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );

				if ( onLoad ) onLoad( response );

				scope.manager.itemEnd( url );

			} else {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}

		}, false );

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		request.addEventListener( 'error', function ( event ) {

			if ( onError ) onError( event );

			scope.manager.itemError( url );

		}, false );

		if ( this.responseType !== undefined ) request.responseType = this.responseType;
		if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

		request.send( null );

		scope.manager.itemStart( url );

		return request;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	}

} );

// File:src/loaders/FontLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.FontLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.FontLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( this.manager );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new THREE.Font( json );

	}

} );

// File:src/loaders/ImageLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.ImageLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
		image.onload = function () {

			URL.revokeObjectURL( image.src );
			if ( onLoad ) onLoad( image );

		};

		if ( url.indexOf( 'data:' ) === 0 ) {

			image.src = url;

		} else {

			var loader = new THREE.XHRLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'blob' );
			loader.load( url, function ( blob ) {

				image.src = URL.createObjectURL( blob );

			}, onProgress, onError );

		}

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

// File:src/loaders/JSONLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	this.withCredentials = false;

};

Object.assign( THREE.JSONLoader.prototype, {

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );

		var loader = new THREE.XHRLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				var type = metadata.type;

				if ( type !== undefined ) {

					if ( type.toLowerCase() === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( type.toLowerCase() === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new THREE.Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new THREE.Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new THREE.Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new THREE.Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new THREE.Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new THREE.Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new THREE.Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		}

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		}

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new THREE.Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];

			if ( json.animation !== undefined ) {

				animations.push( json.animation );

			}

			if ( json.animations !== undefined ) {

				if ( json.animations.length ) {

					animations = animations.concat( json.animations );

				} else {

					animations.push( json.animations );

				}

			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		}

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

} );

// File:src/loaders/LoadingManager.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

// File:src/loaders/BufferGeometryLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.BufferGeometryLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var index = json.data.index;

		var TYPED_ARRAYS = {
			'Int8Array': Int8Array,
			'Uint8Array': Uint8Array,
			'Uint8ClampedArray': Uint8ClampedArray,
			'Int16Array': Int16Array,
			'Uint16Array': Uint16Array,
			'Int32Array': Int32Array,
			'Uint32Array': Uint32Array,
			'Float32Array': Float32Array,
			'Float64Array': Float64Array
		};

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new THREE.Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

} );

// File:src/loaders/MaterialLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.textures = {};

};

Object.assign( THREE.MaterialLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	getTexture: function ( name ) {

		var textures = this.textures;

		if ( textures[ name ] === undefined ) {

			console.warn( 'THREE.MaterialLoader: Undefined texture', name );

		}

		return textures[ name ];

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;

		// for PointsMaterial
		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = this.getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = this.getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new THREE.Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );

		if ( json.envMap !== undefined ) {

			material.envMap = this.getTexture( json.envMap );
			material.combine = THREE.MultiplyOperation;

		}

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		// MultiMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

} );

// File:src/loaders/ObjectLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	this.texturePath = '';

};

Object.assign( THREE.ObjectLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures  = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new THREE[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new THREE[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new THREE[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new THREE[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new THREE [ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new THREE[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'IcosahedronGeometry':
					case 'OctahedronGeometry':
					case 'TetrahedronGeometry':

						geometry = new THREE[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new THREE[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new THREE[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new THREE[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new THREE[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = THREE.AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new THREE.LoadingManager( onLoad );

			var loader = new THREE.ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return THREE[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new THREE.Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;
				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );
				if ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );
				if ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );
				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
				if ( Array.isArray( data.wrap ) ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ] );
					texture.wrapT = parseConstant( data.wrap[ 1 ] );

				}

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function parseObject( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new THREE.SkinnedMesh( geometry, material );

					} else {

						object = new THREE.Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new THREE.LOD();

					break;

				case 'Line':

					object = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'PointCloud':
				case 'Points':

					object = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new THREE.Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new THREE.Group();

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		};

	}()

} );

// File:src/loaders/TextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.TextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new THREE.Texture();

		var loader = new THREE.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );
		loader.load( url, function ( image ) {

			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

// File:src/loaders/CubeTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

Object.assign( THREE.CubeTextureLoader.prototype, {

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new THREE.CubeTexture();

		var loader = new THREE.ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

// File:src/loaders/BinaryTextureLoader.js

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

THREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

Object.assign( THREE.BinaryTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new THREE.DataTexture();

		var loader = new THREE.XHRLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = THREE.LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

// File:src/loaders/CompressedTextureLoader.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

THREE.CompressedTextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

};

Object.assign( THREE.CompressedTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new THREE.CompressedTexture();
		texture.image = images;

		var loader = new THREE.XHRLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = THREE.LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = THREE.LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

// File:src/materials/Material.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	Object.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = THREE.NormalBlending;
	this.side = THREE.FrontSide;
	this.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading
	this.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = THREE.LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipShadows = false;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	get needsUpdate() {

		return this._needsUpdate;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.update();
		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue instanceof THREE.Color ) {

				currentValue.set( newValue );

			} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = meta === undefined;

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color instanceof THREE.Color ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();
		if ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;

		if ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap instanceof THREE.Texture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap instanceof THREE.Texture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();

		}
		if ( this.displacementMap instanceof THREE.Texture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap instanceof THREE.Texture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;
		if ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;
		if ( this.side !== THREE.FrontSide ) data.side = this.side;
		if ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;
		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache ( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.shading = source.shading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.premultipliedAlpha = source.premultipliedAlpha;

		this.overdraw = source.overdraw;

		this.visible = source.visible;
		this.clipShadows = source.clipShadows;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

Object.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );

THREE.MaterialIdCount = 0;

// File:src/materials/LineBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;

THREE.LineBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

// File:src/materials/LineDashedMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.lights = false;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;

THREE.LineDashedMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};

// File:src/materials/MeshBasicMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;

THREE.MeshBasicMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

// File:src/materials/MeshDepthMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = THREE.BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;

THREE.MeshDepthMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshLambertMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new THREE.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;

THREE.MeshLambertMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshNormalMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;

THREE.MeshNormalMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

// File:src/materials/MeshPhongMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new THREE.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;

THREE.MeshPhongMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshStandardMaterial.js

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

THREE.MeshStandardMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.roughness = 0.5;
	this.metalness = 0.5;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new THREE.Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;

THREE.MeshStandardMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

// File:src/materials/MeshPhysicalMaterial.js

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */

THREE.MeshPhysicalMaterial = function ( parameters ) {

	THREE.MeshStandardMaterial.call( this );

	this.defines = { 'PHYSICAL': '' };

	this.type = 'MeshPhysicalMaterial';

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.clearCoat = 0.0;
	this.clearCoatRoughness = 0.0;

	this.setValues( parameters );

};

THREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );
THREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;

THREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {

	THREE.MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = { 'PHYSICAL': '' };

	this.reflectivity = source.reflectivity;

	this.clearCoat = source.clearCoat;
	this.clearCoatRoughness = source.clearCoatRoughness;

	return this;

};

// File:src/materials/MultiMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MultiMaterial = function ( materials ) {

	this.uuid = THREE.Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = materials instanceof Array ? materials : [];

	this.visible = true;

};

THREE.MultiMaterial.prototype = {

	constructor: THREE.MultiMaterial,

	toJSON: function ( meta ) {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		var materials = this.materials;

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			var material = materials[ i ].toJSON( meta );
			delete material.metadata;

			output.materials.push( material );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

// File:src/materials/PointsMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

THREE.PointsMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.lights = false;

	this.setValues( parameters );

};

THREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;

THREE.PointsMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

// File:src/materials/ShaderMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;

THREE.ShaderMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = THREE.UniformsUtils.clone( source.uniforms );

	this.defines = source.defines;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

THREE.ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = THREE.Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

// File:src/materials/RawShaderMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RawShaderMaterial = function ( parameters ) {

	THREE.ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

};

THREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;

// File:src/materials/SpriteMaterial.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2()
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;

THREE.SpriteMaterial.prototype.copy = function ( source ) {

	THREE.Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	return this;

};

// File:src/materials/ShadowMaterial.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ShadowMaterial = function () {

	THREE.ShaderMaterial.call( this, {
		uniforms: THREE.UniformsUtils.merge( [
			THREE.UniformsLib[ "lights" ],
			{
				opacity: { value: 1.0 }
			}
		] ),
		vertexShader: THREE.ShaderChunk[ 'shadow_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]
	} );

	this.lights = true;
	this.transparent = true;

	Object.defineProperties( this, {
		opacity: {
			enumerable: true,
			get: function () {
				return this.uniforms.opacity.value;
			},
			set: function ( value ) {
				this.uniforms.opacity.value = value;
			}
		}
	} );

};

THREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );
THREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;

// File:src/textures/Texture.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );

	this.uuid = THREE.Math.generateUUID();

	this.name = '';
	this.sourceFile = '';

	this.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

};

THREE.Texture.DEFAULT_IMAGE = undefined;
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = THREE.Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== THREE.UVMapping )  return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case THREE.RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case THREE.RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case THREE.ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case THREE.MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

Object.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );

THREE.TextureIdCount = 0;

// File:src/textures/DepthTexture.js

/**
 * @author Matt DesLauriers / @mattdesl
 */

THREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );

  this.image = { width: width, height: height };

  this.type = type !== undefined ? type : THREE.UnsignedShortType;

  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

  this.flipY = false;
  this.generateMipmaps  = false;

};

THREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DepthTexture.prototype.constructor = THREE.DepthTexture;

// File:src/textures/CanvasTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

};

THREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;

// File:src/textures/CubeTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;

	THREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

};

THREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture;

Object.defineProperty( THREE.CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

// File:src/textures/CompressedTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;

// File:src/textures/DataTexture.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;

	this.flipY = false;
	this.generateMipmaps  = false;

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.DataTexture.prototype.constructor = THREE.DataTexture;

// File:src/textures/VideoTexture.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	THREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

};

THREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture;

// File:src/objects/Group.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Group = function () {

	THREE.Object3D.call( this );

	this.type = 'Group';

};

THREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Group

} );

// File:src/objects/Points.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Points = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
	this.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Points,

	raycast: ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new THREE.Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

// File:src/objects/Line.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new THREE.LineSegments( geometry, material );

	}

	THREE.Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

};

THREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Line,

	raycast: ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new THREE.Vector3();
			var vEnd = new THREE.Vector3();
			var interSegment = new THREE.Vector3();
			var interRay = new THREE.Vector3();
			var step = this instanceof THREE.LineSegments ? 2 : 1;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

// File:src/objects/LineSegments.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LineSegments = function ( geometry, material ) {

	THREE.Line.call( this, geometry, material );

	this.type = 'LineSegments';

};

THREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {

	constructor: THREE.LineSegments

} );

// File:src/objects/Mesh.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = THREE.TrianglesDrawMode;

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Mesh,

	setDrawMode: function ( value ) {

		this.drawMode = value;

	},

	copy: function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.drawMode = source.drawMode;

		return this;

	},

	updateMorphTargets: function () {

		if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

			this.morphTargetBase = - 1;
			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

			}

		}

	},

	getMorphTargetIndexByName: function ( name ) {

		if ( this.morphTargetDictionary[ name ] !== undefined ) {

			return this.morphTargetDictionary[ name ];

		}

		console.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );

		return 0;

	},

	raycast: ( function () {

		var inverseMatrix = new THREE.Matrix4();
		var ray = new THREE.Ray();
		var sphere = new THREE.Sphere();

		var vA = new THREE.Vector3();
		var vB = new THREE.Vector3();
		var vC = new THREE.Vector3();

		var tempA = new THREE.Vector3();
		var tempB = new THREE.Vector3();
		var tempC = new THREE.Vector3();

		var uvA = new THREE.Vector2();
		var uvB = new THREE.Vector2();
		var uvC = new THREE.Vector2();

		var barycoord = new THREE.Vector3();

		var intersectionPoint = new THREE.Vector3();
		var intersectionPointWorld = new THREE.Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			THREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

			var intersect;
			var material = object.material;

			if ( material.side === THREE.BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );

			}

			if ( intersect === null ) return null;

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uvs ) {

					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );

					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

				}

				intersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			var uvs, intersection;

			if ( geometry instanceof THREE.BufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.uv !== undefined ) {

					uvs = attributes.uv.array;

				}

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );

						}

					}

				} else {


					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

						a = i / 3;
						b = a + 1;
						c = a + 2;

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var fvA, fvB, fvC;
				var isFaceMaterial = material instanceof THREE.MultiMaterial;
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

// File:src/objects/Bone.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.Bone = function ( skin ) {

	THREE.Object3D.call( this );

	this.type = 'Bone';

	this.skin = skin;

};

THREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Bone,

	copy: function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.skin = source.skin;

		return this;

	}

} );

// File:src/objects/Skeleton.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

THREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new THREE.Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new THREE.Matrix4() );

			}

		}

	}

};

Object.assign( THREE.Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new THREE.Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent instanceof THREE.Bone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: ( function () {

		var offsetMatrix = new THREE.Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.toArray( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )(),

	clone: function () {

		return new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	}

} );

// File:src/objects/SkinnedMesh.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new THREE.Matrix4();
	this.bindMatrixInverse = new THREE.Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new THREE.Bone( this );
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null &&
					bones[ gbone.parent ] !== undefined ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

};


THREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {

	constructor: THREE.SkinnedMesh,

	bind: function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		if ( this.geometry instanceof THREE.Geometry ) {

			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1, 0, 0, 0 ); // do something reasonable

				}

			}

		} else if ( this.geometry instanceof THREE.BufferGeometry ) {

			var vec = new THREE.Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0; i < skinWeight.count; i ++ ) {

				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );

				var scale = 1.0 / vec.lengthManhattan();

				if ( scale !== Infinity ) {

					vec.multiplyScalar( scale );

				} else {

					vec.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

			}

		}

	},

	updateMatrixWorld: function( force ) {

		THREE.Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function() {

		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

	}

} );

// File:src/objects/LOD.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

};


THREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.LOD,

	copy: function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	},

	raycast: ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() ),

	update: function () {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}(),

	toJSON: function ( meta ) {

		var data = THREE.Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

// File:src/objects/Sprite.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = function ( material ) {

	THREE.Object3D.call( this );

	this.type = 'Sprite';

	this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

};

THREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.Sprite,

	raycast: ( function () {

		var matrixPosition = new THREE.Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y / 4;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() ),

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	}

} );

// File:src/objects/LensFlare.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

	constructor: THREE.LensFlare,

	copy: function ( source ) {

		THREE.Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	},

	add: function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new THREE.Color( 0xffffff );
		if ( blending === undefined ) blending = THREE.NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	},

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	updateLensFlares: function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	}

} );

// File:src/scenes/Scene.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );
THREE.Scene.prototype.constructor = THREE.Scene;

THREE.Scene.prototype.copy = function ( source, recursive ) {

	THREE.Object3D.prototype.copy.call( this, source, recursive );

	if ( source.background !== null ) this.background = source.background.clone();
	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

// File:src/scenes/Fog.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

// File:src/scenes/FogExp2.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

// File:src/renderers/shaders/ShaderChunk.js

THREE.ShaderChunk = {};

// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl

THREE.ShaderChunk[ 'alphamap_fragment' ] = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl

THREE.ShaderChunk[ 'alphamap_pars_fragment' ] = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl

THREE.ShaderChunk[ 'alphatest_fragment' ] = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl

THREE.ShaderChunk[ 'aomap_fragment' ] = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl

THREE.ShaderChunk[ 'aomap_pars_fragment' ] = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";

// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl

THREE.ShaderChunk[ 'begin_vertex' ] = "\nvec3 transformed = vec3( position );\n";

// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl

THREE.ShaderChunk[ 'beginnormal_vertex' ] = "\nvec3 objectNormal = vec3( normal );\n";

// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl

THREE.ShaderChunk[ 'bsdfs' ] = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl

THREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl

THREE.ShaderChunk[ 'clipping_planes_fragment' ] = "#if NUM_CLIPPING_PLANES > 0\n	for ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\n		vec4 plane = clippingPlanes[ i ];\n		if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl

THREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = "#if NUM_CLIPPING_PLANES > 0\n	#if ! defined( PHYSICAL ) && ! defined( PHONG )\n		varying vec3 vViewPosition;\n	#endif\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl

THREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	varying vec3 vViewPosition;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl

THREE.ShaderChunk[ 'clipping_planes_vertex' ] = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n	vViewPosition = - mvPosition.xyz;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl

THREE.ShaderChunk[ 'color_fragment' ] = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl

THREE.ShaderChunk[ 'color_pars_fragment' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl

THREE.ShaderChunk[ 'color_pars_vertex' ] = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif";

// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl

THREE.ShaderChunk[ 'color_vertex' ] = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif";

// File:src/renderers/shaders/ShaderChunk/common.glsl

THREE.ShaderChunk[ 'common' ] = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract(sin(sn) * c);\n}\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n";

// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl

THREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n	vec3 absDirection = abs(direction);\n	int face = -1;\n	if( absDirection.x > absDirection.z ) {\n		if(absDirection.x > absDirection.y )\n			face = direction.x > 0.0 ? 0 : 3;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	else {\n		if(absDirection.z > absDirection.y )\n			face = direction.z > 0.0 ? 2 : 5;\n		else\n			face = direction.y > 0.0 ? 1 : 4;\n	}\n	return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n	float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n	float dxRoughness = dFdx(roughness);\n	float dyRoughness = dFdy(roughness);\n	vec3 dx = dFdx( vec * scale * dxRoughness );\n	vec3 dy = dFdy( vec * scale * dyRoughness );\n	float d = max( dot( dx, dx ), dot( dy, dy ) );\n	d = clamp(d, 1.0, cubeUV_rangeClamp);\n	float mipLevel = 0.5 * log2(d);\n	return vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n	mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n	float a = 16.0 * cubeUV_rcpTextureSize;\n	vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n	vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n	float powScale = exp2_packed.x * exp2_packed.y;\n	float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n	float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n	bool bRes = mipLevel == 0.0;\n	scale =  bRes && (scale < a) ? a : scale;\n	vec3 r;\n	vec2 offset;\n	int face = getFaceFromDirection(direction);\n	float rcpPowScale = 1.0 / powScale;\n	if( face == 0) {\n		r = vec3(direction.x, -direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 1) {\n		r = vec3(direction.y, direction.x, direction.z);\n		offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 2) {\n		r = vec3(direction.z, direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n	}\n	else if( face == 3) {\n		r = vec3(direction.x, direction.z, direction.y);\n		offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else if( face == 4) {\n		r = vec3(direction.y, direction.x, -direction.z);\n		offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	else {\n		r = vec3(direction.z, -direction.x, direction.y);\n		offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n		offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n	}\n	r = normalize(r);\n	float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n	vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n	vec2 base = offset + vec2( texelOffset );\n	return base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n	float roughnessVal = roughness* cubeUV_maxLods3;\n	float r1 = floor(roughnessVal);\n	float r2 = r1 + 1.0;\n	float t = fract(roughnessVal);\n	vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n	float s = mipInfo.y;\n	float level0 = mipInfo.x;\n	float level1 = level0 + 1.0;\n	level1 = level1 > 5.0 ? 5.0 : level1;\n	level0 += min( floor( s + 0.5 ), 5.0 );\n	vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n	vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n	vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n	vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n	vec4 result = mix(color10, color20, t);\n	return vec4(result.rgb, 1.0);\n}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl

THREE.ShaderChunk[ 'defaultnormal_vertex' ] = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl

THREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl

THREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl

THREE.ShaderChunk[ 'encodings_pars_fragment' ] = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl

THREE.ShaderChunk[ 'encodings_fragment' ] = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl

THREE.ShaderChunk[ 'envmap_fragment' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl

THREE.ShaderChunk[ 'envmap_pars_fragment' ] = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n		varying vec3 vWorldPosition;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl

THREE.ShaderChunk[ 'envmap_pars_vertex' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl

THREE.ShaderChunk[ 'envmap_vertex' ] = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl

THREE.ShaderChunk[ 'fog_fragment' ] = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl

THREE.ShaderChunk[ 'fog_pars_fragment' ] = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";

// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl

THREE.ShaderChunk[ 'lightmap_fragment' ] = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl

THREE.ShaderChunk[ 'lightmap_pars_fragment' ] = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";

// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl

THREE.ShaderChunk[ 'lights_lambert_vertex' ] = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl

THREE.ShaderChunk[ 'lights_pars' ] = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#include <normal_flip>\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#include <normal_flip>\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n			envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		#endif\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_fragment' ] = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n";

// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl

THREE.ShaderChunk[ 'lights_physical_fragment' ] = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n	material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n	material.clearCoat = saturate( clearCoat );	material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl

THREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = "struct PhysicalMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n	#ifndef STANDARD\n		float clearCoat;\n		float clearCoatRoughness;\n	#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	#ifndef STANDARD\n		reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n	#ifndef STANDARD\n		reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n	#endif\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

// File:src/renderers/shaders/ShaderChunk/lights_template.glsl

THREE.ShaderChunk[ 'lights_template' ] = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointDirectLightIrradiance( pointLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	#ifndef STANDARD\n		vec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n	#else\n		vec3 clearCoatRadiance = vec3( 0.0 );\n	#endif\n		\n	RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_fragment' ] = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif";

// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl

THREE.ShaderChunk[ 'logdepthbuf_vertex' ] = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl

THREE.ShaderChunk[ 'map_fragment' ] = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl

THREE.ShaderChunk[ 'map_pars_fragment' ] = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl

THREE.ShaderChunk[ 'map_particle_fragment' ] = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl

THREE.ShaderChunk[ 'map_particle_pars_fragment' ] = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl

THREE.ShaderChunk[ 'metalnessmap_fragment' ] = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl

THREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl

THREE.ShaderChunk[ 'morphnormal_vertex' ] = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif";

// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl

THREE.ShaderChunk[ 'morphtarget_vertex' ] = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_flip.glsl

THREE.ShaderChunk[ 'normal_flip' ] = "#ifdef DOUBLE_SIDED\n	float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n	float flipNormal = 1.0;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl

THREE.ShaderChunk[ 'normal_fragment' ] = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl

THREE.ShaderChunk[ 'normalmap_pars_fragment' ] = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/packing.glsl

THREE.ShaderChunk[ 'packing' ] = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl

THREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl

THREE.ShaderChunk[ 'project_vertex' ] = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl

THREE.ShaderChunk[ 'roughnessmap_fragment' ] = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl

THREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl

THREE.ShaderChunk[ 'shadowmap_vertex' ] = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl

THREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n";

// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl

THREE.ShaderChunk[ 'skinbase_vertex' ] = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl

THREE.ShaderChunk[ 'skinning_pars_vertex' ] = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl

THREE.ShaderChunk[ 'skinning_vertex' ] = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl

THREE.ShaderChunk[ 'skinnormal_vertex' ] = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl

THREE.ShaderChunk[ 'specularmap_fragment' ] = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";

// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl

THREE.ShaderChunk[ 'specularmap_pars_fragment' ] = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";

// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl

THREE.ShaderChunk[ 'tonemapping_fragment' ] = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl

THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl

THREE.ShaderChunk[ 'uv2_pars_fragment' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl

THREE.ShaderChunk[ 'uv2_pars_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl

THREE.ShaderChunk[ 'uv2_vertex' ] = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl

THREE.ShaderChunk[ 'uv_pars_fragment' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif";

// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl

THREE.ShaderChunk[ 'uv_pars_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n";

// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl

THREE.ShaderChunk[ 'uv_vertex' ] = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl

THREE.ShaderChunk[ 'worldpos_vertex' ] = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n";

// File:src/renderers/shaders/UniformsUtils.js

/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix3 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

// File:src/renderers/shaders/UniformsLib.js

/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse": { value: new THREE.Color( 0xeeeeee ) },
		"opacity": { value: 1.0 },

		"map": { value: null },
		"offsetRepeat": { value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"specularMap": { value: null },
		"alphaMap": { value: null },

		"envMap": { value: null },
		"flipEnvMap": { value: - 1 },
		"reflectivity": { value: 1.0 },
		"refractionRatio": { value: 0.98 }

	},

	aomap: {

		"aoMap": { value: null },
		"aoMapIntensity": { value: 1 }

	},

	lightmap: {

		"lightMap": { value: null },
		"lightMapIntensity": { value: 1 }

	},

	emissivemap: {

		"emissiveMap": { value: null }

	},

	bumpmap: {

		"bumpMap": { value: null },
		"bumpScale": { value: 1 }

	},

	normalmap: {

		"normalMap": { value: null },
		"normalScale": { value: new THREE.Vector2( 1, 1 ) }

	},

	displacementmap: {

		"displacementMap": { value: null },
		"displacementScale": { value: 1 },
		"displacementBias": { value: 0 }

	},

	roughnessmap: {

		"roughnessMap": { value: null }

	},

	metalnessmap: {

		"metalnessMap": { value: null }

	},

	fog: {

		"fogDensity": { value: 0.00025 },
		"fogNear": { value: 1 },
		"fogFar": { value: 2000 },
		"fogColor": { value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor": { value: [] },

		"directionalLights": { value: [], properties: {
			"direction": {},
			"color": {},

			"shadow": {},
			"shadowBias": {},
			"shadowRadius": {},
			"shadowMapSize": {}
		} },

		"directionalShadowMap": { value: [] },
		"directionalShadowMatrix": { value: [] },

		"spotLights": { value: [], properties: {
			"color": {},
			"position": {},
			"direction": {},
			"distance": {},
			"coneCos": {},
			"penumbraCos": {},
			"decay": {},

			"shadow": {},
			"shadowBias": {},
			"shadowRadius": {},
			"shadowMapSize": {}
		} },

		"spotShadowMap": { value: [] },
		"spotShadowMatrix": { value: [] },

		"pointLights": { value: [], properties: {
			"color": {},
			"position": {},
			"decay": {},
			"distance": {},

			"shadow": {},
			"shadowBias": {},
			"shadowRadius": {},
			"shadowMapSize": {}
		} },

		"pointShadowMap": { value: [] },
		"pointShadowMatrix": { value: [] },

		"hemisphereLights": { value: [], properties: {
			"direction": {},
			"skyColor": {},
			"groundColor": {}
		} }

	},

	points: {

		"diffuse": { value: new THREE.Color( 0xeeeeee ) },
		"opacity": { value: 1.0 },
		"size": { value: 1.0 },
		"scale": { value: 1.0 },
		"map": { value: null },
		"offsetRepeat": { value: new THREE.Vector4( 0, 0, 1, 1 ) }

	}

};

// File:src/renderers/shaders/ShaderLib/cube_frag.glsl

THREE.ShaderChunk[ 'cube_frag' ] = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/cube_vert.glsl

THREE.ShaderChunk[ 'cube_vert' ] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/depth_frag.glsl

THREE.ShaderChunk[ 'depth_frag' ] = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n	#endif\n}\n";

// File:src/renderers/shaders/ShaderLib/depth_vert.glsl

THREE.ShaderChunk[ 'depth_vert' ] = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl

THREE.ShaderChunk[ 'distanceRGBA_frag' ] = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	gl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl

THREE.ShaderChunk[ 'distanceRGBA_vert' ] = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition;\n}\n";

// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl

THREE.ShaderChunk[ 'equirect_frag' ] = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl

THREE.ShaderChunk[ 'equirect_vert' ] = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl

THREE.ShaderChunk[ 'linedashed_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl

THREE.ShaderChunk[ 'linedashed_vert' ] = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl

THREE.ShaderChunk[ 'meshbasic_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl

THREE.ShaderChunk[ 'meshbasic_vert' ] = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	#include <envmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl

THREE.ShaderChunk[ 'meshlambert_frag' ] = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <normal_flip>\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl

THREE.ShaderChunk[ 'meshlambert_vert' ] = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl

THREE.ShaderChunk[ 'meshphong_frag' ] = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl

THREE.ShaderChunk[ 'meshphong_vert' ] = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl

THREE.ShaderChunk[ 'meshphysical_frag' ] = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n	uniform float clearCoat;\n	uniform float clearCoatRoughness;\n#endif\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_flip>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl

THREE.ShaderChunk[ 'meshphysical_vert' ] = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/normal_frag.glsl

THREE.ShaderChunk[ 'normal_frag' ] = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	gl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\n	#include <logdepthbuf_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/normal_vert.glsl

THREE.ShaderChunk[ 'normal_vert' ] = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/points_frag.glsl

THREE.ShaderChunk[ 'points_frag' ] = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n";

// File:src/renderers/shaders/ShaderLib/points_vert.glsl

THREE.ShaderChunk[ 'points_vert' ] = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl

THREE.ShaderChunk[ 'shadow_frag' ] = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl

THREE.ShaderChunk[ 'shadow_vert' ] = "#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n";

// File:src/renderers/shaders/ShaderLib.js

/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'aomap' ],
			THREE.UniformsLib[ 'fog' ]

		] ),

		vertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'aomap' ],
			THREE.UniformsLib[ 'lightmap' ],
			THREE.UniformsLib[ 'emissivemap' ],
			THREE.UniformsLib[ 'fog' ],
			THREE.UniformsLib[ 'lights' ],

			{
				"emissive" : { value: new THREE.Color( 0x000000 ) }
			}

		] ),

		vertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'aomap' ],
			THREE.UniformsLib[ 'lightmap' ],
			THREE.UniformsLib[ 'emissivemap' ],
			THREE.UniformsLib[ 'bumpmap' ],
			THREE.UniformsLib[ 'normalmap' ],
			THREE.UniformsLib[ 'displacementmap' ],
			THREE.UniformsLib[ 'fog' ],
			THREE.UniformsLib[ 'lights' ],

			{
				"emissive" : { value: new THREE.Color( 0x000000 ) },
				"specular" : { value: new THREE.Color( 0x111111 ) },
				"shininess": { value: 30 }
			}

		] ),

		vertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]

	},

	'standard': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'aomap' ],
			THREE.UniformsLib[ 'lightmap' ],
			THREE.UniformsLib[ 'emissivemap' ],
			THREE.UniformsLib[ 'bumpmap' ],
			THREE.UniformsLib[ 'normalmap' ],
			THREE.UniformsLib[ 'displacementmap' ],
			THREE.UniformsLib[ 'roughnessmap' ],
			THREE.UniformsLib[ 'metalnessmap' ],
			THREE.UniformsLib[ 'fog' ],
			THREE.UniformsLib[ 'lights' ],

			{
				"emissive" : { value: new THREE.Color( 0x000000 ) },
				"roughness": { value: 0.5 },
				"metalness": { value: 0 },
				"envMapIntensity" : { value: 1 }, // temporary
			}

		] ),

		vertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]

	},

	'points': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'points' ],
			THREE.UniformsLib[ 'fog' ]

		] ),

		vertexShader: THREE.ShaderChunk[ 'points_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'points_frag' ]

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'fog' ],

			{
				"scale"    : { value: 1 },
				"dashSize" : { value: 1 },
				"totalSize": { value: 2 }
			}

		] ),

		vertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]

	},

	'depth': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ 'common' ],
			THREE.UniformsLib[ 'displacementmap' ]

		] ),

		vertexShader: THREE.ShaderChunk[ 'depth_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'depth_frag' ]

	},

	'normal': {

		uniforms: {

			"opacity" : { value: 1.0 }

		},

		vertexShader: THREE.ShaderChunk[ 'normal_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'normal_frag' ]

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: {
			"tCube": { value: null },
			"tFlip": { value: - 1 }
		},

		vertexShader: THREE.ShaderChunk[ 'cube_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'cube_frag' ]

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'equirect': {

		uniforms: {
			"tEquirect": { value: null },
			"tFlip": { value: - 1 }
		},

		vertexShader: THREE.ShaderChunk[ 'equirect_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]

	},

	'distanceRGBA': {

		uniforms: {

			"lightPos": { value: new THREE.Vector3() }

		},

		vertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],
		fragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]

	}

};

THREE.ShaderLib[ 'physical' ] = {

	uniforms: THREE.UniformsUtils.merge( [

		THREE.ShaderLib[ 'standard' ].uniforms,

		{
			"clearCoat": { value: 0 },
			"clearCoatRoughness": { value: 0 }
		}

	] ),

	vertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],
	fragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]

};

// File:src/renderers/WebGLRenderer.js

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_depth = parameters.depth !== undefined ? parameters.depth : true,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = THREE.LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

	// internal state cache

	_currentProgram = null,
	_currentRenderTarget = null,
	_currentFramebuffer = null,
	_currentMaterialId = - 1,
	_currentGeometryProgram = '',
	_currentCamera = null,

	_currentScissor = new THREE.Vector4(),
	_currentScissorTest = null,

	_currentViewport = new THREE.Vector4(),

	//

	_usedTextureUnits = 0,

	//

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0,

	_width = _canvas.width,
	_height = _canvas.height,

	_pixelRatio = 1,

	_scissor = new THREE.Vector4( 0, 0, _width, _height ),
	_scissorTest = false,

	_viewport = new THREE.Vector4( 0, 0, _width, _height ),

	// frustum

	_frustum = new THREE.Frustum(),

	// clipping

	_clipping = new THREE.WebGLClipping(),
	_clippingEnabled = false,
	_localClippingEnabled = false,

	_sphere = new THREE.Sphere(),

	// camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_lights = {

		hash: '',

		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],

		shadows: []

	},

	// info

	_infoRender = {

		calls: 0,
		vertices: 0,
		faces: 0,
		points: 0

	};

	this.info = {

		render: _infoRender,
		memory: {

			geometries: 0,
			textures: 0

		},
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new THREE.WebGLExtensions( _gl );

	extensions.get( 'WEBGL_depth_texture' );
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		THREE.BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );

	var state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new THREE.WebGLProperties();
	var textures = new THREE.WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
	var objects = new THREE.WebGLObjects( _gl, properties, this.info );
	var programCache = new THREE.WebGLPrograms( this, capabilities );
	var lightCache = new THREE.WebGLLights();

	this.info.programs = programCache.programs;

	var bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	var backgroundCamera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	var backgroundCamera2 = new THREE.PerspectiveCamera();
	var backgroundPlaneMesh = new THREE.Mesh(
		new THREE.PlaneBufferGeometry( 2, 2 ),
		new THREE.MeshBasicMaterial( { depthTest: false, depthWrite: false } )
	);
	var backgroundBoxShader = THREE.ShaderLib[ 'cube' ];
	var backgroundBoxMesh = new THREE.Mesh(
		new THREE.BoxBufferGeometry( 5, 5, 5 ),
		new THREE.ShaderMaterial( {
			uniforms: backgroundBoxShader.uniforms,
			vertexShader: backgroundBoxShader.vertexShader,
			fragmentShader: backgroundBoxShader.fragmentShader,
			depthTest: false,
			depthWrite: false,
			side: THREE.BackSide
		} )
	);
	objects.update( backgroundPlaneMesh );
	objects.update( backgroundBoxMesh );

	//

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	function glClearColor( r, g, b, a ) {

		if ( _premultipliedAlpha === true ) {

			r *= a; g *= a; b *= a;

		}

		state.clearColor( r, g, b, a );

	}

	function setDefaultGLState() {

		state.init();

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.properties = properties;
	this.state = state;

	// shadow map

	var shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new THREE.SpritePlugin( this, sprites );
	var lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = function () {

		return capabilities.getMaxAnisotropy();

	};

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _viewport.z, _viewport.w, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		state.viewport( _viewport.set( x, y, width, height ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		state.scissor( _scissor.set( x, y, width, height ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		transparentObjects = [];
		transparentObjectsLastIndex = -1;
		opaqueObjects = [];
		opaqueObjectsLastIndex = -1;

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( absNumericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			program.getUniforms().setValue(
					_gl, 'morphTargetInfluences', morphInfluences );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataStart = 0;
		var dataCount = Infinity;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start;
		var rangeCount = geometry.drawRange.count;

		var groupStart = group !== null ? group.start : 0;
		var groupCount = group !== null ? group.count : Infinity;

		var drawStart = Math.max( dataStart, rangeStart, groupStart );
		var drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		//

		if ( object instanceof THREE.Mesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case THREE.TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case THREE.TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case THREE.TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object instanceof THREE.Line ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object instanceof THREE.LineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object instanceof THREE.Points ) {

			renderer.setMode( _gl.POINTS );

		}

		if ( geometry instanceof THREE.InstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry instanceof THREE.InstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var type = _gl.FLOAT;
					var array = geometryAttribute.array;
					var normalized = geometryAttribute.normalized;

					if ( array instanceof Float32Array ) {

						type = _gl.FLOAT;

					} else if ( array instanceof Float64Array ) {

						console.warn("Unsupported data buffer format: Float64Array");

					} else if ( array instanceof Uint16Array ) {

						type = _gl.UNSIGNED_SHORT;

					} else if ( array instanceof Int16Array ) {

						type = _gl.SHORT;

					} else if ( array instanceof Uint32Array ) {

						type = _gl.UNSIGNED_INT;

					} else if ( array instanceof Int32Array ) {

						type = _gl.INT;

					} else if ( array instanceof Int8Array ) {

						type = _gl.BYTE;

					} else if ( array instanceof Uint8Array ) {

						type = _gl.UNSIGNED_BYTE;

					}

					var size = geometryAttribute.itemSize;
					var buffer = objects.getAttributeBuffer( geometryAttribute );

					if ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data instanceof THREE.InstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );

					} else {

						if ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

	}

	function painterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable ( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var fog = scene.fog;

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		setupShadows( lights );

		shadowMap.render( scene, camera );

		setupLights( lights, camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		//

		var background = scene.background;

		if ( background === null ) {

			glClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

		} else if ( background instanceof THREE.Color ) {

			glClearColor( background.r, background.g, background.b, 1 );

		}

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		if ( background instanceof THREE.CubeTexture ) {

			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

		} else if ( background instanceof THREE.Texture ) {

			backgroundPlaneMesh.material.map = background;

			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, camera, fog, overrideMaterial );
			renderObjects( transparentObjects, camera, fog, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( THREE.NoBlending );
			renderObjects( opaqueObjects, camera, fog );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, camera, fog );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentViewport );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			textures.updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	// TODO Duplicated code (Frustum)

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).
			applyMatrix4( object.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSpriteViewable( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSphereViewable( sphere ) {

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

		var numPlanes = _clipping.numPlanes;

		if ( numPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== numPlanes );

		return true;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		if ( object.layers.test( camera.layers ) ) {

			if ( object instanceof THREE.Light ) {

				lights.push( object );

			} else if ( object instanceof THREE.Sprite ) {

				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

					sprites.push( object );

				}

			} else if ( object instanceof THREE.LensFlare ) {

				lensFlares.push( object );

			} else if ( object instanceof THREE.ImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {

				if ( object instanceof THREE.SkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material instanceof THREE.MultiMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, camera, fog, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object instanceof THREE.ImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, fog, geometry, material, object, group );

			}

		}

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters(
				material, _lights, fog, _clipping.numPlanes, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = THREE.ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: THREE.UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.__webglShader.uniforms;

		if ( ! ( material instanceof THREE.ShaderMaterial ) &&
				! ( material instanceof THREE.RawShaderMaterial ) ||
				material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		if ( material.lights ) {

			// store the light setup it was created for

			materialProperties.lightsHash = _lights.hash;

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = _lights.ambient;
			uniforms.directionalLights.value = _lights.directional;
			uniforms.spotLights.value = _lights.spot;
			uniforms.pointLights.value = _lights.point;
			uniforms.hemisphereLights.value = _lights.hemi;

			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
			uniforms.spotShadowMap.value = _lights.spotShadowMap;
			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
			uniforms.pointShadowMap.value = _lights.pointShadowMap;
			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
					THREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;
		materialProperties.dynamicUniforms =
				THREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );

	}

	function setMaterial( material ) {

		if ( material.side !== THREE.DoubleSide )
			state.enable( _gl.CULL_FACE );
		else
			state.disable( _gl.CULL_FACE );

		state.setFlipSided( material.side === THREE.BackSide );

		if ( material.transparent === true ) {

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		} else {

			state.setBlending( THREE.NoBlending );

		}

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
						material.clippingPlanes, material.clipShadows,
						camera, materialProperties, useCache );

			}

			if ( materialProperties.numClippingPlanes !== undefined &&
				materialProperties.numClippingPlanes !== _clipping.numPlanes ) {

				material.needsUpdate = true;

			}

		}

		if ( materialProperties.program === undefined ) {

			material.needsUpdate = true;

		}

		if ( materialProperties.lightsHash !== undefined &&
			materialProperties.lightsHash !== _lights.hash ) {

			material.needsUpdate = true;

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			p_uniforms.set( _gl, camera, 'projectionMatrix' );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshStandardMaterial ||
				 material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshStandardMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

					p_uniforms.set( _gl, skeleton, 'boneTexture' );
					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			if ( material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshStandardMaterial ||
				 material instanceof THREE.MeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.PointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material instanceof THREE.MeshStandardMaterial ) {

				refreshUniformsStandard( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				if ( material.displacementMap ) {

					m_uniforms.displacementMap.value = material.displacementMap;
					m_uniforms.displacementScale.value = material.displacementScale;
					m_uniforms.displacementBias.value = material.displacementBias;

				}

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			THREE.WebGLUniforms.upload(
					_gl, materialProperties.uniformsList, m_uniforms, _this );

		}


		// common matrices

		p_uniforms.set( _gl, object, 'modelViewMatrix' );
		p_uniforms.set( _gl, object, 'normalMatrix' );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );


		// dynamic uniforms

		var dynUniforms = materialProperties.dynamicUniforms;

		if ( dynUniforms !== null ) {

			THREE.WebGLUniforms.evalDynamic(
					dynUniforms, m_uniforms, object, camera );

			THREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );

		}

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;

		// don't flip CubeTexture envMaps, flip everything else:
		//  WebGLRenderTargetCube will be flipped for backwards compatibility
		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
		uniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _canvas.clientHeight * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert ( uniforms, material ) {

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard ( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical ( uniforms, material ) {

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		refreshUniformsStandard( uniforms, material );

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate ( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Lighting

	function setupShadows ( lights ) {

		var lightShadowsLength = 0;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			if ( light.castShadow ) {

				_lights.shadows[ lightShadowsLength ++ ] = light;

			}

		}

		_lights.shadows.length = lightShadowsLength;

	}

	function setupLights ( lights, camera ) {

		var l, ll, light,
		r = 0, g = 0, b = 0,
		color,
		intensity,
		distance,
		shadowMap,

		viewMatrix = camera.matrixWorldInverse,

		directionalLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light instanceof THREE.AmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light instanceof THREE.DirectionalLight ) {

				var uniforms = lightCache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				_lights.directional[ directionalLength ++ ] = uniforms;

			} else if ( light instanceof THREE.SpotLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.spotShadowMap[ spotLength ] = shadowMap;
				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				_lights.spot[ spotLength ++ ] = uniforms;

			} else if ( light instanceof THREE.PointLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.pointShadowMap[ pointLength ] = shadowMap;

				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

					_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();

				}

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position
				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

				_lights.point[ pointLength ++ ] = uniforms;

			} else if ( light instanceof THREE.HemisphereLight ) {

				var uniforms = lightCache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				_lights.hemi[ hemiLength ++ ] = uniforms;

			}

		}

		_lights.ambient[ 0 ] = r;
		_lights.ambient[ 1 ] = g;
		_lights.ambient[ 2 ] = b;

		_lights.directional.length = directionalLength;
		_lights.spot.length = spotLength;
		_lights.point.length = pointLength;
		_lights.hemi.length = hemiLength;

		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		state.setCullFace( cullFace );
		state.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );

	};

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	this.allocTextureUnit = allocTextureUnit;

	// this.setTexture2D = setTexture2D;
	this.setTexture2D = ( function() {

		var warned = false;

		// backwards compatibility: peel texture.texture
		return function setTexture2D( texture, slot ) {

			if ( texture instanceof THREE.WebGLRenderTarget ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTexture = ( function() {

		var warned = false;

		return function setTexture( texture, slot ) {

			if ( ! warned ) {

				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTextureCube = ( function() {

		var warned = false;

		return function setTextureCube( texture, slot ) {

			// backwards compatibility: peel texture.texture
			if ( texture instanceof THREE.WebGLRenderTargetCube ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( texture instanceof THREE.CubeTexture ||
				 ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				textures.setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube

				textures.setTextureCubeDynamic( texture, slot );

			}

		};

	}() );

	this.getCurrentRenderTarget = function() {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
		var framebuffer;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

			_currentViewport.copy( renderTarget.viewport );

		} else {

			framebuffer = null;

			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		state.viewport( _currentViewport );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;

				if ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( texture.type !== THREE.UnsignedByteType &&
				     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&
				     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&
				     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		var extension;

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		extension = extensions.get( 'OES_texture_half_float' );

		if ( extension !== null ) {

			if ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;

		}

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
		if ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
			if ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

		}

		extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

		if ( extension !== null ) {

			if ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

		}

		extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			if ( p === THREE.MinEquation ) return extension.MIN_EXT;
			if ( p === THREE.MaxEquation ) return extension.MAX_EXT;

		}

		return 0;

	}

};

// File:src/renderers/WebGLRenderTarget.js

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.uuid = THREE.Math.generateUUID();

	this.width = width;
	this.height = height;

	this.scissor = new THREE.Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new THREE.Vector4( 0, 0, width, height );

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;

	this.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = null;

};

Object.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

// File:src/renderers/WebGLRenderTargetCube.js

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	this.activeMipMapLevel = 0;

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;

// File:src/renderers/webgl/WebGLBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		_gl.drawArrays( mode, start, count );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		var count = 0;

		if ( position instanceof THREE.InterleavedBufferAttribute ) {

			count = position.data.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		} else {

			count = position.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		}

		_infoRender.calls ++;
		_infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLClipping.js

THREE.WebGLClipping = function() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new THREE.Plane(),
		viewNormalMatrix = new THREE.Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;

	this.init = function( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function() {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function() {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function( planes, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled ||
				planes === null || planes.length === 0 ||
				renderingShadows && ! clipShadows ) {
			// there's no local clipping

			if ( renderingShadows ) {
				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();
			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset;
									i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).
							applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		return dstArray;

	}

};


// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = _gl.UNSIGNED_INT;
			size = 4;

		} else {

			type = _gl.UNSIGNED_SHORT;
			size = 2;

		}

	}

	function render( start, count ) {

		_gl.drawElements( mode, count, type, start * size );

		_infoRender.calls ++;
		_infoRender.vertices += count;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

		_infoRender.calls ++;
		_infoRender.vertices += count * geometry.maxInstancedCount;
		if ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;
	}

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

};

// File:src/renderers/webgl/WebGLExtensions.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLExtensions = function ( gl ) {

	var extensions = {};

	this.get = function ( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		var extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			case 'WEBGL_compressed_texture_etc1':
				extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		if ( extension === null ) {

			console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

		}

		extensions[ name ] = extension;

		return extension;

	};

};

// File:src/renderers/webgl/WebGLCapabilities.js

THREE.WebGLCapabilities = function ( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	this.getMaxAnisotropy = getMaxAnisotropy;
	this.getMaxPrecision = getMaxPrecision;

	this.precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	this.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;

	this.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	this.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	this.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	this.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	this.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	this.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	this.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	this.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	this.vertexTextures = this.maxVertexTextures > 0;
	this.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;

	var _maxPrecision = getMaxPrecision( this.precision );

	if ( _maxPrecision !== this.precision ) {

		console.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );
		this.precision = _maxPrecision;

	}

	if ( this.logarithmicDepthBuffer ) {

		this.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );

	}

};

// File:src/renderers/webgl/WebGLGeometries.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLGeometries = function ( gl, properties, info ) {

	var geometries = {};

	function get( object ) {

		var geometry = object.geometry;

		if ( geometries[ geometry.id ] !== undefined ) {

			return geometries[ geometry.id ];

		}

		geometry.addEventListener( 'dispose', onGeometryDispose );

		var buffergeometry;

		if ( geometry instanceof THREE.BufferGeometry ) {

			buffergeometry = geometry;

		} else if ( geometry instanceof THREE.Geometry ) {

			if ( geometry._bufferGeometry === undefined ) {

				geometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );

			}

			buffergeometry = geometry._bufferGeometry;

		}

		geometries[ geometry.id ] = buffergeometry;

		info.memory.geometries ++;

		return buffergeometry;

	}

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			deleteAttribute( buffergeometry.index );

		}

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		// TODO

		var property = properties.get( geometry );

		if ( property.wireframe ) {

			deleteAttribute( property.wireframe );

		}

		properties.delete( geometry );

		var bufferproperty = properties.get( buffergeometry );

		if ( bufferproperty.wireframe ) {

			deleteAttribute( bufferproperty.wireframe );

		}

		properties.delete( buffergeometry );

		//

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	this.get = get;

};

// File:src/renderers/webgl/WebGLLights.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLLights = function () {

	var lights = {};

	this.get = function ( light ) {

		if ( lights[ light.id ] !== undefined ) {

			return lights[ light.id ];

		}

		var uniforms;

		switch ( light.type ) {

			case 'DirectionalLight':
				uniforms = {
					direction: new THREE.Vector3(),
					color: new THREE.Color(),

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2()
				};
				break;

			case 'SpotLight':
				uniforms = {
					position: new THREE.Vector3(),
					direction: new THREE.Vector3(),
					color: new THREE.Color(),
					distance: 0,
					coneCos: 0,
					penumbraCos: 0,
					decay: 0,

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2()
				};
				break;

			case 'PointLight':
				uniforms = {
					position: new THREE.Vector3(),
					color: new THREE.Color(),
					distance: 0,
					decay: 0,

					shadow: false,
					shadowBias: 0,
					shadowRadius: 1,
					shadowMapSize: new THREE.Vector2()
				};
				break;

			case 'HemisphereLight':
				uniforms = {
					direction: new THREE.Vector3(),
					skyColor: new THREE.Color(),
					groundColor: new THREE.Color()
				};
				break;

		}

		lights[ light.id ] = uniforms;

		return uniforms;

	};

};

// File:src/renderers/webgl/WebGLObjects.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLObjects = function ( gl, properties, info ) {

	var geometries = new THREE.WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry instanceof THREE.Geometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		attributeProperties.version = data.version;

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false || data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute instanceof THREE.InterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				if ( checkEdge( edges, a, b ) ) indices.push( a, b );
				if ( checkEdge( edges, b, c ) ) indices.push( b, c );
				if ( checkEdge( edges, c, a ) ) indices.push( c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	function checkEdge( edges, a, b ) {

		if ( a > b ) {

			var tmp = a;
			a = b;
			b = tmp;

		}

		var list = edges[ a ];

		if ( list === undefined ) {

			edges[ a ] = [ b ];
			return true;

		} else if ( list.indexOf( b ) === -1 ) {

			list.push( b );
			return true;

		}

		return false;

	}

	this.getAttributeBuffer = getAttributeBuffer;
	this.getWireframeAttribute = getWireframeAttribute;

	this.update = update;

};

// File:src/renderers/webgl/WebGLProgram.js

THREE.WebGLProgram = ( function () {

	var programIdCount = 0;

	function getEncodingComponents( encoding ) {

		switch ( encoding ) {

			case THREE.LinearEncoding:
				return [ 'Linear','( value )' ];
			case THREE.sRGBEncoding:
				return [ 'sRGB','( value )' ];
			case THREE.RGBEEncoding:
				return [ 'RGBE','( value )' ];
			case THREE.RGBM7Encoding:
				return [ 'RGBM','( value, 7.0 )' ];
			case THREE.RGBM16Encoding:
				return [ 'RGBM','( value, 16.0 )' ];
			case THREE.RGBDEncoding:
				return [ 'RGBD','( value, 256.0 )' ];
			case THREE.GammaEncoding:
				return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );

		}

	}

	function getTexelDecodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

	}

	function getTexelEncodingFunction( functionName, encoding ) {

		var components = getEncodingComponents( encoding );
		return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

	}

	function getToneMappingFunction( functionName, toneMapping ) {

		var toneMappingName;

		switch ( toneMapping ) {

			case THREE.LinearToneMapping:
				toneMappingName = "Linear";
				break;

			case THREE.ReinhardToneMapping:
				toneMappingName = "Reinhard";
				break;

			case THREE.Uncharted2ToneMapping:
				toneMappingName = "Uncharted2";
				break;

			case THREE.CineonToneMapping:
				toneMappingName = "OptimizedCineon";
				break;

			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );

		}

		return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

	}

	function generateExtensions( extensions, parameters, rendererExtensions ) {

		extensions = extensions || {};

		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

	}

	function parseIncludes( string ) {

		var pattern = /#include +<([\w\d.]+)>/g;

		function replace( match, include ) {

			var replace = THREE.ShaderChunk[ include ];

			if ( replace === undefined ) {

				throw new Error( 'Can not resolve #include <' + include + '>' );

			}

			return parseIncludes( replace );

		}

		return string.replace( pattern, replace );

	}

	function unrollLoops( string ) {

		var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

		function replace( match, start, end, snippet ) {

			var unroll = '';

			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

			}

			return unroll;

		}

		return string.replace( pattern, replace );

	}

	return function WebGLProgram( renderer, code, material, parameters ) {

		var gl = renderer.context;

		var extensions = material.extensions;
		var defines = material.defines;

		var vertexShader = material.__webglShader.vertexShader;
		var fragmentShader = material.__webglShader.fragmentShader;

		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

		}

		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

		if ( parameters.envMap ) {

			switch ( material.envMap.mapping ) {

				case THREE.CubeReflectionMapping:
				case THREE.CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;

				case THREE.CubeUVReflectionMapping:
				case THREE.CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;

				case THREE.EquirectangularReflectionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;

				case THREE.SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;

			}

			switch ( material.envMap.mapping ) {

				case THREE.CubeRefractionMapping:
				case THREE.EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;

			}

			switch ( material.combine ) {

				case THREE.MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;

				case THREE.MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;

				case THREE.AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;

			}

		}

		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		// console.log( 'building new program ' );

		//

		var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

		var customDefines = generateDefines( defines );

		//

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		if ( material instanceof THREE.RawShaderMaterial ) {

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

		} else {

			prefixVertex = [

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				'#define MAX_BONES ' + parameters.maxBones,

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',

				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',

				'#ifdef USE_COLOR',

				'	attribute vec3 color;',

				'#endif',

				'#ifdef USE_MORPHTARGETS',

				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',

				'	#ifdef USE_MORPHNORMALS',

				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',

				'	#else',

				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',

				'	#endif',

				'#endif',

				'#ifdef USE_SKINNING',

				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',

				'#endif',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

			prefixFragment = [

				customExtensions,

				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',

				'#define SHADER_NAME ' + material.__webglShader.name,

				customDefines,

				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

				'#define GAMMA_FACTOR ' + gammaFactorDefine,

				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',

				parameters.flatShading ? '#define FLAT_SHADED' : '',

				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',

				'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

				parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

				parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

				parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',

				( parameters.toneMapping !== THREE.NoToneMapping ) ? "#define TONE_MAPPING" : '',
				( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

				( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

				parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

				'\n'

			].filter( filterEmptyLine ).join( '\n' );

		}

		vertexShader = parseIncludes( vertexShader, parameters );
		vertexShader = replaceLightNums( vertexShader, parameters );

		fragmentShader = parseIncludes( fragmentShader, parameters );
		fragmentShader = replaceLightNums( fragmentShader, parameters );

		if ( material instanceof THREE.ShaderMaterial === false ) {

			vertexShader = unrollLoops( vertexShader );
			fragmentShader = unrollLoops( fragmentShader );

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
		var glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( material.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, material.index0AttributeName );

		} else if ( parameters.morphTargets === true ) {

			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );

		}

		gl.linkProgram( program );

		var programLog = gl.getProgramInfoLog( program );
		var vertexLog = gl.getShaderInfoLog( glVertexShader );
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

		var runnable = true;
		var haveDiagnostics = true;

		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

		if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

			runnable = false;

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,
				material: material,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

		// clean up

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function() {

			if ( cachedUniforms === undefined ) {

				cachedUniforms =
						new THREE.WebGLUniforms( gl, program, renderer );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function() {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function() {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		// DEPRECATED

		Object.defineProperties( this, {

			uniforms: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();

				}
			},

			attributes: {
				get: function() {

					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();

				}
			}

		} );


		//

		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	};

} )();

// File:src/renderers/webgl/WebGLPrograms.js

THREE.WebGLPrograms = function ( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "depthPacking"
	];


	function allocateBones ( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = THREE.LinearEncoding;

		} else if ( map instanceof THREE.Texture ) {

			encoding = map.encoding;

		} else if ( map instanceof THREE.WebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {

			encoding = THREE.GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, fog, nClipPlanes, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var currentRenderTarget = renderer.getCurrentRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			flatShading: material.shading === THREE.FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		return array.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new THREE.WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

};

// File:src/renderers/webgl/WebGLProperties.js

/**
* @author fordacious / fordacious.github.io
*/

THREE.WebGLProperties = function () {

	var properties = {};

	this.get = function ( object ) {

		var uuid = object.uuid;
		var map = properties[ uuid ];

		if ( map === undefined ) {

			map = {};
			properties[ uuid ] = map;

		}

		return map;

	};

	this.delete = function ( object ) {

		delete properties[ object.uuid ];

	};

	this.clear = function () {

		properties = {};

	};

};

// File:src/renderers/webgl/WebGLShader.js

THREE.WebGLShader = ( function () {

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	return function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

		}

		if ( gl.getShaderInfoLog( shader ) !== '' ) {

			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

		}

		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		return shader;

	};

} )();

// File:src/renderers/webgl/WebGLShadowMap.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_lightShadows = _lights.shadows,

	_shadowMapSize = new THREE.Vector2(),

	_lookTarget = new THREE.Vector3(),
	_lightPositionWorld = new THREE.Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

	_materialCache = {};

	var cubeDirections = [
		new THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),
		new THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),
		new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),	new THREE.Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),
		new THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()
	];

	// init

	var depthMaterialTemplate = new THREE.MeshDepthMaterial();
	depthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;
	depthMaterialTemplate.clipping = true;

	var distanceShader = THREE.ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = depthMaterialTemplate.clone();
		depthMaterial.morphTargets = useMorphing;
		depthMaterial.skinning = useSkinning;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new THREE.ShaderMaterial( {
			defines: {
				'USE_SHADOWMAP': ''
			},
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning,
			clipping: true
		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = THREE.PCFShadowMap;

	this.renderReverseSided = true;
	this.renderSingleSided = true;

	this.render = function ( scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( _lightShadows.length === 0 ) return;

		// Set GL state for depth map.
		_state.clearColor( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.setDepthTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount, isPointLight;

		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

			var light = _lightShadows[ i ];
			var shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );

			if ( light instanceof THREE.PointLight ) {

				faceCount = 6;
				isPointLight = true;

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			} else {

				faceCount = 1;
				isPointLight = false;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };

				shadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow instanceof THREE.SpotLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				} else {

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );

				}

				shadowCamera.updateMatrixWorld();
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, camera, shadowCamera );

				// render shadow map
				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material instanceof THREE.MultiMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

		}

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = geometry.morphTargets !== undefined &&
					geometry.morphTargets.length > 0 && material.morphTargets;

			var useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
			 material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		var side = material.side;

		if ( scope.renderSingleSided && side == THREE.DoubleSide ) {

			side = THREE.FrontSide;

		}

		if ( scope.renderReverseSided ) {

			if ( side === THREE.FrontSide ) side = THREE.BackSide;
			else if ( side === THREE.BackSide ) side = THREE.FrontSide;

		}

		result.side = side;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

			result.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return result;

	}

	function projectObject( object, camera, shadowCamera ) {

		if ( object.visible === false ) return;

		if ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, shadowCamera );

		}

	}

};

// File:src/renderers/webgl/WebGLState.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {

	var _this = this;

	this.buffers = {
		color: new THREE.WebGLColorBuffer( gl, this ),
		depth: new THREE.WebGLDepthBuffer( gl, this ),
		stencil: new THREE.WebGLStencilBuffer( gl, this )
	};

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var currentScissorTest = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new THREE.Vector4();
	var currentViewport = new THREE.Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	//

	this.init = function () {

		this.clearColor( 0, 0, 0, 1 );
		this.clearDepth( 1 );
		this.clearStencil( 0 );

		this.enable( gl.DEPTH_TEST );
		this.setDepthFunc( THREE.LessEqualDepth );

		this.setFlipSided( false );
		this.setCullFace( THREE.CullFaceBack );
		this.enable( gl.CULL_FACE );

		this.enable( gl.BLEND );
		this.setBlending( THREE.NormalBlending );

	};

	this.initAttributes = function () {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	};

	this.enableAttribute = function ( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	};

	this.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	};

	this.disableUnusedAttributes = function () {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	};

	this.enable = function ( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	};

	this.disable = function ( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	};

	this.getCompressedTextureFormats = function () {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending !== THREE.NoBlending ) {

			this.enable( gl.BLEND );

		} else {

			this.disable( gl.BLEND );
			currentBlending = blending; // no blending, that is
			return;

		}

		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

			if ( blending === THREE.AdditiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				}

			} else if ( blending === THREE.SubtractiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				}

			} else if ( blending === THREE.MultiplyBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				}

			} else {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		if ( blending === THREE.CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	};

	// TODO Deprecate

	this.setColorWrite = function ( colorWrite ) {

		this.buffers.color.setMask( colorWrite );

	};

	this.setDepthTest = function ( depthTest ) {

		this.buffers.depth.setTest( depthTest );

	};

	this.setDepthWrite = function ( depthWrite ) {

		this.buffers.depth.setMask( depthWrite );

	};

	this.setDepthFunc = function ( depthFunc ) {

		this.buffers.depth.setFunc( depthFunc );

	};

	this.setStencilTest = function ( stencilTest ) {

		this.buffers.stencil.setTest( stencilTest );

	};

	this.setStencilWrite = function ( stencilWrite ) {

		this.buffers.stencil.setMask( stencilWrite );

	};

	this.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {

		this.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );

	};

	this.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {

		this.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );

	};

	//

	this.setFlipSided = function ( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	};

	this.setCullFace = function ( cullFace ) {

		if ( cullFace !== THREE.CullFaceNone ) {

			this.enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === THREE.CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === THREE.CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			this.disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	};

	this.setLineWidth = function ( width ) {

		if ( width !== currentLineWidth ) {

			gl.lineWidth( width );

			currentLineWidth = width;

		}

	};

	this.setPolygonOffset = function ( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			this.enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			this.disable( gl.POLYGON_OFFSET_FILL );

		}

	};

	this.getScissorTest = function () {

		return currentScissorTest;

	};

	this.setScissorTest = function ( scissorTest ) {

		currentScissorTest = scissorTest;

		if ( scissorTest ) {

			this.enable( gl.SCISSOR_TEST );

		} else {

			this.disable( gl.SCISSOR_TEST );

		}

	};

	// texture

	this.activeTexture = function ( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	};

	this.bindTexture = function ( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			_this.activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	};

	this.compressedTexImage2D = function () {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	this.texImage2D = function () {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	};

	// TODO Deprecate

	this.clearColor = function ( r, g, b, a ) {

		this.buffers.color.setClear( r, g, b, a );

	};

	this.clearDepth = function ( depth ) {

		this.buffers.depth.setClear( depth );

	};

	this.clearStencil = function ( stencil ) {

		this.buffers.stencil.setClear( stencil );

	};

	//

	this.scissor = function ( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	};

	this.viewport = function ( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	};

	//

	this.reset = function () {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		this.buffers.color.reset();
		this.buffers.depth.reset();
		this.buffers.stencil.reset();

	};

};

THREE.WebGLColorBuffer = function ( gl, state ) {

	var locked = false;

	var color = new THREE.Vector4();
	var currentColorMask = null;
	var currentColorClear = new THREE.Vector4();

	this.setMask = function ( colorMask ) {

		if ( currentColorMask !== colorMask && ! locked ) {

			gl.colorMask( colorMask, colorMask, colorMask, colorMask );
			currentColorMask = colorMask;

		}

	};

	this.setLocked = function ( lock ) {

		locked = lock;

	};

	this.setClear = function ( r, g, b, a ) {

		color.set( r, g, b, a );

		if ( currentColorClear.equals( color ) === false ) {

			gl.clearColor( r, g, b, a );
			currentColorClear.copy( color );

		}

	};

	this.reset = function () {

		locked = false;

		currentColorMask = null;
		currentColorClear = new THREE.Vector4();

	};

};

THREE.WebGLDepthBuffer = function( gl, state ) {

	var locked = false;

	var currentDepthMask = null;
	var currentDepthFunc = null;
	var currentDepthClear = null;

	this.setTest = function ( depthTest ) {

		if ( depthTest ) {

			state.enable( gl.DEPTH_TEST );

		} else {

			state.disable( gl.DEPTH_TEST );

		}

	};

	this.setMask = function( depthMask ){

		if ( currentDepthMask !== depthMask && ! locked ) {

			gl.depthMask( depthMask );
			currentDepthMask = depthMask;

		}

	};

	this.setFunc = function ( depthFunc ) {

		if ( currentDepthFunc !== depthFunc ) {

			if ( depthFunc ) {

				switch ( depthFunc ) {

					case THREE.NeverDepth:

						gl.depthFunc( gl.NEVER );
						break;

					case THREE.AlwaysDepth:

						gl.depthFunc( gl.ALWAYS );
						break;

					case THREE.LessDepth:

						gl.depthFunc( gl.LESS );
						break;

					case THREE.LessEqualDepth:

						gl.depthFunc( gl.LEQUAL );
						break;

					case THREE.EqualDepth:

						gl.depthFunc( gl.EQUAL );
						break;

					case THREE.GreaterEqualDepth:

						gl.depthFunc( gl.GEQUAL );
						break;

					case THREE.GreaterDepth:

						gl.depthFunc( gl.GREATER );
						break;

					case THREE.NotEqualDepth:

						gl.depthFunc( gl.NOTEQUAL );
						break;

					default:

						gl.depthFunc( gl.LEQUAL );

				}

			} else {

				gl.depthFunc( gl.LEQUAL );

			}

			currentDepthFunc = depthFunc;

		}

	};

	this.setLocked = function ( lock ) {

		locked = lock;

	};

	this.setClear = function ( depth ) {

		if ( currentDepthClear !== depth ) {

			gl.clearDepth( depth );
			currentDepthClear = depth;

		}

	};

	this.reset = function () {

		locked = false;

		currentDepthMask = null;
		currentDepthFunc = null;
		currentDepthClear = null;

	};

};

THREE.WebGLStencilBuffer = function ( gl, state ) {

	var locked = false;

	var currentStencilMask = null;
	var currentStencilFunc = null;
	var currentStencilRef = null;
	var currentStencilFuncMask = null;
	var currentStencilFail  = null;
	var currentStencilZFail = null;
	var currentStencilZPass = null;
	var currentStencilClear = null;

	this.setTest = function ( stencilTest ) {

		if ( stencilTest ) {

			state.enable( gl.STENCIL_TEST );

		} else {

			state.disable( gl.STENCIL_TEST );

		}

	};

	this.setMask = function ( stencilMask ) {

		if ( currentStencilMask !== stencilMask && ! locked ) {

			gl.stencilMask( stencilMask );
			currentStencilMask = stencilMask;

		}

	};

	this.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {

		if ( currentStencilFunc !== stencilFunc ||
		     currentStencilRef 	!== stencilRef 	||
		     currentStencilFuncMask !== stencilMask ) {

			gl.stencilFunc( stencilFunc,  stencilRef, stencilMask );

			currentStencilFunc = stencilFunc;
			currentStencilRef  = stencilRef;
			currentStencilFuncMask = stencilMask;

		}

	};

	this.setOp	 = function ( stencilFail, stencilZFail, stencilZPass ) {

		if ( currentStencilFail	 !== stencilFail 	||
		     currentStencilZFail !== stencilZFail ||
		     currentStencilZPass !== stencilZPass ) {

			gl.stencilOp( stencilFail,  stencilZFail, stencilZPass );

			currentStencilFail  = stencilFail;
			currentStencilZFail = stencilZFail;
			currentStencilZPass = stencilZPass;

		}

	};

	this.setLocked = function ( lock ) {

		locked = lock;

	};

	this.setClear = function ( stencil ) {

		if ( currentStencilClear !== stencil ) {

			gl.clearStencil( stencil );
			currentStencilClear = stencil;

		}

	};

	this.reset = function () {

		locked = false;

		currentStencilMask = null;
		currentStencilFunc = null;
		currentStencilRef = null;
		currentStencilFuncMask = null;
		currentStencilFail = null;
		currentStencilZFail = null;
		currentStencilZPass = null;
		currentStencilClear = null;

	};

};

// File:src/renderers/webgl/WebGLTextures.js

/**
* @author mrdoob / http://mrdoob.com/
*/

THREE.WebGLTextures = function ( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

	var _infoMemory = info.memory;
	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

	//

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = THREE.Math.nearestPowerOfTwo( image.width );
			canvas.height = THREE.Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;
		if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;

		return false;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	//



	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTextureCube ( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;
				var isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setTextureCubeDynamic ( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	function setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {

		var extension;

		if ( isPowerOfTwoImage ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

			image = makePowerOfTwo( image );

		}

		var isPowerOfTwoImage = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture instanceof THREE.DepthTexture ) {

			// populate depth texture with dummy data

			var internalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === THREE.FloatType ) {

				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
				internalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( _isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				internalFormat = _gl.DEPTH_COMPONENT16;

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture instanceof THREE.DataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture instanceof THREE.CompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

			}

		}

		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = paramThreeToGL( renderTarget.texture.format );
		var glType = paramThreeToGL( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage ( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			// FIXME: We don't support !depth !stencil
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture ( framebuffer, renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {

			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

		}

		// upload an empty depth texture with framebuffer size
		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		_infoMemory.textures ++;

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;

		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
				texture.minFilter !== THREE.NearestFilter &&
				texture.minFilter !== THREE.LinearFilter ) {

			var target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );

		}

	}

	this.setTexture2D = setTexture2D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

};

// File:src/renderers/webgl/WebGLUniforms.js

/**
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 * .splitDynamic( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with dynamic entry and removes them from 'seq'
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 *
 * @author tschw
 *
 */

THREE.WebGLUniforms = ( function() { // scope

	var emptyTexture = new THREE.Texture();
	var emptyCubeTexture = new THREE.CubeTexture();

	// --- Base for inner nodes (including the root) ---

	var UniformContainer = function() {

			this.seq = [];
			this.map = {};

		},

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

		arrayCacheF32 = [],
		arrayCacheI32 = [],

		uncacheTemporaryArrays = function() {

			arrayCacheF32.length = 0;
			arrayCacheI32.length = 0;

		},

	// Flattening for arrays of vectors and matrices

		flatten = function( array, nBlocks, blockSize ) {

			var firstElem = array[ 0 ];

			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983

			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];

			if ( r === undefined ) {

				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;

			}

			if ( nBlocks !== 0 ) {

				firstElem.toArray( r, 0 );

				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

					offset += blockSize;
					array[ i ].toArray( r, offset );

				}

			}

			return r;

		},

	// Texture unit allocation

		allocTexUnits = function( renderer, n ) {

			var r = arrayCacheI32[ n ];

			if ( r === undefined ) {

				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;

			}

			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();

			return r;

		},

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

		// Single scalar

		setValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },
		setValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },

		// Single float vector (from flat array or THREE.VectorN)

		setValue2fv = function( gl, v ) {

			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );

		},

		setValue3fv = function( gl, v ) {

			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );

		},

		setValue4fv = function( gl, v ) {

			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

		},

		// Single matrix (from flat array or MatrixN)

		setValue2fm = function( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, v.elements || v );

		},

		setValue3fm = function( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, v.elements || v );

		},

		setValue4fm = function( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, v.elements || v );

		},

		// Single texture (2D / Cube)

		setValueT1 = function( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );

		},

		setValueT6 = function( gl, v, renderer ) {

			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );

		},

		// Integer / Boolean vectors or arrays thereof (always flat arrays)

		setValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },
		setValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },
		setValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },

		// Helper to pick the right setter for the singular case

		getSingularSetter = function( type ) {

			switch ( type ) {

				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4

				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4

				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		},

		// Array of scalars

		setValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },
		setValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },

		// Array of vectors (flat or from THREE classes)

		setValueV2a = function( gl, v ) {

			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

		},

		setValueV3a = function( gl, v ) {

			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

		},

		setValueV4a = function( gl, v ) {

			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

		},

		// Array of matrices (flat or from THREE clases)

		setValueM2a = function( gl, v ) {

			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

		},

		setValueM3a = function( gl, v ) {

			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

		},

		setValueM4a = function( gl, v ) {

			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

		},

		// Array of textures (2D / Cube)

		setValueT1a = function( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

			}

		},

		setValueT6a = function( gl, v, renderer ) {

			var n = v.length,
				units = allocTexUnits( renderer, n );

			gl.uniform1iv( this.addr, units );

			for ( var i = 0; i !== n; ++ i ) {

				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

			}

		},


		// Helper to pick the right setter for a pure (bottom-level) array

		getPureArraySetter = function( type ) {

			switch ( type ) {

				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4

				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4

				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE

				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

			}

		},

	// --- Uniform Classes ---

		SingleUniform = function SingleUniform( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		},

		PureArrayUniform = function( id, activeInfo, addr ) {

			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );

			// this.path = activeInfo.name; // DEBUG

		},

		StructuredUniform = function( id ) {

			this.id = id;

			UniformContainer.call( this ); // mix-in

		};

	StructuredUniform.prototype.setValue = function( gl, value ) {

		// Note: Don't need an extra 'renderer' parameter, since samplers
		// are not allowed in structured uniforms.

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ] );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g,
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.

		addUniform = function( container, uniformObject ) {

			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;

		},

		parseUniform = function( activeInfo, addr, container ) {

			var path = activeInfo.name,
				pathLength = path.length;

			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;

			for (; ;) {

				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,

					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];

				if ( idIsIndex ) id = id | 0; // convert to integer

				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix

					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );

					break;

				} else {
					// step into inner node / create it in case it doesn't exist

					var map = container.map,
						next = map[ id ];

					if ( next === undefined ) {

						next = new StructuredUniform( id );
						addUniform( container, next );

					}

					container = next;

				}

			}

		},

	// Root Container

		WebGLUniforms = function WebGLUniforms( gl, program, renderer ) {

			UniformContainer.call( this );

			this.renderer = renderer;

			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

			for ( var i = 0; i !== n; ++ i ) {

				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );

				parseUniform( info, addr, this );

			}

		};


	WebGLUniforms.prototype.setValue = function( gl, name, value ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, this.renderer );

	};

	WebGLUniforms.prototype.set = function( gl, object, name ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

	};

	WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function( gl, seq, values, renderer ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {
				// note: always updating when .needsUpdate is undefined

				u.setValue( gl, v.value, renderer );

			}

		}

	};

	WebGLUniforms.seqWithValue = function( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	WebGLUniforms.splitDynamic = function( seq, values ) {

		var r = null,
			n = seq.length,
			w = 0;

		for ( var i = 0; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v && v.dynamic === true ) {

				if ( r === null ) r = [];
				r.push( u );

			} else {

				// in-place compact 'seq', removing the matches
				if ( w < i ) seq[ w ] = u;
				++ w;

			}

		}

		if ( w < n ) seq.length = w;

		return r;

	};

	WebGLUniforms.evalDynamic = function( seq, values, object, camera ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var v = values[ seq[ i ].id ],
				f = v.onUpdateCallback;

			if ( f !== undefined ) f.call( v, object, camera );

		}

	};

	return WebGLUniforms;

} )();

// File:src/renderers/webgl/plugins/LensFlarePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function ( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		shader = {

			vertexShader: [

				"uniform lowp int renderType;",

				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",

				"uniform sampler2D occlusionMap;",

				"attribute vec2 position;",
				"attribute vec2 uv;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",

						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform lowp int renderType;",

				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

						"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",

					"}",

				"}"

			].join( "\n" )

		};

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewport ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;

		var size = 16 / viewport.w,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var validArea = new THREE.Box2();

		validArea.min.set( 0, 0 );
		validArea.max.set( viewport.z - 16, viewport.w - 16 );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		state.setDepthWrite( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewport.w;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

			// screen cull

			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewport.w;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture2D( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.setDepthWrite( true );

		renderer.resetGLState();

	};

	function createProgram ( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

};

// File:src/renderers/webgl/plugins/SpritePlugin.js

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function ( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new THREE.Vector3();
	var spriteRotation = new THREE.Quaternion();
	var spriteScale = new THREE.Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new THREE.Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map ) {

				renderer.setTexture2D( material.map, 0 );

			} else {

				renderer.setTexture2D( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram () {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable ( a, b ) {
		
		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

};

// File:src/Three.Legacy.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

Object.assign( THREE, {
	Face4: function ( a, b, c, d, normal, color, materialIndex ) {
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new THREE.Face3( a, b, c, normal, color, materialIndex );
	},
	LineStrip: 0,
	LinePieces: 1,
	MeshFaceMaterial: THREE.MultiMaterial,
	PointCloud: function ( geometry, material ) {
		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );
	},
	Particle: THREE.Sprite,
	ParticleSystem: function ( geometry, material ) {
		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new THREE.Points( geometry, material );
	},
	PointCloudMaterial: function ( parameters ) {
		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	},
	ParticleBasicMaterial: function ( parameters ) {
		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	},
	ParticleSystemMaterial: function ( parameters ) {
		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new THREE.PointsMaterial( parameters );
	},
	Vertex: function ( x, y, z ) {
		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new THREE.Vector3( x, y, z );
	}
} );

//

Object.assign( THREE.Box2.prototype, {
	empty: function () {
		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();
	},
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	}
} );

Object.assign( THREE.Box3.prototype, {
	empty: function () {
		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();
	},
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	},
	isIntersectionSphere: function ( sphere ) {
		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );
	}
} );

Object.assign( THREE.Matrix3.prototype, {
	multiplyVector3: function ( vector ) {
		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );
	},
	multiplyVector3Array: function ( a ) {
		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );
	}
} );

Object.assign( THREE.Matrix4.prototype, {
	extractPosition: function ( m ) {
		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );
	},
	setRotationFromQuaternion: function ( q ) {
		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );
	},
	multiplyVector3: function ( vector ) {
		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );
	},
	multiplyVector4: function ( vector ) {
		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );
	},
	multiplyVector3Array: function ( a ) {
		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );
	},
	rotateAxis: function ( v ) {
		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );
	},
	crossVector: function ( vector ) {
		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );
	},
	translate: function ( v ) {
		console.error( 'THREE.Matrix4: .translate() has been removed.' );
	},
	rotateX: function ( angle ) {
		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	},
	rotateY: function ( angle ) {
		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	},
	rotateZ: function ( angle ) {
		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	},
	rotateByAxis: function ( axis, angle ) {
		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	}
} );

Object.assign( THREE.Plane.prototype, {
	isIntersectionLine: function ( line ) {
		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );
	}
} );

Object.assign( THREE.Quaternion.prototype, {
	multiplyVector3: function ( vector ) {
		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );
	}
} );

Object.assign( THREE.Ray.prototype, {
	isIntersectionBox: function ( box ) {
		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );
	},
	isIntersectionPlane: function ( plane ) {
		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );
	},
	isIntersectionSphere: function ( sphere ) {
		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );
	}
} );

Object.assign( THREE.Vector3.prototype, {
	setEulerFromRotationMatrix: function () {
		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	},
	setEulerFromQuaternion: function () {
		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	},
	getPositionFromMatrix: function ( m ) {
		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );
	},
	getScaleFromMatrix: function ( m ) {
		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );
	},
	getColumnFromMatrix: function ( index, matrix ) {
		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );
	}
} );

//

Object.assign( THREE.Object3D.prototype, {
	getChildByName: function ( name ) {
		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );
	},
	renderDepth: function ( value ) {
		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	},
	translate: function ( distance, axis ) {
		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );
	}
} );

Object.defineProperties( THREE.Object3D.prototype, {
	eulerOrder: {
		get: function () {
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;
		},
		set: function ( value ) {
			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;
		}
	},
	useQuaternion: {
		get: function () {
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		},
		set: function ( value ) {
			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
		}
	}
} );

Object.defineProperties( THREE.LOD.prototype, {
	objects: {
		get: function () {
			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;
		}
	}
} );

//

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( THREE.Light.prototype, {
	onlyShadow: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .onlyShadow has been removed.' );
		}
	},
	shadowCameraFov: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;
		}
	},
	shadowCameraLeft: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;
		}
	},
	shadowCameraRight: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;
		}
	},
	shadowCameraTop: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;
		}
	},
	shadowCameraBottom: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;
		}
	},
	shadowCameraNear: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;
		}
	},
	shadowCameraFar: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;
		}
	},
	shadowCameraVisible: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
		}
	},
	shadowBias: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;
		}
	},
	shadowDarkness: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
		}
	},
	shadowMapWidth: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;
		}
	},
	shadowMapHeight: {
		set: function ( value ) {
			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;
		}
	}
} );

//

Object.defineProperties( THREE.BufferAttribute.prototype, {
	length: {
		get: function () {
			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );
			return this.array.length;
		}
	}
} );

Object.assign( THREE.BufferGeometry.prototype, {
	addIndex: function ( index ) {
		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );
	},
	addDrawCall: function ( start, count, indexOffset ) {
		if ( indexOffset !== undefined ) {
			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );
	},
	clearDrawCalls: function () {
		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();
	},
	computeTangents: function () {
		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	},
	computeOffsets: function () {
		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	}
} );

Object.defineProperties( THREE.BufferGeometry.prototype, {
	drawcalls: {
		get: function () {
			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;
		}
	},
	offsets: {
		get: function () {
			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;
		}
	}
} );

//

Object.defineProperties( THREE.Material.prototype, {
	wrapAround: {
		get: function () {
			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
		},
		set: function ( value ) {
			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
		}
	},
	wrapRGB: {
		get: function () {
			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new THREE.Color();
		}
	}
} );

Object.defineProperties( THREE.MeshPhongMaterial.prototype, {
	metal: {
		get: function () {
			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;
		},
		set: function ( value ) {
			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
		}
	}
} );

Object.defineProperties( THREE.ShaderMaterial.prototype, {
	derivatives: {
		get: function () {
			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;
		},
		set: function ( value ) {
			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;
		}
	}
} );

//

THREE.EventDispatcher.prototype = Object.assign( Object.create( {

	// Note: Extra base ensures these properties are not 'assign'ed.

	constructor: THREE.EventDispatcher,

	apply: function ( target ) {

		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
				"just inherit or Object.assign the prototype to mix-in." );

		Object.assign( target, this );

	}

} ), THREE.EventDispatcher.prototype );

//

Object.assign( THREE.WebGLRenderer.prototype, {
	supportsFloatTextures: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );
	},
	supportsHalfFloatTextures: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );
	},
	supportsStandardDerivatives: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );
	},
	supportsCompressedTextureS3TC: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	},
	supportsCompressedTexturePVRTC: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	},
	supportsBlendMinMax: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );
	},
	supportsVertexTextures: function () {
		return this.capabilities.vertexTextures;
	},
	supportsInstancedArrays: function () {
		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );
	},
	enableScissorTest: function ( boolean ) {
		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );
	},
	initMaterial: function () {
		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	},
	addPrePlugin: function () {
		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	},
	addPostPlugin: function () {
		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	},
	updateShadowMap: function () {
		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	}
} );

Object.defineProperties( THREE.WebGLRenderer.prototype, {
	shadowMapEnabled: {
		get: function () {
			return this.shadowMap.enabled;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;
		}
	},
	shadowMapType: {
		get: function () {
			return this.shadowMap.type;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;
		}
	},
	shadowMapCullFace: {
		get: function () {
			return this.shadowMap.cullFace;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;
		}
	}
} );

Object.defineProperties( THREE.WebGLShadowMap.prototype, {
	cullFace: {
		get: function () {
			return this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;
		},
		set: function ( cullFace ) {
			var value = ( cullFace !== THREE.CullFaceBack );
			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
			this.renderReverseSided = value;
		}
	}
} );

//

Object.defineProperties( THREE.WebGLRenderTarget.prototype, {
	wrapS: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;
		}
	},
	wrapT: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;
		}
	},
	magFilter: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;
		}
	},
	minFilter: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;
		}
	},
	anisotropy: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;
		}
	},
	offset: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;
		}
	},
	repeat: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;
		}
	},
	format: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;
		}
	},
	type: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;
		}
	},
	generateMipmaps: {
		get: function () {
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;
		},
		set: function ( value ) {
			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;
		}
	}
} );

//

Object.assign( THREE.Audio.prototype, {
	load: function ( file ) {
		console.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );
		var scope = this;
		var audioLoader = new THREE.AudioLoader();
		audioLoader.load( file, function ( buffer ) {
			scope.setBuffer( buffer );
		} );
		return this;
	}
} );

Object.assign( THREE.AudioAnalyser.prototype, {
	getData: function ( file ) {
		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();
	}
} );

//

THREE.GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );

		var matrix;

		if ( geometry2 instanceof THREE.Mesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new THREE.TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new THREE.CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	}

};

//

THREE.Projector = function () {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function ( vector, camera ) {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

};

//

THREE.CanvasRenderer = function () {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

};

// File:src/extras/CurveUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

// File:src/extras/SceneUtils.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

// File:src/extras/ShapeUtils.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function triangulate( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( THREE.ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.Shape: Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function b2( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function b3( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

// File:src/extras/core/Curve.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

THREE.Curve.prototype = {

	constructor: THREE.Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPoint( d / divisions ) );

		}

		return pts;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var d, pts = [];

		for ( d = 0; d <= divisions; d ++ ) {

			pts.push( this.getPointAt( d / divisions ) );

		}

		return pts;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	}

};

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

// File:src/extras/core/CurvePath.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

};

THREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {

	constructor: THREE.CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// TODO Test
		// and verify for vector3 (needs to implement equals)
		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new THREE.LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var u = 1 - diff / curve.getLength();

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	createPointsGeometry: function ( divisions ) {

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	// Generate geometry from equidistant sampling along the path

	createSpacedPointsGeometry: function ( divisions ) {

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		var geometry = new THREE.Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

// File:src/extras/core/Font.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Font = function ( data ) {

	this.data = data;

};

Object.assign( THREE.Font.prototype, {

	generateShapes: function ( text, size, divisions ) {

		function createPaths( text ) {

			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var offset = 0;

			var paths = [];

			for ( var i = 0; i < chars.length; i ++ ) {

				var ret = createPath( chars[ i ], scale, offset );
				offset += ret.offset;

				paths.push( ret.path );

			}

			return paths;

		}

		function createPath( c, scale, offset ) {

			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

			if ( ! glyph ) return;

			var path = new THREE.Path();

			var pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b2( t, cpx0, cpx1, cpx );
									b2( t, cpy0, cpy1, cpy );

								}

							}

							break;

						case 'b': // bezierCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;
							cpx2 = outline[ i ++ ] * scale + offset;
							cpy2 = outline[ i ++ ] * scale;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b3( t, cpx0, cpx1, cpx2, cpx );
									b3( t, cpy0, cpy1, cpy2, cpy );

								}

							}

							break;

					}

				}

			}

			return { offset: glyph.ha * scale, path: path };

		}

		//

		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;

		var data = this.data;

		var paths = createPaths( text );
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

// File:src/extras/core/Path.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call( this );

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {

	constructor: THREE.Path,

	// TODO Clean up PATH API

	// Create path using straight lines to connect all points
	// - vectors: array of Vector2

	fromPoints: function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

			this.lineTo( vectors[ i ].x, vectors[ i ].y );

		}

	},

	moveTo: function ( x, y ) {

		this.actions.push( { action: 'moveTo', args: [ x, y ] } );

	},

	lineTo: function ( x, y ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
		this.curves.push( curve );

		this.actions.push( { action: 'lineTo', args: [ x, y ] } );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.QuadraticBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCPx, aCPy ),
			new THREE.Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var curve = new THREE.CubicBezierCurve(
			new THREE.Vector2( x0, y0 ),
			new THREE.Vector2( aCP1x, aCP1y ),
			new THREE.Vector2( aCP2x, aCP2y ),
			new THREE.Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var args = Array.prototype.slice.call( arguments );

		var lastargs = this.actions[ this.actions.length - 1 ].args;

		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		var npts = [ new THREE.Vector2( x0, y0 ) ];
		Array.prototype.push.apply( npts, pts );

		var curve = new THREE.SplineCurve( npts );
		this.curves.push( curve );

		var lastPoint = pts[ pts.length - 1 ];
		args.push( lastPoint.x );
		args.push( lastPoint.y );

		this.actions.push( { action: 'splineThru', args: args } );

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var lastargs = this.actions[ this.actions.length - 1 ].args;
		var x0 = lastargs[ lastargs.length - 2 ];
		var y0 = lastargs[ lastargs.length - 1 ];

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var args = [
			aX, aY,
			xRadius, yRadius,
			aStartAngle, aEndAngle,
			aClockwise,
			aRotation || 0 // aRotation is optional.
		];

		var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		args.push( lastPoint.x );
		args.push( lastPoint.y );

		this.actions.push( { action: 'ellipse', args: args } );

	},

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i < divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

			//if ( !this.getPoint( i / divisions ) ) throw "DIE";

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var b2 = THREE.ShapeUtils.b2;
		var b3 = THREE.ShapeUtils.b3;

		var points = [];

		var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
			laste, tx, ty;

		for ( var i = 0, l = this.actions.length; i < l; i ++ ) {

			var item = this.actions[ i ];

			var action = item.action;
			var args = item.args;

			switch ( action ) {

			case 'moveTo':

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case 'lineTo':

				points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

				break;

			case 'quadraticCurveTo':

				cpx  = args[ 2 ];
				cpy  = args[ 3 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}

				for ( var j = 1; j <= divisions; j ++ ) {

					var t = j / divisions;

					tx = b2( t, cpx0, cpx1, cpx );
					ty = b2( t, cpy0, cpy1, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case 'bezierCurveTo':

				cpx  = args[ 4 ];
				cpy  = args[ 5 ];

				cpx1 = args[ 0 ];
				cpy1 = args[ 1 ];

				cpx2 = args[ 2 ];
				cpy2 = args[ 3 ];

				if ( points.length > 0 ) {

					laste = points[ points.length - 1 ];

					cpx0 = laste.x;
					cpy0 = laste.y;

				} else {

					laste = this.actions[ i - 1 ].args;

					cpx0 = laste[ laste.length - 2 ];
					cpy0 = laste[ laste.length - 1 ];

				}


				for ( var j = 1; j <= divisions; j ++ ) {

					var t = j / divisions;

					tx = b3( t, cpx0, cpx1, cpx2, cpx );
					ty = b3( t, cpy0, cpy1, cpy2, cpy );

					points.push( new THREE.Vector2( tx, ty ) );

				}

				break;

			case 'splineThru':

				laste = this.actions[ i - 1 ].args;

				var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
				var spts = [ last ];

				var n = divisions * args[ 0 ].length;

				spts = spts.concat( args[ 0 ] );

				var spline = new THREE.SplineCurve( spts );

				for ( var j = 1; j <= n; j ++ ) {

					points.push( spline.getPointAt( j / n ) );

				}

				break;

			case 'arc':

				var aX = args[ 0 ], aY = args[ 1 ],
					aRadius = args[ 2 ],
					aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
					aClockwise = !! args[ 5 ];

				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				for ( var j = 1; j <= tdivisions; j ++ ) {

					var t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + aRadius * Math.cos( angle );
					ty = aY + aRadius * Math.sin( angle );

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			case 'ellipse':

				var aX = args[ 0 ], aY = args[ 1 ],
					xRadius = args[ 2 ],
					yRadius = args[ 3 ],
					aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
					aClockwise = !! args[ 6 ],
					aRotation = args[ 7 ];


				var deltaAngle = aEndAngle - aStartAngle;
				var angle;
				var tdivisions = divisions * 2;

				var cos, sin;
				if ( aRotation !== 0 ) {

					cos = Math.cos( aRotation );
					sin = Math.sin( aRotation );

				}

				for ( var j = 1; j <= tdivisions; j ++ ) {

					var t = j / tdivisions;

					if ( ! aClockwise ) {

						t = 1 - t;

					}

					angle = aStartAngle + t * deltaAngle;

					tx = aX + xRadius * Math.cos( angle );
					ty = aY + yRadius * Math.sin( angle );

					if ( aRotation !== 0 ) {

						var x = tx, y = ty;

						// Rotate the point about the center of the ellipse.
						tx = ( x - aX ) * cos - ( y - aY ) * sin + aX;
						ty = ( x - aX ) * sin + ( y - aY ) * cos + aY;

					}

					//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

					points.push( new THREE.Vector2( tx, ty ) );

				}

				//console.log(points);

				break;

			} // end switch

		}



		// Normalize to remove the closing point by default.
		var lastPoint = points[ points.length - 1 ];
		if ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&
				 Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )
			points.splice( points.length - 1, 1 );

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	toShapes: function ( isCCW, noHoles ) {

		function extractSubpaths( inActions ) {

			var subPaths = [], lastPath = new THREE.Path();

			for ( var i = 0, l = inActions.length; i < l; i ++ ) {

				var item = inActions[ i ];

				var args = item.args;
				var action = item.action;

				if ( action === 'moveTo' ) {

					if ( lastPath.actions.length !== 0 ) {

						subPaths.push( lastPath );
						lastPath = new THREE.Path();

					}

				}

				lastPath[ action ].apply( lastPath, args );

			}

			if ( lastPath.actions.length !== 0 ) {

				subPaths.push( lastPath );

			}

			// console.log(subPaths);

			return	subPaths;

		}

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new THREE.Shape();
				tmpShape.actions = tmpPath.actions;
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			//console.log("shape", shapes);

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = THREE.ShapeUtils.isClockWise;

		var subPaths = extractSubpaths( this.actions );
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new THREE.Shape();
			tmpShape.actions = tmpPath.actions;
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.actions = tmpPath.actions;
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

} );

// File:src/extras/core/Shape.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );

	this.holes = [];

};

THREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {

	constructor: THREE.Shape,

	// Convenience method to return ExtrudeGeometry

	extrude: function ( options ) {

		return new THREE.ExtrudeGeometry( this, options );

	},

	// Convenience method to return ShapeGeometry

	makeGeometry: function ( options ) {

		return new THREE.ShapeGeometry( this, options );

	},

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// Get points of shape and holes (keypoints based on segments parameter)

	extractAllPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	extractPoints: function ( divisions ) {

		return this.extractAllPoints( divisions );

	}

} );

// File:src/extras/curves/LineCurve.js

/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.LineCurve.prototype.constructor = THREE.LineCurve;

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

// File:src/extras/curves/QuadraticBezierCurve.js

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = THREE.ShapeUtils.b2;

	return new THREE.Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;

	return new THREE.Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

// File:src/extras/curves/CubicBezierCurve.js

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = THREE.ShapeUtils.b3;

	return new THREE.Vector2( 
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;

	return new THREE.Vector2( 
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

// File:src/extras/curves/SplineCurve.js

/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = ( points == undefined ) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve;

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = THREE.CurveUtils.interpolate;

	return new THREE.Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

// File:src/extras/curves/EllipseCurve.js

/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;
	
	this.aRotation = aRotation || 0;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	var angle;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}
	
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x, ty = y;

		// Rotate the point about the center of the ellipse.
		x = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;
		y = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;

	}

	return new THREE.Vector2( x, y );

};

// File:src/extras/curves/ArcCurve.js

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve;

// File:src/extras/curves/LineCurve3.js

/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var vector = new THREE.Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

// File:src/extras/curves/QuadraticBezierCurve3.js

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = THREE.ShapeUtils.b2;		

		return new THREE.Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

// File:src/extras/curves/CubicBezierCurve3.js

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = THREE.ShapeUtils.b3;

		return new THREE.Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

// File:src/extras/curves/SplineCurve3.js

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
		this.points = ( points == undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = THREE.CurveUtils.interpolate;

		return new THREE.Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

// File:src/extras/curves/CatmullRomCurve3.js

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

THREE.CatmullRomCurve3 = ( function() {

	var
		tmp = new THREE.Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

	}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass Three.js curve
	return THREE.Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];
			this.closed = false;

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3; // 4 points

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new THREE.Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

// File:src/extras/curves/ClosedSplineCurve3.js

/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = function ( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );

	THREE.CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

};

THREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );

// File:src/extras/geometries/BoxGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;

THREE.CubeGeometry = THREE.BoxGeometry;

// File:src/extras/geometries/BoxBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	// segments
	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// these are used to calculate buffer length
	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;
	var numberOfVertices = 0;

	// group variables
	var groupStart = 0;

	// build each side of the box geometry
	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

	// build geometry
	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	// helper functions

	function calculateVertexCount ( w, h, d ) {

		var vertices = 0;

		// calculate the amount of vertices for each side (plane)
		vertices += (w + 1) * (h + 1) * 2; // xy
		vertices += (w + 1) * (d + 1) * 2; // xz
		vertices += (d + 1) * (h + 1) * 2; // zy

		return vertices;

	}

	function calculateIndexCount ( w, h, d ) {

		var index = 0;

		// calculate the amount of squares for each side
		index += w * h * 2; // xy
		index += w * d * 2; // xz
		index += d * h * 2; // zy

		return index * 6; // two triangles per square => six vertices per square

	}

	function buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth	= width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var vector = new THREE.Vector3();

		// generate vertices, normals and uvs

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component
				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer
				vertices[ vertexBufferOffset ] = vector.x;
				vertices[ vertexBufferOffset + 1 ] = vector.y;
				vertices[ vertexBufferOffset + 2 ] = vector.z;

				// set values to correct vector component
				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer
				normals[ vertexBufferOffset ] = vector.x;
				normals[ vertexBufferOffset + 1 ] = vector.y;
				normals[ vertexBufferOffset + 2 ] = vector.z;

				// uvs
				uvs[ uvBufferOffset ] = ix / gridX;
				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

				// update offsets and counters
				vertexBufferOffset += 3;
				uvBufferOffset += 2;
				vertexCounter += 1;

			}

		}

		// 1. you need three indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				// indices
				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// face one
				indices[ indexBufferOffset ] = a;
				indices[ indexBufferOffset + 1 ] = b;
				indices[ indexBufferOffset + 2 ] = d;

				// face two
				indices[ indexBufferOffset + 3 ] = b;
				indices[ indexBufferOffset + 4 ] = c;
				indices[ indexBufferOffset + 5 ] = d;

				// update offsets and counters
				indexBufferOffset += 6;
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups
		groupStart += groupCount;

		// update total number of vertices
		numberOfVertices += vertexCounter;

	}

};

THREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;

// File:src/extras/geometries/CircleGeometry.js

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;

// File:src/extras/geometries/CircleBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

THREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;

// File:src/extras/geometries/CylinderBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

	// used to calculate buffer length

	var nbCap = 0;

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) nbCap ++;
		if ( radiusBottom > 0 ) nbCap ++;

	}

	var vertexCount = calculateVertexCount();
	var indexCount = calculateIndexCount();

	// buffers

	var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
	var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables

	var index = 0,
	    indexOffset = 0,
	    indexArray = [],
	    halfHeight = height / 2;

	// group variables
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// helper functions

	function calculateVertexCount() {

		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

		if ( openEnded === false ) {

			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

		}

		return count;

	}

	function calculateIndexCount() {

		var count = radialSegments * heightSegments * 2 * 3;

		if ( openEnded === false ) {

			count += radialSegments * nbCap * 3;

		}

		return count;

	}

	function generateTorso() {

		var x, y;
		var normal = new THREE.Vector3();
		var vertex = new THREE.Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var tanTheta = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				// vertex
				vertex.x = radius * Math.sin( u * thetaLength + thetaStart );
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * Math.cos( u * thetaLength + thetaStart );
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

				// normal
				normal.copy( vertex );

				// handle special case if radiusTop/radiusBottom is zero

				if ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {

					normal.x = Math.sin( u * thetaLength + thetaStart );
					normal.z = Math.cos( u * thetaLength + thetaStart );

				}

				normal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();
				normals.setXYZ( index, normal.x, normal.y, normal.z );

				// uv
				uvs.setXY( index, u, 1 - v );

				// save index of vertex in respective row
				indexRow.push( index );

				// increase index
				index ++;

			}

			// now save vertices of the row in our index array
			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices
				var i1 = indexArray[ y ][ x ];
				var i2 = indexArray[ y + 1 ][ x ];
				var i3 = indexArray[ y + 1 ][ x + 1 ];
				var i4 = indexArray[ y ][ x + 1 ];

				// face one
				indices.setX( indexOffset, i1 ); indexOffset ++;
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// face two
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i3 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// update counters
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new THREE.Vector2();
		var vertex = new THREE.Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex
			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			uv.x = 0.5;
			uv.y = 0.5;

			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

		// save the index of the last center vertex
		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex
			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			} else {

				// face bottom
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			}

			// update counters
			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

};

THREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;

// File:src/extras/geometries/CylinderGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

};

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;

// File:src/extras/geometries/ConeBufferGeometry.js

/*
 * @author: abelnation / http://github.com/abelnation
 */

THREE.ConeBufferGeometry = function (
	radius, height,
	radialSegments, heightSegments,
	openEnded, thetaStart, thetaLength ) {

	THREE.CylinderBufferGeometry.call( this,
		0, radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

};

THREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;

// File:src/extras/geometries/ConeGeometry.js

/**
 * @author abelnation / http://github.com/abelnation
 */

THREE.ConeGeometry = function (
	radius, height,
	radialSegments, heightSegments,
	openEnded, thetaStart, thetaLength ) {

	THREE.CylinderGeometry.call( this,
		0, radius, height,
		radialSegments, heightSegments,
		openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

};

THREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );
THREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;

// File:src/extras/geometries/EdgesGeometry.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesGeometry = function ( geometry, thresholdAngle ) {

	THREE.BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry instanceof THREE.BufferGeometry ) {

		geometry2 = new THREE.Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );

};

THREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;

// File:src/extras/geometries/ExtrudeGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	THREE.Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new THREE.Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved
		//bs = bevelSize * t; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new THREE.Vector2( a.x, a.y ),
			new THREE.Vector2( b.x, b.y ),
			new THREE.Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new THREE.Vector2( a.x, 1 - a.z ),
				new THREE.Vector2( b.x, 1 - b.z ),
				new THREE.Vector2( c.x, 1 - c.z ),
				new THREE.Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new THREE.Vector2( a.y, 1 - a.z ),
				new THREE.Vector2( b.y, 1 - b.z ),
				new THREE.Vector2( c.y, 1 - c.z ),
				new THREE.Vector2( d.y, 1 - d.z )
			];

		}

	}
};

// File:src/extras/geometries/ShapeGeometry.js

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( Array.isArray( shapes ) === false ) shapes = [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i ++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	//

	var i, l, hole;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! THREE.ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i ++ ) {

			hole = holes[ i ];

			if ( THREE.ShapeUtils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.ShapeUtils.triangulateShape( vertices, holes );

	// Vertices

	for ( i = 0, l = holes.length; i < l; i ++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;

	for ( i = 0; i < vlen; i ++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i ++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );

	}

};

// File:src/extras/geometries/LatheBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

 // points - to create a closed torus, one must use a set of points
 //    like so: [ a, b, c, d, a ], see first is the same as last.
 // segments - the number of circumference segments to create
 // phiStart - the starting radian
 // phiLength - the radian (0 to 2PI) range of the lathed section
 //    2PI is a closed lathe, less than 2PI is a portion.

THREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]
	phiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );

	// these are used to calculate buffer length
	var vertexCount = ( segments + 1 ) * points.length;
	var indexCount = segments * points.length * 2 * 3;

	// buffers
	var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var index = 0, indexOffset = 0, base;
	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;
	var vertex = new THREE.Vector3();
	var uv = new THREE.Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex
			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// uv
			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			// indices
			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'uv', uvs );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new THREE.Vector3();
		var n2 = new THREE.Vector3();
		var n = new THREE.Vector3();

		// this is the buffer offset for the last line of vertices
		base = segments * points.length * 3;

		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line
			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line
			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals
			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals
			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		} // next row

	}

};

THREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;

// File:src/extras/geometries/LatheGeometry.js

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.

THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;

// File:src/extras/geometries/PlaneGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;

// File:src/extras/geometries/PlaneBufferGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;

// File:src/extras/geometries/RingBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 20;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// these are used to calculate buffer length
	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
	var indexCount = thetaSegments * phiSegments * 2 * 3;

	// buffers
	var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// some helper variables
	var index = 0, indexOffset = 0, segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new THREE.Vector3();
	var uv = new THREE.Vector2();
	var j, i;

	// generate vertices, normals and uvs

	// values are generate from the inside of the ring to the outside

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, 0, 1 );

			// uv
			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index++;

		}

		// increase the radius for next row of vertices
		radius += radiusStep;

	}

	// generate indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			// indices
			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;

			// face two
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

};

THREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;

// File:src/extras/geometries/RingGeometry.js

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry;

// File:src/extras/geometries/SphereGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;

// File:src/extras/geometries/SphereBufferGeometry.js

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

THREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new THREE.Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;

// File:src/extras/geometries/TextGeometry.js

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */

THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( font instanceof THREE.Font === false ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new THREE.Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, shapes, parameters );

	this.type = 'TextGeometry';

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry;

// File:src/extras/geometries/TorusBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

THREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;

	// helper variables
	var center = new THREE.Vector3();
	var vertex = new THREE.Vector3();
	var normal = new THREE.Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices[ vertexBufferOffset ] = vertex.x;
			vertices[ vertexBufferOffset + 1 ] = vertex.y;
			vertices[ vertexBufferOffset + 2 ] = vertex.z;

			// this vector is used to calculate the normal
			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			// normal
			normal.subVectors( vertex, center ).normalize();

			normals[ vertexBufferOffset ] = normal.x;
			normals[ vertexBufferOffset + 1 ] = normal.y;
			normals[ vertexBufferOffset + 2 ] = normal.z;

			// uv
			uvs[ uvBufferOffset ] = i / tubularSegments;
			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

			// update offsets
			vertexBufferOffset += 3;
			uvBufferOffset += 2;

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices
			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// face one
			indices[ indexBufferOffset ] = a;
			indices[ indexBufferOffset + 1 ] = b;
			indices[ indexBufferOffset + 2 ] = d;

			// face two
			indices[ indexBufferOffset + 3 ] = b;
			indices[ indexBufferOffset + 4 ] = c;
			indices[ indexBufferOffset + 5 ] = d;

			// update offset
			indexBufferOffset += 6;

		}

	}

	// build geometry
	this.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );

};

THREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;

// File:src/extras/geometries/TorusGeometry.js

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;

// File:src/extras/geometries/TorusKnotBufferGeometry.js

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * see: http://www.blackpawn.com/texts/pqtorus/
 */
THREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {

	THREE.BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 100;
	tube = tube || 40;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var i, j, index = 0, indexOffset = 0;

	var vertex = new THREE.Vector3();
	var normal = new THREE.Vector3();
	var uv = new THREE.Vector2();

	var P1 = new THREE.Vector3();
	var P2 = new THREE.Vector3();

	var B = new THREE.Vector3();
	var T = new THREE.Vector3();
	var N = new THREE.Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			// vertex
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
			normal.subVectors( vertex, P1 ).normalize();
			normals.setXYZ( index, normal.x, normal.y, normal.z );

			// uv
			uv.x = i / tubularSegments;
			uv.y = j / radialSegments;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices
			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

};

THREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;

// File:src/extras/geometries/TorusKnotGeometry.js

/**
 * @author oosmoxiecode
 */

THREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;

// File:src/extras/geometries/TubeGeometry.js

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {

	THREE.Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		segments: segments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed,
		taper: taper
	};

	segments = segments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;
	taper = taper || THREE.TubeGeometry.NoTaper;

	var grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = segments + 1,

		u, v, r,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}

	// construct the grid

	for ( i = 0; i < numpoints; i ++ ) {

		grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		r = radius * taper( u );

		for ( j = 0; j < radialSegments; j ++ ) {

			v = j / radialSegments * 2 * Math.PI;

			cx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = r * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}

	}


	// construct the mesh

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < radialSegments; j ++ ) {

			ip = ( closed ) ? ( i + 1 ) % segments : i + 1;
			jp = ( j + 1 ) % radialSegments;

			a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = grid[ ip ][ j ];
			c = grid[ ip ][ jp ];
			d = grid[ i ][ jp ];

			uva = new THREE.Vector2( i / segments, j / radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );
			uvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;

THREE.TubeGeometry.NoTaper = function ( u ) {

	return 1;

};

THREE.TubeGeometry.SinusoidalTaper = function ( u ) {

	return Math.sin( Math.PI * u );

};

// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {

	var	normal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		smallest,

		tx, ty, tz,
		i, u;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i ++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	/*
	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}
	*/

	function initialNormal3() {

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {

			smallest = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= smallest ) {

			smallest = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= smallest ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );

	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i ++ ) {

		normals[ i ] = normals[ i - 1 ].clone();

		binormals[ i ] = binormals[ i - 1 ].clone();

		vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

		if ( vec.length() > Number.EPSILON ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {

			theta = - theta;

		}

		for ( i = 1; i < numpoints; i ++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}

};

// File:src/extras/geometries/PolyhedronGeometry.js

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {

	THREE.Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i += 3 ) {

		prepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );

	}

	var p = this.vertices;

	var faces = [];

	for ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {

		var v1 = p[ indices[ i ] ];
		var v2 = p[ indices[ i + 1 ] ];
		var v3 = p[ indices[ i + 2 ] ];

		faces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	var centroid = new THREE.Vector3();

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		subdivide( faces[ i ], detail );

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, x1, x2 );
		var min = Math.min( x0, x1, x2 );

		if ( max > 0.9 && min < 0.1 ) {

			// 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		that.faces.push( face );

		centroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );

		var azi = azimuth( centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide( face, detail ) {

		var cols = Math.pow( 2, detail );
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1 ][ k + 1 ],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;

// File:src/extras/geometries/DodecahedronGeometry.js

/**
 * @author Abe Pazos / https://hamoid.com
 */

THREE.DodecahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;

// File:src/extras/geometries/IcosahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;

// File:src/extras/geometries/OctahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;

// File:src/extras/geometries/TetrahedronGeometry.js

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	THREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;

// File:src/extras/geometries/ParametricGeometry.js

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}

	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;

// File:src/extras/geometries/WireframeGeometry.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeGeometry = function ( geometry ) {

	THREE.BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry instanceof THREE.Geometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

	} else if ( geometry instanceof THREE.BufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var groups = geometry.groups;
			var numEdges = 0;

			if ( groups.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

				var group = groups[ o ];

				var start = group.start;
				var count = group.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );

		}

	}

};

THREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;

// File:src/extras/helpers/AxisHelper.js

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var vertices = new Float32Array( [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	] );

	var colors = new Float32Array( [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	] );

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.LineSegments.call( this, geometry, material );

};

THREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper;

// File:src/extras/helpers/ArrowHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = ( function () {

	var lineGeometry = new THREE.BufferGeometry();
	lineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

	var coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.translate( 0, - 0.5, 0 );

	return function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

		// dir is assumed to be normalized

		THREE.Object3D.call( this );

		if ( color === undefined ) color = 0xffff00;
		if ( length === undefined ) length = 1;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;

		this.position.copy( origin );

		this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	};

}() );

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;

THREE.ArrowHelper.prototype.setDirection = ( function () {

	var axis = new THREE.Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.copy( color );
	this.cone.material.color.copy( color );

};

// File:src/extras/helpers/BoxHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object, color ) {
	
	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new THREE.BufferGeometry();
	geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper;

THREE.BoxHelper.prototype.update = ( function () {

	var box = new THREE.Box3();

	return function update( object ) {

		if ( object instanceof THREE.Box3 ) {

			box.copy( object );

		} else {

			box.setFromObject( object );

		}

		if ( box.isEmpty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	};

} )();

// File:src/extras/helpers/BoundingBoxHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

// File:src/extras/helpers/CameraHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.LineSegments.call( this, geometry, material );

	this.camera = camera;
	if( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper;

THREE.CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				geometry.vertices[ points[ i ] ].copy( vector );

			}

		}

	}

	return function update() {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.verticesNeedUpdate = true;

	};

}();

// File:src/extras/helpers/DirectionalLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	if ( size === undefined ) size = 1;

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.Float32Attribute( [
		- size,   size, 0,
		  size,   size, 0,
		  size, - size, 0,
		- size, - size, 0,
		- size,   size, 0
	], 3 ) );

	var material = new THREE.LineBasicMaterial( { fog: false } );

	this.add( new THREE.Line( geometry, material ) );

	geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.add( new THREE.Line( geometry, material ));

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;

THREE.DirectionalLightHelper.prototype.dispose = function () {

	var lightPlane = this.children[ 0 ];
	var targetLine = this.children[ 1 ];

	lightPlane.geometry.dispose();
	lightPlane.material.dispose();
	targetLine.geometry.dispose();
	targetLine.material.dispose();

};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function update() {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		var lightPlane = this.children[ 0 ];
		var targetLine = this.children[ 1 ];

		lightPlane.lookAt( v3 );
		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		targetLine.lookAt( v3 );
		targetLine.scale.z = v3.length();

	};

}();

// File:src/extras/helpers/EdgesHelper.js

/**
 * @author WestLangley / http://github.com/WestLangley
 * @param object THREE.Mesh whose geometry will be used
 * @param hex line color
 * @param thresholdAngle the minimum angle (in degrees),
 * between the face normals of adjacent faces,
 * that is required to render an edge. A value of 10 means
 * an edge is only rendered if the angle is at least 10 degrees.
 */

THREE.EdgesHelper = function ( object, hex, thresholdAngle ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;

// File:src/extras/helpers/FaceNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;

THREE.FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	};

}() );

// File:src/extras/helpers/GridHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step, color1, color2 ) {

	color1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	for ( var i = - size, j = 0; i <= size; i += step ) {

		vertices.push( - size, 0, i, size, 0, i );
		vertices.push( i, 0, - size, i, 0, size );

		var color = i === 0 ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new THREE.BufferGeometry();
	geometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.LineSegments.call( this, geometry, material );

};

THREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.GridHelper.prototype.constructor = THREE.GridHelper;

THREE.GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

// File:src/extras/helpers/HemisphereLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.rotateX( - Math.PI / 2 );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;

THREE.HemisphereLightHelper.prototype.dispose = function () {

	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();

};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function update() {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	};

}();

// File:src/extras/helpers/PointLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;

THREE.PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

// File:src/extras/helpers/SkeletonHelper.js

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 */

THREE.SkeletonHelper = function ( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );
			geometry.colors.push( new THREE.Color( 0, 0, 1 ) );
			geometry.colors.push( new THREE.Color( 0, 1, 0 ) );

		}

	}

	geometry.dynamic = true;

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	THREE.LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

};


THREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;

THREE.SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object instanceof THREE.Bone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

THREE.SkeletonHelper.prototype.update = function () {

	var geometry = this.geometry;

	var matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );

	var boneMatrix = new THREE.Matrix4();

	var j = 0;

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent instanceof THREE.Bone ) {

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
			geometry.vertices[ j ].setFromMatrixPosition( boneMatrix );

			boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
			geometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );

			j += 2;

		}

	}

	geometry.verticesNeedUpdate = true;

	geometry.computeBoundingSphere();

};

// File:src/extras/helpers/SpotLightHelper.js

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.BufferGeometry();

	var positions = [
		0, 0, 0,   0,   0,   1,
		0, 0, 0,   1,   0,   1,
		0, 0, 0, - 1,   0,   1,
		0, 0, 0,   0,   1,   1,
		0, 0, 0,   0, - 1,   1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );

	var material = new THREE.LineBasicMaterial( { fog: false } );

	this.cone = new THREE.LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;

THREE.SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function update() {

		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

// File:src/extras/helpers/VertexNormalsHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry instanceof THREE.Geometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry instanceof THREE.BufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count;

	}

	//

	var geometry = new THREE.BufferGeometry();

	var positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	THREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;

THREE.VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var normalMatrix = new THREE.Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry instanceof THREE.Geometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry instanceof THREE.BufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	};

}() );

// File:src/extras/helpers/WireframeHelper.js

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	THREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

};

THREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;

// File:src/extras/objects/ImmediateRenderObject.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function ( material ) {

	THREE.Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;

// File:src/extras/objects/MorphBlendMesh.js

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/i;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};



/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property \'%s\' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.', propName) : _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s', propName) : _prodInvariant('50', propName) : void 0;

      if (process.env.NODE_ENV !== 'production') {
        DOMProperty.getPossibleStandardName[lowerCased] = propName;
      }

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
        if (process.env.NODE_ENV !== 'production') {
          DOMProperty.getPossibleStandardName[attributeName] = propName;
        }
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? { autofocus: 'autoFocus' } : null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(23);


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactCurrentOwner = __webpack_require__(12);

var warning = __webpack_require__(2);
var canDefineProperty = __webpack_require__(65);
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = __webpack_require__(104);

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'ref')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.ref !== undefined;
}

function hasValidKey(config) {
  if (process.env.NODE_ENV !== 'production') {
    if (hasOwnProperty.call(config, 'key')) {
      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
      if (getter && getter.isReactWarning) {
        return false;
      }
    }
  }
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      process.env.NODE_ENV !== 'production' ? warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName) : void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  if (process.env.NODE_ENV !== 'production') {
    // The validation flag is currently mutative. We put it on
    // an external backing store so that we can freeze the whole object.
    // This can be replaced with a WeakMap once they are implemented in
    // commonly used development environments.
    element._store = {};

    // To make comparing ReactElements easier for testing purposes, we make
    // the validation flag non-enumerable (where possible, which should
    // include every environment we run tests in), so the test framework
    // ignores it.
    if (canDefineProperty) {
      Object.defineProperty(element._store, 'validated', {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      });
      // self and source are DEV only properties.
      Object.defineProperty(element, '_self', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: self
      });
      // Two elements created in two different places should be considered
      // equal for testing purposes and therefore we hide it from enumeration.
      Object.defineProperty(element, '_source', {
        configurable: false,
        enumerable: false,
        writable: false,
        value: source
      });
    } else {
      element._store.validated = false;
      element._self = self;
      element._source = source;
    }
    if (Object.freeze) {
      Object.freeze(element.props);
      Object.freeze(element);
    }
  }

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    if (process.env.NODE_ENV !== 'production') {
      if (Object.freeze) {
        Object.freeze(childArray);
      }
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  if (process.env.NODE_ENV !== 'production') {
    if (key || ref) {
      if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
        var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
        if (key) {
          defineKeyPropWarningGetter(props, displayName);
        }
        if (ref) {
          defineRefPropWarningGetter(props, displayName);
        }
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */


/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var keys = __webpack_require__(144);
var hasBinary = __webpack_require__(78);
var sliceBuffer = __webpack_require__(119);
var after = __webpack_require__(118);
var utf8 = __webpack_require__(268);

var base64encoder;
if (global && global.ArrayBuffer) {
  base64encoder = __webpack_require__(132);
}

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);

/**
 * Check if we are running in PhantomJS.
 * Uploading a Blob with PhantomJS does not work correctly, as reported here:
 * https://github.com/ariya/phantomjs/issues/11395
 * @type boolean
 */
var isPhantomJS = typeof navigator !== 'undefined' && /PhantomJS/i.test(navigator.userAgent);

/**
 * When true, avoids using Blobs to encode payloads.
 * @type boolean
 */
var dontSendBlobs = isAndroid || isPhantomJS;

/**
 * Current protocol version.
 */

exports.protocol = 3;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = __webpack_require__(133);

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
  if ('function' == typeof supportsBinary) {
    callback = supportsBinary;
    supportsBinary = false;
  }

  if ('function' == typeof utf8encode) {
    callback = utf8encode;
    utf8encode = null;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // might be an object with { base64: true, data: dataAsBase64String }
  if (data && data.base64) {
    return encodeBase64Object(packet, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
  }

  return callback('' + encoded);

};

function encodeBase64Object(packet, callback) {
  // packet data is an object { base64: true, data: dataAsBase64String }
  var message = 'b' + exports.packets[packet.type] + packet.data.data;
  return callback(message);
}

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, true, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (dontSendBlobs) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof global.Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }
  // String data
  if (typeof data == 'string') {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);
      if (data === false) {
        return err;
      }
    }
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

function tryDecode(data) {
  try {
    data = utf8.decode(data);
  } catch (e) {
    return false;
  }
  return data;
}

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!base64encoder) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  var isBinary = hasBinary(packets);

  if (supportsBinary && isBinary) {
    if (Blob && !dontSendBlobs) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType, true);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  var numberTooLong = false;
  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';

    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;

      if (msgLength.length > 310) {
        numberTooLong = true;
        break;
      }

      msgLength += tailArray[i];
    }

    if(numberTooLong) return callback(err, 0, 1);

    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }

    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType, true), i, total);
  });
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = __webpack_require__(48);
var setInnerHTML = __webpack_require__(39);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(55);
var setTextContent = __webpack_require__(102);

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactRef = __webpack_require__(205);
var ReactInstrumentation = __webpack_require__(9);

var warning = __webpack_require__(2);

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeMountComponent(internalInstance._debugID, internalInstance._currentElement, parentDebugID);
      }
    }
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onMountComponent(internalInstance._debugID);
      }
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUnmountComponent(internalInstance._debugID);
      }
    }
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUnmountComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, nextElement);
      }
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }

    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      process.env.NODE_ENV !== 'production' ? warning(internalInstance._updateBatchNumber == null || internalInstance._updateBatchNumber === updateBatchNumber + 1, 'performUpdateIfNecessary: Unexpected batch number (current %s, ' + 'pending %s)', updateBatchNumber, internalInstance._updateBatchNumber) : void 0;
      return;
    }
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onBeforeUpdateComponent(internalInstance._debugID, internalInstance._currentElement);
      }
    }
    internalInstance.performUpdateIfNecessary(transaction);
    if (process.env.NODE_ENV !== 'production') {
      if (internalInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onUpdateComponent(internalInstance._debugID);
      }
    }
  }

};

module.exports = ReactReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactChildren = __webpack_require__(236);
var ReactComponent = __webpack_require__(62);
var ReactPureComponent = __webpack_require__(240);
var ReactClass = __webpack_require__(237);
var ReactDOMFactories = __webpack_require__(238);
var ReactElement = __webpack_require__(18);
var ReactPropTypes = __webpack_require__(239);
var ReactVersion = __webpack_require__(241);

var onlyChild = __webpack_require__(243);
var warning = __webpack_require__(2);

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(105);
  createElement = ReactElementValidator.createElement;
  createFactory = ReactElementValidator.createFactory;
  cloneElement = ReactElementValidator.cloneElement;
}

var __spread = _assign;

if (process.env.NODE_ENV !== 'production') {
  var warned = false;
  __spread = function () {
    process.env.NODE_ENV !== 'production' ? warning(warned, 'React.__spread is deprecated and should not be used. Use ' + 'Object.assign directly or another helper function with similar ' + 'semantics. You may be seeing this warning due to your compiler. ' + 'See https://fb.me/react-spread-deprecation for more details.') : void 0;
    warned = true;
    return _assign.apply(null, arguments);
  };
}

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var EventPluginRegistry = __webpack_require__(34);
var EventPluginUtils = __webpack_require__(49);
var ReactErrorUtils = __webpack_require__(53);

var accumulateInto = __webpack_require__(96);
var forEachAccumulated = __webpack_require__(97);
var invariant = __webpack_require__(1);

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener) : _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.') : _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);
var EventPluginUtils = __webpack_require__(49);

var accumulateInto = __webpack_require__(96);
var forEachAccumulated = __webpack_require__(97);
var warning = __webpack_require__(2);

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(inst, 'Dispatching inst must not be null') : void 0;
  }
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

var getEventTarget = __webpack_require__(58);

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pLight = exports.light2 = exports.spotLight = exports.light = exports.scene = exports.camera = exports.renderer = exports.canvas = undefined;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _d = __webpack_require__(32);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var canvas = exports.canvas = _d2.default.select("#three-container").append("canvas").attr("width", window.innerWidth).attr("height", window.innerHeight);

canvas.node().getContext("webgl");

var renderer = exports.renderer = new _THREE2.default.WebGLRenderer({
  alpha: true,
  antialias: true,
  canvas: canvas.node()
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x333333, 0);
document.getElementById("three-container").appendChild(renderer.domElement);

var camera = exports.camera = new _THREE2.default.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
camera.position.z = 1000;

var scene = exports.scene = new _THREE2.default.Scene();

var light = exports.light = new _THREE2.default.HemisphereLight('#ffffff', '#666666', 1);
light.position.set(0, 1000, 0);
scene.add(light);

var spotLight = exports.spotLight = new _THREE2.default.SpotLight('#ffffff', 5, 1500);
spotLight.position.set(600, 600, 200);
scene.add(spotLight);

var light2 = exports.light2 = new _THREE2.default.AmbientLight('#000000');
scene.add(light2);

var pLight = exports.pLight = new _THREE2.default.PointLight(0xffffff, 2, 1000);
pLight.position.set(0, 0, 0);
scene.add(pLight);

window.addEventListener('resize', onWindowResize, false);

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fadeObject = exports.growObject = undefined;

var _scene = __webpack_require__(29);

/**
 * Scales the supplied object up by tweening the scale property.
 *
 * @param  tween    : Object
 * @param  scalar   : Number
 * @param  obj      : THREE.Mesh
 * @param  tween    : Object
 * @param  callback : function
 * 
 */
var growObject = exports.growObject = function growObject(tween, obj, scalar, duration) {
  var delay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

  new tween.Tween(obj.scale).to({
    x: scalar,
    y: scalar,
    z: scalar
  }, duration).delay(delay).easing(tween.Easing.Quadratic.InOut).onUpdate(function () {
    _scene.renderer.render(_scene.scene, _scene.camera);
  }).onComplete(callback).start();
};

/**
 * fades the supplied object by tweening the opacity property.
 *
 * @param  tween    : Object
 * @param  scalar   : Number
 * @param  obj      : THREE.Mesh
 * @param  tween    : Object
 * @param  callback : function
 * 
 */
var fadeObject = exports.fadeObject = function fadeObject(tween, obj, scalar, duration) {
  var delay = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var callback = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;

  new tween.Tween(obj.material).to({
    opacity: scalar
  }, duration).delay(delay).easing(tween.Easing.Quadratic.InOut).onUpdate(function () {
    _scene.renderer.render(_scene.scene, _scene.camera);
  }).onComplete(callback).start();
};

/***/ }),
/* 31 */
/***/ (function(module, exports) {


module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {
  var d3 = {
    version: "3.5.17"
  };
  var d3_arraySlice = [].slice, d3_array = function(list) {
    return d3_arraySlice.call(list);
  };
  var d3_document = this.document;
  function d3_documentElement(node) {
    return node && (node.ownerDocument || node.document || node).documentElement;
  }
  function d3_window(node) {
    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);
  }
  if (d3_document) {
    try {
      d3_array(d3_document.documentElement.childNodes)[0].nodeType;
    } catch (e) {
      d3_array = function(list) {
        var i = list.length, array = new Array(i);
        while (i--) array[i] = list[i];
        return array;
      };
    }
  }
  if (!Date.now) Date.now = function() {
    return +new Date();
  };
  if (d3_document) {
    try {
      d3_document.createElement("DIV").style.setProperty("opacity", 0, "");
    } catch (error) {
      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;
      d3_element_prototype.setAttribute = function(name, value) {
        d3_element_setAttribute.call(this, name, value + "");
      };
      d3_element_prototype.setAttributeNS = function(space, local, value) {
        d3_element_setAttributeNS.call(this, space, local, value + "");
      };
      d3_style_prototype.setProperty = function(name, value, priority) {
        d3_style_setProperty.call(this, name, value + "", priority);
      };
    }
  }
  d3.ascending = d3_ascending;
  function d3_ascending(a, b) {
    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
  }
  d3.descending = function(a, b) {
    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
  };
  d3.min = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && a > b) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;
    }
    return a;
  };
  d3.max = function(array, f) {
    var i = -1, n = array.length, a, b;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null && b > a) a = b;
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;
    }
    return a;
  };
  d3.extent = function(array, f) {
    var i = -1, n = array.length, a, b, c;
    if (arguments.length === 1) {
      while (++i < n) if ((b = array[i]) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = array[i]) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    } else {
      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {
        a = c = b;
        break;
      }
      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {
        if (a > b) a = b;
        if (c < b) c = b;
      }
    }
    return [ a, c ];
  };
  function d3_number(x) {
    return x === null ? NaN : +x;
  }
  function d3_numeric(x) {
    return !isNaN(x);
  }
  d3.sum = function(array, f) {
    var s = 0, n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = +array[i])) s += a;
    } else {
      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;
    }
    return s;
  };
  d3.mean = function(array, f) {
    var s = 0, n = array.length, a, i = -1, j = n;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;
    }
    if (j) return s / j;
  };
  d3.quantile = function(values, p) {
    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;
    return e ? v + e * (values[h] - v) : v;
  };
  d3.median = function(array, f) {
    var numbers = [], n = array.length, a, i = -1;
    if (arguments.length === 1) {
      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);
    } else {
      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);
    }
    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);
  };
  d3.variance = function(array, f) {
    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;
    if (arguments.length === 1) {
      while (++i < n) {
        if (d3_numeric(a = d3_number(array[i]))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    } else {
      while (++i < n) {
        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {
          d = a - m;
          m += d / ++j;
          s += d * (a - m);
        }
      }
    }
    if (j > 1) return s / (j - 1);
  };
  d3.deviation = function() {
    var v = d3.variance.apply(this, arguments);
    return v ? Math.sqrt(v) : v;
  };
  function d3_bisector(compare) {
    return {
      left: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;
        }
        return lo;
      },
      right: function(a, x, lo, hi) {
        if (arguments.length < 3) lo = 0;
        if (arguments.length < 4) hi = a.length;
        while (lo < hi) {
          var mid = lo + hi >>> 1;
          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;
        }
        return lo;
      }
    };
  }
  var d3_bisect = d3_bisector(d3_ascending);
  d3.bisectLeft = d3_bisect.left;
  d3.bisect = d3.bisectRight = d3_bisect.right;
  d3.bisector = function(f) {
    return d3_bisector(f.length === 1 ? function(d, x) {
      return d3_ascending(f(d), x);
    } : f);
  };
  d3.shuffle = function(array, i0, i1) {
    if ((m = arguments.length) < 3) {
      i1 = array.length;
      if (m < 2) i0 = 0;
    }
    var m = i1 - i0, t, i;
    while (m) {
      i = Math.random() * m-- | 0;
      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;
    }
    return array;
  };
  d3.permute = function(array, indexes) {
    var i = indexes.length, permutes = new Array(i);
    while (i--) permutes[i] = array[indexes[i]];
    return permutes;
  };
  d3.pairs = function(array) {
    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);
    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];
    return pairs;
  };
  d3.transpose = function(matrix) {
    if (!(n = matrix.length)) return [];
    for (var i = -1, m = d3.min(matrix, d3_transposeLength), transpose = new Array(m); ++i < m; ) {
      for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n; ) {
        row[j] = matrix[j][i];
      }
    }
    return transpose;
  };
  function d3_transposeLength(d) {
    return d.length;
  }
  d3.zip = function() {
    return d3.transpose(arguments);
  };
  d3.keys = function(map) {
    var keys = [];
    for (var key in map) keys.push(key);
    return keys;
  };
  d3.values = function(map) {
    var values = [];
    for (var key in map) values.push(map[key]);
    return values;
  };
  d3.entries = function(map) {
    var entries = [];
    for (var key in map) entries.push({
      key: key,
      value: map[key]
    });
    return entries;
  };
  d3.merge = function(arrays) {
    var n = arrays.length, m, i = -1, j = 0, merged, array;
    while (++i < n) j += arrays[i].length;
    merged = new Array(j);
    while (--n >= 0) {
      array = arrays[n];
      m = array.length;
      while (--m >= 0) {
        merged[--j] = array[m];
      }
    }
    return merged;
  };
  var abs = Math.abs;
  d3.range = function(start, stop, step) {
    if (arguments.length < 3) {
      step = 1;
      if (arguments.length < 2) {
        stop = start;
        start = 0;
      }
    }
    if ((stop - start) / step === Infinity) throw new Error("infinite range");
    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;
    start *= k, stop *= k, step *= k;
    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);
    return range;
  };
  function d3_range_integerScale(x) {
    var k = 1;
    while (x * k % 1) k *= 10;
    return k;
  }
  function d3_class(ctor, properties) {
    for (var key in properties) {
      Object.defineProperty(ctor.prototype, key, {
        value: properties[key],
        enumerable: false
      });
    }
  }
  d3.map = function(object, f) {
    var map = new d3_Map();
    if (object instanceof d3_Map) {
      object.forEach(function(key, value) {
        map.set(key, value);
      });
    } else if (Array.isArray(object)) {
      var i = -1, n = object.length, o;
      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);
    } else {
      for (var key in object) map.set(key, object[key]);
    }
    return map;
  };
  function d3_Map() {
    this._ = Object.create(null);
  }
  var d3_map_proto = "__proto__", d3_map_zero = "\x00";
  d3_class(d3_Map, {
    has: d3_map_has,
    get: function(key) {
      return this._[d3_map_escape(key)];
    },
    set: function(key, value) {
      return this._[d3_map_escape(key)] = value;
    },
    remove: d3_map_remove,
    keys: d3_map_keys,
    values: function() {
      var values = [];
      for (var key in this._) values.push(this._[key]);
      return values;
    },
    entries: function() {
      var entries = [];
      for (var key in this._) entries.push({
        key: d3_map_unescape(key),
        value: this._[key]
      });
      return entries;
    },
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);
    }
  });
  function d3_map_escape(key) {
    return (key += "") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;
  }
  function d3_map_unescape(key) {
    return (key += "")[0] === d3_map_zero ? key.slice(1) : key;
  }
  function d3_map_has(key) {
    return d3_map_escape(key) in this._;
  }
  function d3_map_remove(key) {
    return (key = d3_map_escape(key)) in this._ && delete this._[key];
  }
  function d3_map_keys() {
    var keys = [];
    for (var key in this._) keys.push(d3_map_unescape(key));
    return keys;
  }
  function d3_map_size() {
    var size = 0;
    for (var key in this._) ++size;
    return size;
  }
  function d3_map_empty() {
    for (var key in this._) return false;
    return true;
  }
  d3.nest = function() {
    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;
    function map(mapType, array, depth) {
      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;
      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;
      while (++i < n) {
        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {
          values.push(object);
        } else {
          valuesByKey.set(keyValue, [ object ]);
        }
      }
      if (mapType) {
        object = mapType();
        setter = function(keyValue, values) {
          object.set(keyValue, map(mapType, values, depth));
        };
      } else {
        object = {};
        setter = function(keyValue, values) {
          object[keyValue] = map(mapType, values, depth);
        };
      }
      valuesByKey.forEach(setter);
      return object;
    }
    function entries(map, depth) {
      if (depth >= keys.length) return map;
      var array = [], sortKey = sortKeys[depth++];
      map.forEach(function(key, keyMap) {
        array.push({
          key: key,
          values: entries(keyMap, depth)
        });
      });
      return sortKey ? array.sort(function(a, b) {
        return sortKey(a.key, b.key);
      }) : array;
    }
    nest.map = function(array, mapType) {
      return map(mapType, array, 0);
    };
    nest.entries = function(array) {
      return entries(map(d3.map, array, 0), 0);
    };
    nest.key = function(d) {
      keys.push(d);
      return nest;
    };
    nest.sortKeys = function(order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    };
    nest.sortValues = function(order) {
      sortValues = order;
      return nest;
    };
    nest.rollup = function(f) {
      rollup = f;
      return nest;
    };
    return nest;
  };
  d3.set = function(array) {
    var set = new d3_Set();
    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);
    return set;
  };
  function d3_Set() {
    this._ = Object.create(null);
  }
  d3_class(d3_Set, {
    has: d3_map_has,
    add: function(key) {
      this._[d3_map_escape(key += "")] = true;
      return key;
    },
    remove: d3_map_remove,
    values: d3_map_keys,
    size: d3_map_size,
    empty: d3_map_empty,
    forEach: function(f) {
      for (var key in this._) f.call(this, d3_map_unescape(key));
    }
  });
  d3.behavior = {};
  function d3_identity(d) {
    return d;
  }
  d3.rebind = function(target, source) {
    var i = 1, n = arguments.length, method;
    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);
    return target;
  };
  function d3_rebind(target, source, method) {
    return function() {
      var value = method.apply(source, arguments);
      return value === source ? target : value;
    };
  }
  function d3_vendorSymbol(object, name) {
    if (name in object) return name;
    name = name.charAt(0).toUpperCase() + name.slice(1);
    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {
      var prefixName = d3_vendorPrefixes[i] + name;
      if (prefixName in object) return prefixName;
    }
  }
  var d3_vendorPrefixes = [ "webkit", "ms", "moz", "Moz", "o", "O" ];
  function d3_noop() {}
  d3.dispatch = function() {
    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    return dispatch;
  };
  function d3_dispatch() {}
  d3_dispatch.prototype.on = function(type, listener) {
    var i = type.indexOf("."), name = "";
    if (i >= 0) {
      name = type.slice(i + 1);
      type = type.slice(0, i);
    }
    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);
    if (arguments.length === 2) {
      if (listener == null) for (type in this) {
        if (this.hasOwnProperty(type)) this[type].on(name, null);
      }
      return this;
    }
  };
  function d3_dispatch_event(dispatch) {
    var listeners = [], listenerByName = new d3_Map();
    function event() {
      var z = listeners, i = -1, n = z.length, l;
      while (++i < n) if (l = z[i].on) l.apply(this, arguments);
      return dispatch;
    }
    event.on = function(name, listener) {
      var l = listenerByName.get(name), i;
      if (arguments.length < 2) return l && l.on;
      if (l) {
        l.on = null;
        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));
        listenerByName.remove(name);
      }
      if (listener) listeners.push(listenerByName.set(name, {
        on: listener
      }));
      return dispatch;
    };
    return event;
  }
  d3.event = null;
  function d3_eventPreventDefault() {
    d3.event.preventDefault();
  }
  function d3_eventSource() {
    var e = d3.event, s;
    while (s = e.sourceEvent) e = s;
    return e;
  }
  function d3_eventDispatch(target) {
    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;
    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);
    dispatch.of = function(thiz, argumentz) {
      return function(e1) {
        try {
          var e0 = e1.sourceEvent = d3.event;
          e1.target = target;
          d3.event = e1;
          dispatch[e1.type].apply(thiz, argumentz);
        } finally {
          d3.event = e0;
        }
      };
    };
    return dispatch;
  }
  d3.requote = function(s) {
    return s.replace(d3_requote_re, "\\$&");
  };
  var d3_requote_re = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
  var d3_subclass = {}.__proto__ ? function(object, prototype) {
    object.__proto__ = prototype;
  } : function(object, prototype) {
    for (var property in prototype) object[property] = prototype[property];
  };
  function d3_selection(groups) {
    d3_subclass(groups, d3_selectionPrototype);
    return groups;
  }
  var d3_select = function(s, n) {
    return n.querySelector(s);
  }, d3_selectAll = function(s, n) {
    return n.querySelectorAll(s);
  }, d3_selectMatches = function(n, s) {
    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, "matchesSelector")];
    d3_selectMatches = function(n, s) {
      return d3_selectMatcher.call(n, s);
    };
    return d3_selectMatches(n, s);
  };
  if (typeof Sizzle === "function") {
    d3_select = function(s, n) {
      return Sizzle(s, n)[0] || null;
    };
    d3_selectAll = Sizzle;
    d3_selectMatches = Sizzle.matchesSelector;
  }
  d3.selection = function() {
    return d3.select(d3_document.documentElement);
  };
  var d3_selectionPrototype = d3.selection.prototype = [];
  d3_selectionPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, group, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(subnode = selector.call(node, node.__data__, i, j));
          if (subnode && "__data__" in node) subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selector(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_select(selector, this);
    };
  }
  d3_selectionPrototype.selectAll = function(selector) {
    var subgroups = [], subgroup, node;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));
          subgroup.parentNode = node;
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_selectorAll(selector) {
    return typeof selector === "function" ? selector : function() {
      return d3_selectAll(selector, this);
    };
  }
  var d3_nsXhtml = "http://www.w3.org/1999/xhtml";
  var d3_nsPrefix = {
    svg: "http://www.w3.org/2000/svg",
    xhtml: d3_nsXhtml,
    xlink: "http://www.w3.org/1999/xlink",
    xml: "http://www.w3.org/XML/1998/namespace",
    xmlns: "http://www.w3.org/2000/xmlns/"
  };
  d3.ns = {
    prefix: d3_nsPrefix,
    qualify: function(name) {
      var i = name.indexOf(":"), prefix = name;
      if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
      return d3_nsPrefix.hasOwnProperty(prefix) ? {
        space: d3_nsPrefix[prefix],
        local: name
      } : name;
    }
  };
  d3_selectionPrototype.attr = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node();
        name = d3.ns.qualify(name);
        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);
      }
      for (value in name) this.each(d3_selection_attr(value, name[value]));
      return this;
    }
    return this.each(d3_selection_attr(name, value));
  };
  function d3_selection_attr(name, value) {
    name = d3.ns.qualify(name);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrConstant() {
      this.setAttribute(name, value);
    }
    function attrConstantNS() {
      this.setAttributeNS(name.space, name.local, value);
    }
    function attrFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);
    }
    function attrFunctionNS() {
      var x = value.apply(this, arguments);
      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);
    }
    return value == null ? name.local ? attrNullNS : attrNull : typeof value === "function" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;
  }
  function d3_collapse(s) {
    return s.trim().replace(/\s+/g, " ");
  }
  d3_selectionPrototype.classed = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") {
        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;
        if (value = node.classList) {
          while (++i < n) if (!value.contains(name[i])) return false;
        } else {
          value = node.getAttribute("class");
          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;
        }
        return true;
      }
      for (value in name) this.each(d3_selection_classed(value, name[value]));
      return this;
    }
    return this.each(d3_selection_classed(name, value));
  };
  function d3_selection_classedRe(name) {
    return new RegExp("(?:^|\\s+)" + d3.requote(name) + "(?:\\s+|$)", "g");
  }
  function d3_selection_classes(name) {
    return (name + "").trim().split(/^|\s+/);
  }
  function d3_selection_classed(name, value) {
    name = d3_selection_classes(name).map(d3_selection_classedName);
    var n = name.length;
    function classedConstant() {
      var i = -1;
      while (++i < n) name[i](this, value);
    }
    function classedFunction() {
      var i = -1, x = value.apply(this, arguments);
      while (++i < n) name[i](this, x);
    }
    return typeof value === "function" ? classedFunction : classedConstant;
  }
  function d3_selection_classedName(name) {
    var re = d3_selection_classedRe(name);
    return function(node, value) {
      if (c = node.classList) return value ? c.add(name) : c.remove(name);
      var c = node.getAttribute("class") || "";
      if (value) {
        re.lastIndex = 0;
        if (!re.test(c)) node.setAttribute("class", d3_collapse(c + " " + name));
      } else {
        node.setAttribute("class", d3_collapse(c.replace(re, " ")));
      }
    };
  }
  d3_selectionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));
        return this;
      }
      if (n < 2) {
        var node = this.node();
        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);
      }
      priority = "";
    }
    return this.each(d3_selection_style(name, value, priority));
  };
  function d3_selection_style(name, value, priority) {
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleConstant() {
      this.style.setProperty(name, value, priority);
    }
    function styleFunction() {
      var x = value.apply(this, arguments);
      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);
    }
    return value == null ? styleNull : typeof value === "function" ? styleFunction : styleConstant;
  }
  d3_selectionPrototype.property = function(name, value) {
    if (arguments.length < 2) {
      if (typeof name === "string") return this.node()[name];
      for (value in name) this.each(d3_selection_property(value, name[value]));
      return this;
    }
    return this.each(d3_selection_property(name, value));
  };
  function d3_selection_property(name, value) {
    function propertyNull() {
      delete this[name];
    }
    function propertyConstant() {
      this[name] = value;
    }
    function propertyFunction() {
      var x = value.apply(this, arguments);
      if (x == null) delete this[name]; else this[name] = x;
    }
    return value == null ? propertyNull : typeof value === "function" ? propertyFunction : propertyConstant;
  }
  d3_selectionPrototype.text = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.textContent = v == null ? "" : v;
    } : value == null ? function() {
      this.textContent = "";
    } : function() {
      this.textContent = value;
    }) : this.node().textContent;
  };
  d3_selectionPrototype.html = function(value) {
    return arguments.length ? this.each(typeof value === "function" ? function() {
      var v = value.apply(this, arguments);
      this.innerHTML = v == null ? "" : v;
    } : value == null ? function() {
      this.innerHTML = "";
    } : function() {
      this.innerHTML = value;
    }) : this.node().innerHTML;
  };
  d3_selectionPrototype.append = function(name) {
    name = d3_selection_creator(name);
    return this.select(function() {
      return this.appendChild(name.apply(this, arguments));
    });
  };
  function d3_selection_creator(name) {
    function create() {
      var document = this.ownerDocument, namespace = this.namespaceURI;
      return namespace === d3_nsXhtml && document.documentElement.namespaceURI === d3_nsXhtml ? document.createElement(name) : document.createElementNS(namespace, name);
    }
    function createNS() {
      return this.ownerDocument.createElementNS(name.space, name.local);
    }
    return typeof name === "function" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;
  }
  d3_selectionPrototype.insert = function(name, before) {
    name = d3_selection_creator(name);
    before = d3_selection_selector(before);
    return this.select(function() {
      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);
    });
  };
  d3_selectionPrototype.remove = function() {
    return this.each(d3_selectionRemove);
  };
  function d3_selectionRemove() {
    var parent = this.parentNode;
    if (parent) parent.removeChild(this);
  }
  d3_selectionPrototype.data = function(value, key) {
    var i = -1, n = this.length, group, node;
    if (!arguments.length) {
      value = new Array(n = (group = this[0]).length);
      while (++i < n) {
        if (node = group[i]) {
          value[i] = node.__data__;
        }
      }
      return value;
    }
    function bind(group, groupData) {
      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;
      if (key) {
        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;
        for (i = -1; ++i < n; ) {
          if (node = group[i]) {
            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {
              exitNodes[i] = node;
            } else {
              nodeByKeyValue.set(keyValue, node);
            }
            keyValues[i] = keyValue;
          }
        }
        for (i = -1; ++i < m; ) {
          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          } else if (node !== true) {
            updateNodes[i] = node;
            node.__data__ = nodeData;
          }
          nodeByKeyValue.set(keyValue, true);
        }
        for (i = -1; ++i < n; ) {
          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {
            exitNodes[i] = group[i];
          }
        }
      } else {
        for (i = -1; ++i < n0; ) {
          node = group[i];
          nodeData = groupData[i];
          if (node) {
            node.__data__ = nodeData;
            updateNodes[i] = node;
          } else {
            enterNodes[i] = d3_selection_dataNode(nodeData);
          }
        }
        for (;i < m; ++i) {
          enterNodes[i] = d3_selection_dataNode(groupData[i]);
        }
        for (;i < n; ++i) {
          exitNodes[i] = group[i];
        }
      }
      enterNodes.update = updateNodes;
      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;
      enter.push(enterNodes);
      update.push(updateNodes);
      exit.push(exitNodes);
    }
    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);
    if (typeof value === "function") {
      while (++i < n) {
        bind(group = this[i], value.call(group, group.parentNode.__data__, i));
      }
    } else {
      while (++i < n) {
        bind(group = this[i], value);
      }
    }
    update.enter = function() {
      return enter;
    };
    update.exit = function() {
      return exit;
    };
    return update;
  };
  function d3_selection_dataNode(data) {
    return {
      __data__: data
    };
  }
  d3_selectionPrototype.datum = function(value) {
    return arguments.length ? this.property("__data__", value) : this.property("__data__");
  };
  d3_selectionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      subgroup.parentNode = (group = this[j]).parentNode;
      for (var i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_selection(subgroups);
  };
  function d3_selection_filter(selector) {
    return function() {
      return d3_selectMatches(this, selector);
    };
  }
  d3_selectionPrototype.order = function() {
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {
        if (node = group[i]) {
          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
          next = node;
        }
      }
    }
    return this;
  };
  d3_selectionPrototype.sort = function(comparator) {
    comparator = d3_selection_sortComparator.apply(this, arguments);
    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);
    return this.order();
  };
  function d3_selection_sortComparator(comparator) {
    if (!arguments.length) comparator = d3_ascending;
    return function(a, b) {
      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;
    };
  }
  d3_selectionPrototype.each = function(callback) {
    return d3_selection_each(this, function(node, i, j) {
      callback.call(node, node.__data__, i, j);
    });
  };
  function d3_selection_each(groups, callback) {
    for (var j = 0, m = groups.length; j < m; j++) {
      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {
        if (node = group[i]) callback(node, i, j);
      }
    }
    return groups;
  }
  d3_selectionPrototype.call = function(callback) {
    var args = d3_array(arguments);
    callback.apply(args[0] = this, args);
    return this;
  };
  d3_selectionPrototype.empty = function() {
    return !this.node();
  };
  d3_selectionPrototype.node = function() {
    for (var j = 0, m = this.length; j < m; j++) {
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        var node = group[i];
        if (node) return node;
      }
    }
    return null;
  };
  d3_selectionPrototype.size = function() {
    var n = 0;
    d3_selection_each(this, function() {
      ++n;
    });
    return n;
  };
  function d3_selection_enter(selection) {
    d3_subclass(selection, d3_selection_enterPrototype);
    return selection;
  }
  var d3_selection_enterPrototype = [];
  d3.selection.enter = d3_selection_enter;
  d3.selection.enter.prototype = d3_selection_enterPrototype;
  d3_selection_enterPrototype.append = d3_selectionPrototype.append;
  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;
  d3_selection_enterPrototype.node = d3_selectionPrototype.node;
  d3_selection_enterPrototype.call = d3_selectionPrototype.call;
  d3_selection_enterPrototype.size = d3_selectionPrototype.size;
  d3_selection_enterPrototype.select = function(selector) {
    var subgroups = [], subgroup, subnode, upgroup, group, node;
    for (var j = -1, m = this.length; ++j < m; ) {
      upgroup = (group = this[j]).update;
      subgroups.push(subgroup = []);
      subgroup.parentNode = group.parentNode;
      for (var i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));
          subnode.__data__ = node.__data__;
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_selection(subgroups);
  };
  d3_selection_enterPrototype.insert = function(name, before) {
    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);
    return d3_selectionPrototype.insert.call(this, name, before);
  };
  function d3_selection_enterInsertBefore(enter) {
    var i0, j0;
    return function(d, i, j) {
      var group = enter[j].update, n = group.length, node;
      if (j != j0) j0 = j, i0 = 0;
      if (i >= i0) i0 = i + 1;
      while (!(node = group[i0]) && ++i0 < n) ;
      return node;
    };
  }
  d3.select = function(node) {
    var group;
    if (typeof node === "string") {
      group = [ d3_select(node, d3_document) ];
      group.parentNode = d3_document.documentElement;
    } else {
      group = [ node ];
      group.parentNode = d3_documentElement(node);
    }
    return d3_selection([ group ]);
  };
  d3.selectAll = function(nodes) {
    var group;
    if (typeof nodes === "string") {
      group = d3_array(d3_selectAll(nodes, d3_document));
      group.parentNode = d3_document.documentElement;
    } else {
      group = d3_array(nodes);
      group.parentNode = null;
    }
    return d3_selection([ group ]);
  };
  d3_selectionPrototype.on = function(type, listener, capture) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof type !== "string") {
        if (n < 2) listener = false;
        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));
        return this;
      }
      if (n < 2) return (n = this.node()["__on" + type]) && n._;
      capture = false;
    }
    return this.each(d3_selection_on(type, listener, capture));
  };
  function d3_selection_on(type, listener, capture) {
    var name = "__on" + type, i = type.indexOf("."), wrap = d3_selection_onListener;
    if (i > 0) type = type.slice(0, i);
    var filter = d3_selection_onFilters.get(type);
    if (filter) type = filter, wrap = d3_selection_onFilter;
    function onRemove() {
      var l = this[name];
      if (l) {
        this.removeEventListener(type, l, l.$);
        delete this[name];
      }
    }
    function onAdd() {
      var l = wrap(listener, d3_array(arguments));
      onRemove.call(this);
      this.addEventListener(type, this[name] = l, l.$ = capture);
      l._ = listener;
    }
    function removeAll() {
      var re = new RegExp("^__on([^.]+)" + d3.requote(type) + "$"), match;
      for (var name in this) {
        if (match = name.match(re)) {
          var l = this[name];
          this.removeEventListener(match[1], l, l.$);
          delete this[name];
        }
      }
    }
    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;
  }
  var d3_selection_onFilters = d3.map({
    mouseenter: "mouseover",
    mouseleave: "mouseout"
  });
  if (d3_document) {
    d3_selection_onFilters.forEach(function(k) {
      if ("on" + k in d3_document) d3_selection_onFilters.remove(k);
    });
  }
  function d3_selection_onListener(listener, argumentz) {
    return function(e) {
      var o = d3.event;
      d3.event = e;
      argumentz[0] = this.__data__;
      try {
        listener.apply(this, argumentz);
      } finally {
        d3.event = o;
      }
    };
  }
  function d3_selection_onFilter(listener, argumentz) {
    var l = d3_selection_onListener(listener, argumentz);
    return function(e) {
      var target = this, related = e.relatedTarget;
      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {
        l.call(target, e);
      }
    };
  }
  var d3_event_dragSelect, d3_event_dragId = 0;
  function d3_event_dragSuppress(node) {
    var name = ".dragsuppress-" + ++d3_event_dragId, click = "click" + name, w = d3.select(d3_window(node)).on("touchmove" + name, d3_eventPreventDefault).on("dragstart" + name, d3_eventPreventDefault).on("selectstart" + name, d3_eventPreventDefault);
    if (d3_event_dragSelect == null) {
      d3_event_dragSelect = "onselectstart" in node ? false : d3_vendorSymbol(node.style, "userSelect");
    }
    if (d3_event_dragSelect) {
      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];
      style[d3_event_dragSelect] = "none";
    }
    return function(suppressClick) {
      w.on(name, null);
      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;
      if (suppressClick) {
        var off = function() {
          w.on(click, null);
        };
        w.on(click, function() {
          d3_eventPreventDefault();
          off();
        }, true);
        setTimeout(off, 0);
      }
    };
  }
  d3.mouse = function(container) {
    return d3_mousePoint(container, d3_eventSource());
  };
  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;
  function d3_mousePoint(container, e) {
    if (e.changedTouches) e = e.changedTouches[0];
    var svg = container.ownerSVGElement || container;
    if (svg.createSVGPoint) {
      var point = svg.createSVGPoint();
      if (d3_mouse_bug44083 < 0) {
        var window = d3_window(container);
        if (window.scrollX || window.scrollY) {
          svg = d3.select("body").append("svg").style({
            position: "absolute",
            top: 0,
            left: 0,
            margin: 0,
            padding: 0,
            border: "none"
          }, "important");
          var ctm = svg[0][0].getScreenCTM();
          d3_mouse_bug44083 = !(ctm.f || ctm.e);
          svg.remove();
        }
      }
      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, 
      point.y = e.clientY;
      point = point.matrixTransform(container.getScreenCTM().inverse());
      return [ point.x, point.y ];
    }
    var rect = container.getBoundingClientRect();
    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];
  }
  d3.touch = function(container, touches, identifier) {
    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;
    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {
      if ((touch = touches[i]).identifier === identifier) {
        return d3_mousePoint(container, touch);
      }
    }
  };
  d3.behavior.drag = function() {
    var event = d3_eventDispatch(drag, "drag", "dragstart", "dragend"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, "mousemove", "mouseup"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, "touchmove", "touchend");
    function drag() {
      this.on("mousedown.drag", mousedown).on("touchstart.drag", touchstart);
    }
    function dragstart(id, position, subject, move, end) {
      return function() {
        var that = this, target = d3.event.target.correspondingElement || d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = ".drag" + (dragId == null ? "" : "-" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);
        if (origin) {
          dragOffset = origin.apply(that, arguments);
          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];
        } else {
          dragOffset = [ 0, 0 ];
        }
        dispatch({
          type: "dragstart"
        });
        function moved() {
          var position1 = position(parent, dragId), dx, dy;
          if (!position1) return;
          dx = position1[0] - position0[0];
          dy = position1[1] - position0[1];
          dragged |= dx | dy;
          position0 = position1;
          dispatch({
            type: "drag",
            x: position1[0] + dragOffset[0],
            y: position1[1] + dragOffset[1],
            dx: dx,
            dy: dy
          });
        }
        function ended() {
          if (!position(parent, dragId)) return;
          dragSubject.on(move + dragName, null).on(end + dragName, null);
          dragRestore(dragged);
          dispatch({
            type: "dragend"
          });
        }
      };
    }
    drag.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return drag;
    };
    return d3.rebind(drag, event, "on");
  };
  function d3_behavior_dragTouchId() {
    return d3.event.changedTouches[0].identifier;
  }
  d3.touches = function(container, touches) {
    if (arguments.length < 2) touches = d3_eventSource().touches;
    return touches ? d3_array(touches).map(function(touch) {
      var point = d3_mousePoint(container, touch);
      point.identifier = touch.identifier;
      return point;
    }) : [];
  };
  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;
  function d3_sgn(x) {
    return x > 0 ? 1 : x < 0 ? -1 : 0;
  }
  function d3_cross2d(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
  }
  function d3_acos(x) {
    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);
  }
  function d3_asin(x) {
    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);
  }
  function d3_sinh(x) {
    return ((x = Math.exp(x)) - 1 / x) / 2;
  }
  function d3_cosh(x) {
    return ((x = Math.exp(x)) + 1 / x) / 2;
  }
  function d3_tanh(x) {
    return ((x = Math.exp(2 * x)) - 1) / (x + 1);
  }
  function d3_haversin(x) {
    return (x = Math.sin(x / 2)) * x;
  }
  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;
  d3.interpolateZoom = function(p0, p1) {
    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
    if (d2 < ε2) {
      S = Math.log(w1 / w0) / ρ;
      i = function(t) {
        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];
      };
    } else {
      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / ρ;
      i = function(t) {
        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));
        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];
      };
    }
    i.duration = S * 1e3;
    return i;
  };
  d3.behavior.zoom = function() {
    var view = {
      x: 0,
      y: 0,
      k: 1
    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = "mousedown.zoom", mousemove = "mousemove.zoom", mouseup = "mouseup.zoom", mousewheelTimer, touchstart = "touchstart.zoom", touchtime, event = d3_eventDispatch(zoom, "zoomstart", "zoom", "zoomend"), x0, x1, y0, y1;
    if (!d3_behavior_zoomWheel) {
      d3_behavior_zoomWheel = "onwheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);
      }, "wheel") : "onmousewheel" in d3_document ? (d3_behavior_zoomDelta = function() {
        return d3.event.wheelDelta;
      }, "mousewheel") : (d3_behavior_zoomDelta = function() {
        return -d3.event.detail;
      }, "MozMousePixelScroll");
    }
    function zoom(g) {
      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + ".zoom", mousewheeled).on("dblclick.zoom", dblclicked).on(touchstart, touchstarted);
    }
    zoom.event = function(g) {
      g.each(function() {
        var dispatch = event.of(this, arguments), view1 = view;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.zoom", function() {
            view = this.__chart__ || {
              x: 0,
              y: 0,
              k: 1
            };
            zoomstarted(dispatch);
          }).tween("zoom:zoom", function() {
            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);
            return function(t) {
              var l = i(t), k = dx / l[2];
              this.__chart__ = view = {
                x: cx - l[0] * k,
                y: cy - l[1] * k,
                k: k
              };
              zoomed(dispatch);
            };
          }).each("interrupt.zoom", function() {
            zoomended(dispatch);
          }).each("end.zoom", function() {
            zoomended(dispatch);
          });
        } else {
          this.__chart__ = view;
          zoomstarted(dispatch);
          zoomed(dispatch);
          zoomended(dispatch);
        }
      });
    };
    zoom.translate = function(_) {
      if (!arguments.length) return [ view.x, view.y ];
      view = {
        x: +_[0],
        y: +_[1],
        k: view.k
      };
      rescale();
      return zoom;
    };
    zoom.scale = function(_) {
      if (!arguments.length) return view.k;
      view = {
        x: view.x,
        y: view.y,
        k: null
      };
      scaleTo(+_);
      rescale();
      return zoom;
    };
    zoom.scaleExtent = function(_) {
      if (!arguments.length) return scaleExtent;
      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.center = function(_) {
      if (!arguments.length) return center;
      center = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.size = function(_) {
      if (!arguments.length) return size;
      size = _ && [ +_[0], +_[1] ];
      return zoom;
    };
    zoom.duration = function(_) {
      if (!arguments.length) return duration;
      duration = +_;
      return zoom;
    };
    zoom.x = function(z) {
      if (!arguments.length) return x1;
      x1 = z;
      x0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    zoom.y = function(z) {
      if (!arguments.length) return y1;
      y1 = z;
      y0 = z.copy();
      view = {
        x: 0,
        y: 0,
        k: 1
      };
      return zoom;
    };
    function location(p) {
      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];
    }
    function point(l) {
      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];
    }
    function scaleTo(s) {
      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));
    }
    function translateTo(p, l) {
      l = point(l);
      view.x += p[0] - l[0];
      view.y += p[1] - l[1];
    }
    function zoomTo(that, p, l, k) {
      that.__chart__ = {
        x: view.x,
        y: view.y,
        k: view.k
      };
      scaleTo(Math.pow(2, k));
      translateTo(center0 = p, l);
      that = d3.select(that);
      if (duration > 0) that = that.transition().duration(duration);
      that.call(zoom.event);
    }
    function rescale() {
      if (x1) x1.domain(x0.range().map(function(x) {
        return (x - view.x) / view.k;
      }).map(x0.invert));
      if (y1) y1.domain(y0.range().map(function(y) {
        return (y - view.y) / view.k;
      }).map(y0.invert));
    }
    function zoomstarted(dispatch) {
      if (!zooming++) dispatch({
        type: "zoomstart"
      });
    }
    function zoomed(dispatch) {
      rescale();
      dispatch({
        type: "zoom",
        scale: view.k,
        translate: [ view.x, view.y ]
      });
    }
    function zoomended(dispatch) {
      if (!--zooming) dispatch({
        type: "zoomend"
      }), center0 = null;
    }
    function mousedowned() {
      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);
      d3_selection_interrupt.call(that);
      zoomstarted(dispatch);
      function moved() {
        dragged = 1;
        translateTo(d3.mouse(that), location0);
        zoomed(dispatch);
      }
      function ended() {
        subject.on(mousemove, null).on(mouseup, null);
        dragRestore(dragged);
        zoomended(dispatch);
      }
    }
    function touchstarted() {
      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = ".zoom-" + d3.event.changedTouches[0].identifier, touchmove = "touchmove" + zoomName, touchend = "touchend" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);
      started();
      zoomstarted(dispatch);
      subject.on(mousedown, null).on(touchstart, started);
      function relocate() {
        var touches = d3.touches(that);
        scale0 = view.k;
        touches.forEach(function(t) {
          if (t.identifier in locations0) locations0[t.identifier] = location(t);
        });
        return touches;
      }
      function started() {
        var target = d3.event.target;
        d3.select(target).on(touchmove, moved).on(touchend, ended);
        targets.push(target);
        var changed = d3.event.changedTouches;
        for (var i = 0, n = changed.length; i < n; ++i) {
          locations0[changed[i].identifier] = null;
        }
        var touches = relocate(), now = Date.now();
        if (touches.length === 1) {
          if (now - touchtime < 500) {
            var p = touches[0];
            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);
            d3_eventPreventDefault();
          }
          touchtime = now;
        } else if (touches.length > 1) {
          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];
          distance0 = dx * dx + dy * dy;
        }
      }
      function moved() {
        var touches = d3.touches(that), p0, l0, p1, l1;
        d3_selection_interrupt.call(that);
        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {
          p1 = touches[i];
          if (l1 = locations0[p1.identifier]) {
            if (l0) break;
            p0 = p1, l0 = l1;
          }
        }
        if (l1) {
          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);
          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];
          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];
          scaleTo(scale1 * scale0);
        }
        touchtime = null;
        translateTo(p0, l0);
        zoomed(dispatch);
      }
      function ended() {
        if (d3.event.touches.length) {
          var changed = d3.event.changedTouches;
          for (var i = 0, n = changed.length; i < n; ++i) {
            delete locations0[changed[i].identifier];
          }
          for (var identifier in locations0) {
            return void relocate();
          }
        }
        d3.selectAll(targets).on(zoomName, null);
        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);
        dragRestore();
        zoomended(dispatch);
      }
    }
    function mousewheeled() {
      var dispatch = event.of(this, arguments);
      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), 
      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);
      mousewheelTimer = setTimeout(function() {
        mousewheelTimer = null;
        zoomended(dispatch);
      }, 50);
      d3_eventPreventDefault();
      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);
      translateTo(center0, translate0);
      zoomed(dispatch);
    }
    function dblclicked() {
      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;
      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);
    }
    return d3.rebind(zoom, event, "on");
  };
  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;
  d3.color = d3_color;
  function d3_color() {}
  d3_color.prototype.toString = function() {
    return this.rgb() + "";
  };
  d3.hsl = d3_hsl;
  function d3_hsl(h, s, l) {
    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse("" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);
  }
  var d3_hslPrototype = d3_hsl.prototype = new d3_color();
  d3_hslPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, this.l / k);
  };
  d3_hslPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_hsl(this.h, this.s, k * this.l);
  };
  d3_hslPrototype.rgb = function() {
    return d3_hsl_rgb(this.h, this.s, this.l);
  };
  function d3_hsl_rgb(h, s, l) {
    var m1, m2;
    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;
    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;
    l = l < 0 ? 0 : l > 1 ? 1 : l;
    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;
    m1 = 2 * l - m2;
    function v(h) {
      if (h > 360) h -= 360; else if (h < 0) h += 360;
      if (h < 60) return m1 + (m2 - m1) * h / 60;
      if (h < 180) return m2;
      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;
      return m1;
    }
    function vv(h) {
      return Math.round(v(h) * 255);
    }
    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));
  }
  d3.hcl = d3_hcl;
  function d3_hcl(h, c, l) {
    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);
  }
  var d3_hclPrototype = d3_hcl.prototype = new d3_color();
  d3_hclPrototype.brighter = function(k) {
    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.darker = function(k) {
    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));
  };
  d3_hclPrototype.rgb = function() {
    return d3_hcl_lab(this.h, this.c, this.l).rgb();
  };
  function d3_hcl_lab(h, c, l) {
    if (isNaN(h)) h = 0;
    if (isNaN(c)) c = 0;
    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);
  }
  d3.lab = d3_lab;
  function d3_lab(l, a, b) {
    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);
  }
  var d3_lab_K = 18;
  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;
  var d3_labPrototype = d3_lab.prototype = new d3_color();
  d3_labPrototype.brighter = function(k) {
    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.darker = function(k) {
    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);
  };
  d3_labPrototype.rgb = function() {
    return d3_lab_rgb(this.l, this.a, this.b);
  };
  function d3_lab_rgb(l, a, b) {
    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;
    x = d3_lab_xyz(x) * d3_lab_X;
    y = d3_lab_xyz(y) * d3_lab_Y;
    z = d3_lab_xyz(z) * d3_lab_Z;
    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));
  }
  function d3_lab_hcl(l, a, b) {
    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);
  }
  function d3_lab_xyz(x) {
    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;
  }
  function d3_xyz_lab(x) {
    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;
  }
  function d3_xyz_rgb(r) {
    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));
  }
  d3.rgb = d3_rgb;
  function d3_rgb(r, g, b) {
    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse("" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);
  }
  function d3_rgbNumber(value) {
    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);
  }
  function d3_rgbString(value) {
    return d3_rgbNumber(value) + "";
  }
  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();
  d3_rgbPrototype.brighter = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    var r = this.r, g = this.g, b = this.b, i = 30;
    if (!r && !g && !b) return new d3_rgb(i, i, i);
    if (r && r < i) r = i;
    if (g && g < i) g = i;
    if (b && b < i) b = i;
    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));
  };
  d3_rgbPrototype.darker = function(k) {
    k = Math.pow(.7, arguments.length ? k : 1);
    return new d3_rgb(k * this.r, k * this.g, k * this.b);
  };
  d3_rgbPrototype.hsl = function() {
    return d3_rgb_hsl(this.r, this.g, this.b);
  };
  d3_rgbPrototype.toString = function() {
    return "#" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);
  };
  function d3_rgb_hex(v) {
    return v < 16 ? "0" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);
  }
  function d3_rgb_parse(format, rgb, hsl) {
    var r = 0, g = 0, b = 0, m1, m2, color;
    m1 = /([a-z]+)\((.*)\)/.exec(format = format.toLowerCase());
    if (m1) {
      m2 = m1[2].split(",");
      switch (m1[1]) {
       case "hsl":
        {
          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);
        }

       case "rgb":
        {
          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));
        }
      }
    }
    if (color = d3_rgb_names.get(format)) {
      return rgb(color.r, color.g, color.b);
    }
    if (format != null && format.charAt(0) === "#" && !isNaN(color = parseInt(format.slice(1), 16))) {
      if (format.length === 4) {
        r = (color & 3840) >> 4;
        r = r >> 4 | r;
        g = color & 240;
        g = g >> 4 | g;
        b = color & 15;
        b = b << 4 | b;
      } else if (format.length === 7) {
        r = (color & 16711680) >> 16;
        g = (color & 65280) >> 8;
        b = color & 255;
      }
    }
    return rgb(r, g, b);
  }
  function d3_rgb_hsl(r, g, b) {
    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;
    if (d) {
      s = l < .5 ? d / (max + min) : d / (2 - max - min);
      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;
      h *= 60;
    } else {
      h = NaN;
      s = l > 0 && l < 1 ? 0 : h;
    }
    return new d3_hsl(h, s, l);
  }
  function d3_rgb_lab(r, g, b) {
    r = d3_rgb_xyz(r);
    g = d3_rgb_xyz(g);
    b = d3_rgb_xyz(b);
    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);
    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));
  }
  function d3_rgb_xyz(r) {
    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);
  }
  function d3_rgb_parseNumber(c) {
    var f = parseFloat(c);
    return c.charAt(c.length - 1) === "%" ? Math.round(f * 2.55) : f;
  }
  var d3_rgb_names = d3.map({
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  });
  d3_rgb_names.forEach(function(key, value) {
    d3_rgb_names.set(key, d3_rgbNumber(value));
  });
  function d3_functor(v) {
    return typeof v === "function" ? v : function() {
      return v;
    };
  }
  d3.functor = d3_functor;
  d3.xhr = d3_xhrType(d3_identity);
  function d3_xhrType(response) {
    return function(url, mimeType, callback) {
      if (arguments.length === 2 && typeof mimeType === "function") callback = mimeType, 
      mimeType = null;
      return d3_xhr(url, mimeType, response, callback);
    };
  }
  function d3_xhr(url, mimeType, response, callback) {
    var xhr = {}, dispatch = d3.dispatch("beforesend", "progress", "load", "error"), headers = {}, request = new XMLHttpRequest(), responseType = null;
    if (this.XDomainRequest && !("withCredentials" in request) && /^(http(s)?:)?\/\//.test(url)) request = new XDomainRequest();
    "onload" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {
      request.readyState > 3 && respond();
    };
    function respond() {
      var status = request.status, result;
      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {
        try {
          result = response.call(xhr, request);
        } catch (e) {
          dispatch.error.call(xhr, e);
          return;
        }
        dispatch.load.call(xhr, result);
      } else {
        dispatch.error.call(xhr, request);
      }
    }
    request.onprogress = function(event) {
      var o = d3.event;
      d3.event = event;
      try {
        dispatch.progress.call(xhr, request);
      } finally {
        d3.event = o;
      }
    };
    xhr.header = function(name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers[name];
      if (value == null) delete headers[name]; else headers[name] = value + "";
      return xhr;
    };
    xhr.mimeType = function(value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return xhr;
    };
    xhr.responseType = function(value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return xhr;
    };
    xhr.response = function(value) {
      response = value;
      return xhr;
    };
    [ "get", "post" ].forEach(function(method) {
      xhr[method] = function() {
        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));
      };
    });
    xhr.send = function(method, data, callback) {
      if (arguments.length === 2 && typeof data === "function") callback = data, data = null;
      request.open(method, url, true);
      if (mimeType != null && !("accept" in headers)) headers["accept"] = mimeType + ",*/*";
      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);
      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);
      if (responseType != null) request.responseType = responseType;
      if (callback != null) xhr.on("error", callback).on("load", function(request) {
        callback(null, request);
      });
      dispatch.beforesend.call(xhr, request);
      request.send(data == null ? null : data);
      return xhr;
    };
    xhr.abort = function() {
      request.abort();
      return xhr;
    };
    d3.rebind(xhr, dispatch, "on");
    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));
  }
  function d3_xhr_fixCallback(callback) {
    return callback.length === 1 ? function(error, request) {
      callback(error == null ? request : null);
    } : callback;
  }
  function d3_xhrHasResponse(request) {
    var type = request.responseType;
    return type && type !== "text" ? request.response : request.responseText;
  }
  d3.dsv = function(delimiter, mimeType) {
    var reFormat = new RegExp('["' + delimiter + "\n]"), delimiterCode = delimiter.charCodeAt(0);
    function dsv(url, row, callback) {
      if (arguments.length < 3) callback = row, row = null;
      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);
      xhr.row = function(_) {
        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;
      };
      return xhr;
    }
    function response(request) {
      return dsv.parse(request.responseText);
    }
    function typedResponse(f) {
      return function(request) {
        return dsv.parse(request.responseText, f);
      };
    }
    dsv.parse = function(text, f) {
      var o;
      return dsv.parseRows(text, function(row, i) {
        if (o) return o(row, i - 1);
        var a = new Function("d", "return {" + row.map(function(name, i) {
          return JSON.stringify(name) + ": d[" + i + "]";
        }).join(",") + "}");
        o = f ? function(row, i) {
          return f(a(row), i);
        } : a;
      });
    };
    dsv.parseRows = function(text, f) {
      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;
      function token() {
        if (I >= N) return EOF;
        if (eol) return eol = false, EOL;
        var j = I;
        if (text.charCodeAt(j) === 34) {
          var i = j;
          while (i++ < N) {
            if (text.charCodeAt(i) === 34) {
              if (text.charCodeAt(i + 1) !== 34) break;
              ++i;
            }
          }
          I = i + 2;
          var c = text.charCodeAt(i + 1);
          if (c === 13) {
            eol = true;
            if (text.charCodeAt(i + 2) === 10) ++I;
          } else if (c === 10) {
            eol = true;
          }
          return text.slice(j + 1, i).replace(/""/g, '"');
        }
        while (I < N) {
          var c = text.charCodeAt(I++), k = 1;
          if (c === 10) eol = true; else if (c === 13) {
            eol = true;
            if (text.charCodeAt(I) === 10) ++I, ++k;
          } else if (c !== delimiterCode) continue;
          return text.slice(j, I - k);
        }
        return text.slice(j);
      }
      while ((t = token()) !== EOF) {
        var a = [];
        while (t !== EOL && t !== EOF) {
          a.push(t);
          t = token();
        }
        if (f && (a = f(a, n++)) == null) continue;
        rows.push(a);
      }
      return rows;
    };
    dsv.format = function(rows) {
      if (Array.isArray(rows[0])) return dsv.formatRows(rows);
      var fieldSet = new d3_Set(), fields = [];
      rows.forEach(function(row) {
        for (var field in row) {
          if (!fieldSet.has(field)) {
            fields.push(fieldSet.add(field));
          }
        }
      });
      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {
        return fields.map(function(field) {
          return formatValue(row[field]);
        }).join(delimiter);
      })).join("\n");
    };
    dsv.formatRows = function(rows) {
      return rows.map(formatRow).join("\n");
    };
    function formatRow(row) {
      return row.map(formatValue).join(delimiter);
    }
    function formatValue(text) {
      return reFormat.test(text) ? '"' + text.replace(/\"/g, '""') + '"' : text;
    }
    return dsv;
  };
  d3.csv = d3.dsv(",", "text/csv");
  d3.tsv = d3.dsv("	", "text/tab-separated-values");
  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, "requestAnimationFrame")] || function(callback) {
    setTimeout(callback, 17);
  };
  d3.timer = function() {
    d3_timer.apply(this, arguments);
  };
  function d3_timer(callback, delay, then) {
    var n = arguments.length;
    if (n < 2) delay = 0;
    if (n < 3) then = Date.now();
    var time = then + delay, timer = {
      c: callback,
      t: time,
      n: null
    };
    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;
    d3_timer_queueTail = timer;
    if (!d3_timer_interval) {
      d3_timer_timeout = clearTimeout(d3_timer_timeout);
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
    return timer;
  }
  function d3_timer_step() {
    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;
    if (delay > 24) {
      if (isFinite(delay)) {
        clearTimeout(d3_timer_timeout);
        d3_timer_timeout = setTimeout(d3_timer_step, delay);
      }
      d3_timer_interval = 0;
    } else {
      d3_timer_interval = 1;
      d3_timer_frame(d3_timer_step);
    }
  }
  d3.timer.flush = function() {
    d3_timer_mark();
    d3_timer_sweep();
  };
  function d3_timer_mark() {
    var now = Date.now(), timer = d3_timer_queueHead;
    while (timer) {
      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;
      timer = timer.n;
    }
    return now;
  }
  function d3_timer_sweep() {
    var t0, t1 = d3_timer_queueHead, time = Infinity;
    while (t1) {
      if (t1.c) {
        if (t1.t < time) time = t1.t;
        t1 = (t0 = t1).n;
      } else {
        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;
      }
    }
    d3_timer_queueTail = t0;
    return time;
  }
  function d3_format_precision(x, p) {
    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);
  }
  d3.round = function(x, n) {
    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);
  };
  var d3_formatPrefixes = [ "y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y" ].map(d3_formatPrefix);
  d3.formatPrefix = function(value, precision) {
    var i = 0;
    if (value = +value) {
      if (value < 0) value *= -1;
      if (precision) value = d3.round(value, d3_format_precision(value, precision));
      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);
      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));
    }
    return d3_formatPrefixes[8 + i / 3];
  };
  function d3_formatPrefix(d, i) {
    var k = Math.pow(10, abs(8 - i) * 3);
    return {
      scale: i > 8 ? function(d) {
        return d / k;
      } : function(d) {
        return d * k;
      },
      symbol: d
    };
  }
  function d3_locale_numberFormat(locale) {
    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {
      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;
      while (i > 0 && g > 0) {
        if (length + g + 1 > width) g = Math.max(1, width - length);
        t.push(value.substring(i -= g, i + g));
        if ((length += g + 1) > width) break;
        g = locale_grouping[j = (j + 1) % locale_grouping.length];
      }
      return t.reverse().join(locale_thousands);
    } : d3_identity;
    return function(specifier) {
      var match = d3_format_re.exec(specifier), fill = match[1] || " ", align = match[2] || ">", sign = match[3] || "-", symbol = match[4] || "", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = "", suffix = "", integer = false, exponent = true;
      if (precision) precision = +precision.substring(1);
      if (zfill || fill === "0" && align === "=") {
        zfill = fill = "0";
        align = "=";
      }
      switch (type) {
       case "n":
        comma = true;
        type = "g";
        break;

       case "%":
        scale = 100;
        suffix = "%";
        type = "f";
        break;

       case "p":
        scale = 100;
        suffix = "%";
        type = "r";
        break;

       case "b":
       case "o":
       case "x":
       case "X":
        if (symbol === "#") prefix = "0" + type.toLowerCase();

       case "c":
        exponent = false;

       case "d":
        integer = true;
        precision = 0;
        break;

       case "s":
        scale = -1;
        type = "r";
        break;
      }
      if (symbol === "$") prefix = locale_currency[0], suffix = locale_currency[1];
      if (type == "r" && !precision) type = "g";
      if (precision != null) {
        if (type == "g") precision = Math.max(1, Math.min(21, precision)); else if (type == "e" || type == "f") precision = Math.max(0, Math.min(20, precision));
      }
      type = d3_format_types.get(type) || d3_format_typeDefault;
      var zcomma = zfill && comma;
      return function(value) {
        var fullSuffix = suffix;
        if (integer && value % 1) return "";
        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, "-") : sign === "-" ? "" : sign;
        if (scale < 0) {
          var unit = d3.formatPrefix(value, precision);
          value = unit.scale(value);
          fullSuffix = unit.symbol + suffix;
        } else {
          value *= scale;
        }
        value = type(value, precision);
        var i = value.lastIndexOf("."), before, after;
        if (i < 0) {
          var j = exponent ? value.lastIndexOf("e") : -1;
          if (j < 0) before = value, after = ""; else before = value.substring(0, j), after = value.substring(j);
        } else {
          before = value.substring(0, i);
          after = locale_decimal + value.substring(i + 1);
        }
        if (!zfill && comma) before = formatGroup(before, Infinity);
        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : "";
        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);
        negative += prefix;
        value = before + after;
        return (align === "<" ? negative + value + padding : align === ">" ? padding + negative + value : align === "^" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;
      };
    };
  }
  var d3_format_re = /(?:([^{])?([<>=^]))?([+\- ])?([$#])?(0)?(\d+)?(,)?(\.-?\d+)?([a-z%])?/i;
  var d3_format_types = d3.map({
    b: function(x) {
      return x.toString(2);
    },
    c: function(x) {
      return String.fromCharCode(x);
    },
    o: function(x) {
      return x.toString(8);
    },
    x: function(x) {
      return x.toString(16);
    },
    X: function(x) {
      return x.toString(16).toUpperCase();
    },
    g: function(x, p) {
      return x.toPrecision(p);
    },
    e: function(x, p) {
      return x.toExponential(p);
    },
    f: function(x, p) {
      return x.toFixed(p);
    },
    r: function(x, p) {
      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));
    }
  });
  function d3_format_typeDefault(x) {
    return x + "";
  }
  var d3_time = d3.time = {}, d3_date = Date;
  function d3_date_utc() {
    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);
  }
  d3_date_utc.prototype = {
    getDate: function() {
      return this._.getUTCDate();
    },
    getDay: function() {
      return this._.getUTCDay();
    },
    getFullYear: function() {
      return this._.getUTCFullYear();
    },
    getHours: function() {
      return this._.getUTCHours();
    },
    getMilliseconds: function() {
      return this._.getUTCMilliseconds();
    },
    getMinutes: function() {
      return this._.getUTCMinutes();
    },
    getMonth: function() {
      return this._.getUTCMonth();
    },
    getSeconds: function() {
      return this._.getUTCSeconds();
    },
    getTime: function() {
      return this._.getTime();
    },
    getTimezoneOffset: function() {
      return 0;
    },
    valueOf: function() {
      return this._.valueOf();
    },
    setDate: function() {
      d3_time_prototype.setUTCDate.apply(this._, arguments);
    },
    setDay: function() {
      d3_time_prototype.setUTCDay.apply(this._, arguments);
    },
    setFullYear: function() {
      d3_time_prototype.setUTCFullYear.apply(this._, arguments);
    },
    setHours: function() {
      d3_time_prototype.setUTCHours.apply(this._, arguments);
    },
    setMilliseconds: function() {
      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);
    },
    setMinutes: function() {
      d3_time_prototype.setUTCMinutes.apply(this._, arguments);
    },
    setMonth: function() {
      d3_time_prototype.setUTCMonth.apply(this._, arguments);
    },
    setSeconds: function() {
      d3_time_prototype.setUTCSeconds.apply(this._, arguments);
    },
    setTime: function() {
      d3_time_prototype.setTime.apply(this._, arguments);
    }
  };
  var d3_time_prototype = Date.prototype;
  function d3_time_interval(local, step, number) {
    function round(date) {
      var d0 = local(date), d1 = offset(d0, 1);
      return date - d0 < d1 - date ? d0 : d1;
    }
    function ceil(date) {
      step(date = local(new d3_date(date - 1)), 1);
      return date;
    }
    function offset(date, k) {
      step(date = new d3_date(+date), k);
      return date;
    }
    function range(t0, t1, dt) {
      var time = ceil(t0), times = [];
      if (dt > 1) {
        while (time < t1) {
          if (!(number(time) % dt)) times.push(new Date(+time));
          step(time, 1);
        }
      } else {
        while (time < t1) times.push(new Date(+time)), step(time, 1);
      }
      return times;
    }
    function range_utc(t0, t1, dt) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = t0;
        return range(utc, t1, dt);
      } finally {
        d3_date = Date;
      }
    }
    local.floor = local;
    local.round = round;
    local.ceil = ceil;
    local.offset = offset;
    local.range = range;
    var utc = local.utc = d3_time_interval_utc(local);
    utc.floor = utc;
    utc.round = d3_time_interval_utc(round);
    utc.ceil = d3_time_interval_utc(ceil);
    utc.offset = d3_time_interval_utc(offset);
    utc.range = range_utc;
    return local;
  }
  function d3_time_interval_utc(method) {
    return function(date, k) {
      try {
        d3_date = d3_date_utc;
        var utc = new d3_date_utc();
        utc._ = date;
        return method(utc, k)._;
      } finally {
        d3_date = Date;
      }
    };
  }
  d3_time.year = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setMonth(0, 1);
    return date;
  }, function(date, offset) {
    date.setFullYear(date.getFullYear() + offset);
  }, function(date) {
    return date.getFullYear();
  });
  d3_time.years = d3_time.year.range;
  d3_time.years.utc = d3_time.year.utc.range;
  d3_time.day = d3_time_interval(function(date) {
    var day = new d3_date(2e3, 0);
    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
    return day;
  }, function(date, offset) {
    date.setDate(date.getDate() + offset);
  }, function(date) {
    return date.getDate() - 1;
  });
  d3_time.days = d3_time.day.range;
  d3_time.days.utc = d3_time.day.utc.range;
  d3_time.dayOfYear = function(date) {
    var year = d3_time.year(date);
    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);
  };
  [ "sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday" ].forEach(function(day, i) {
    i = 7 - i;
    var interval = d3_time[day] = d3_time_interval(function(date) {
      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);
      return date;
    }, function(date, offset) {
      date.setDate(date.getDate() + Math.floor(offset) * 7);
    }, function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);
    });
    d3_time[day + "s"] = interval.range;
    d3_time[day + "s"].utc = interval.utc.range;
    d3_time[day + "OfYear"] = function(date) {
      var day = d3_time.year(date).getDay();
      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);
    };
  });
  d3_time.week = d3_time.sunday;
  d3_time.weeks = d3_time.sunday.range;
  d3_time.weeks.utc = d3_time.sunday.utc.range;
  d3_time.weekOfYear = d3_time.sundayOfYear;
  function d3_locale_timeFormat(locale) {
    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;
    function d3_time_format(template) {
      var n = template.length;
      function format(date) {
        var string = [], i = -1, j = 0, c, p, f;
        while (++i < n) {
          if (template.charCodeAt(i) === 37) {
            string.push(template.slice(j, i));
            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);
            if (f = d3_time_formats[c]) c = f(date, p == null ? c === "e" ? " " : "0" : p);
            string.push(c);
            j = i + 1;
          }
        }
        string.push(template.slice(j, i));
        return string.join("");
      }
      format.parse = function(string) {
        var d = {
          y: 1900,
          m: 0,
          d: 1,
          H: 0,
          M: 0,
          S: 0,
          L: 0,
          Z: null
        }, i = d3_time_parse(d, template, string, 0);
        if (i != string.length) return null;
        if ("p" in d) d.H = d.H % 12 + d.p * 12;
        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();
        if ("j" in d) date.setFullYear(d.y, 0, d.j); else if ("W" in d || "U" in d) {
          if (!("w" in d)) d.w = "W" in d ? 1 : 0;
          date.setFullYear(d.y, 0, 1);
          date.setFullYear(d.y, 0, "W" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);
        } else date.setFullYear(d.y, d.m, d.d);
        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);
        return localZ ? date._ : date;
      };
      format.toString = function() {
        return template;
      };
      return format;
    }
    function d3_time_parse(date, template, string, j) {
      var c, p, t, i = 0, n = template.length, m = string.length;
      while (i < n) {
        if (j >= m) return -1;
        c = template.charCodeAt(i++);
        if (c === 37) {
          t = template.charAt(i++);
          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];
          if (!p || (j = p(date, string, j)) < 0) return -1;
        } else if (c != string.charCodeAt(j++)) {
          return -1;
        }
      }
      return j;
    }
    d3_time_format.utc = function(template) {
      var local = d3_time_format(template);
      function format(date) {
        try {
          d3_date = d3_date_utc;
          var utc = new d3_date();
          utc._ = date;
          return local(utc);
        } finally {
          d3_date = Date;
        }
      }
      format.parse = function(string) {
        try {
          d3_date = d3_date_utc;
          var date = local.parse(string);
          return date && date._;
        } finally {
          d3_date = Date;
        }
      };
      format.toString = local.toString;
      return format;
    };
    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;
    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);
    locale_periods.forEach(function(p, i) {
      d3_time_periodLookup.set(p.toLowerCase(), i);
    });
    var d3_time_formats = {
      a: function(d) {
        return locale_shortDays[d.getDay()];
      },
      A: function(d) {
        return locale_days[d.getDay()];
      },
      b: function(d) {
        return locale_shortMonths[d.getMonth()];
      },
      B: function(d) {
        return locale_months[d.getMonth()];
      },
      c: d3_time_format(locale_dateTime),
      d: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      e: function(d, p) {
        return d3_time_formatPad(d.getDate(), p, 2);
      },
      H: function(d, p) {
        return d3_time_formatPad(d.getHours(), p, 2);
      },
      I: function(d, p) {
        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);
      },
      j: function(d, p) {
        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);
      },
      L: function(d, p) {
        return d3_time_formatPad(d.getMilliseconds(), p, 3);
      },
      m: function(d, p) {
        return d3_time_formatPad(d.getMonth() + 1, p, 2);
      },
      M: function(d, p) {
        return d3_time_formatPad(d.getMinutes(), p, 2);
      },
      p: function(d) {
        return locale_periods[+(d.getHours() >= 12)];
      },
      S: function(d, p) {
        return d3_time_formatPad(d.getSeconds(), p, 2);
      },
      U: function(d, p) {
        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);
      },
      w: function(d) {
        return d.getDay();
      },
      W: function(d, p) {
        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);
      },
      x: d3_time_format(locale_date),
      X: d3_time_format(locale_time),
      y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 100, p, 2);
      },
      Y: function(d, p) {
        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);
      },
      Z: d3_time_zone,
      "%": function() {
        return "%";
      }
    };
    var d3_time_parsers = {
      a: d3_time_parseWeekdayAbbrev,
      A: d3_time_parseWeekday,
      b: d3_time_parseMonthAbbrev,
      B: d3_time_parseMonth,
      c: d3_time_parseLocaleFull,
      d: d3_time_parseDay,
      e: d3_time_parseDay,
      H: d3_time_parseHour24,
      I: d3_time_parseHour24,
      j: d3_time_parseDayOfYear,
      L: d3_time_parseMilliseconds,
      m: d3_time_parseMonthNumber,
      M: d3_time_parseMinutes,
      p: d3_time_parseAmPm,
      S: d3_time_parseSeconds,
      U: d3_time_parseWeekNumberSunday,
      w: d3_time_parseWeekdayNumber,
      W: d3_time_parseWeekNumberMonday,
      x: d3_time_parseLocaleDate,
      X: d3_time_parseLocaleTime,
      y: d3_time_parseYear,
      Y: d3_time_parseFullYear,
      Z: d3_time_parseZone,
      "%": d3_time_parseLiteralPercent
    };
    function d3_time_parseWeekdayAbbrev(date, string, i) {
      d3_time_dayAbbrevRe.lastIndex = 0;
      var n = d3_time_dayAbbrevRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseWeekday(date, string, i) {
      d3_time_dayRe.lastIndex = 0;
      var n = d3_time_dayRe.exec(string.slice(i));
      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonthAbbrev(date, string, i) {
      d3_time_monthAbbrevRe.lastIndex = 0;
      var n = d3_time_monthAbbrevRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseMonth(date, string, i) {
      d3_time_monthRe.lastIndex = 0;
      var n = d3_time_monthRe.exec(string.slice(i));
      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
    }
    function d3_time_parseLocaleFull(date, string, i) {
      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);
    }
    function d3_time_parseLocaleDate(date, string, i) {
      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);
    }
    function d3_time_parseLocaleTime(date, string, i) {
      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);
    }
    function d3_time_parseAmPm(date, string, i) {
      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());
      return n == null ? -1 : (date.p = n, i);
    }
    return d3_time_format;
  }
  var d3_time_formatPads = {
    "-": "",
    _: " ",
    "0": "0"
  }, d3_time_numberRe = /^\s*\d+/, d3_time_percentRe = /^%/;
  function d3_time_formatPad(value, fill, width) {
    var sign = value < 0 ? "-" : "", string = (sign ? -value : value) + "", length = string.length;
    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
  }
  function d3_time_formatRe(names) {
    return new RegExp("^(?:" + names.map(d3.requote).join("|") + ")", "i");
  }
  function d3_time_formatLookup(names) {
    var map = new d3_Map(), i = -1, n = names.length;
    while (++i < n) map.set(names[i].toLowerCase(), i);
    return map;
  }
  function d3_time_parseWeekdayNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 1));
    return n ? (date.w = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberSunday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.U = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseWeekNumberMonday(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i));
    return n ? (date.W = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseFullYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 4));
    return n ? (date.y = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;
  }
  function d3_time_parseZone(date, string, i) {
    return /^[+-]\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, 
    i + 5) : -1;
  }
  function d3_time_expandYear(d) {
    return d + (d > 68 ? 1900 : 2e3);
  }
  function d3_time_parseMonthNumber(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;
  }
  function d3_time_parseDay(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.d = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseDayOfYear(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.j = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseHour24(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.H = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMinutes(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.M = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseSeconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 2));
    return n ? (date.S = +n[0], i + n[0].length) : -1;
  }
  function d3_time_parseMilliseconds(date, string, i) {
    d3_time_numberRe.lastIndex = 0;
    var n = d3_time_numberRe.exec(string.slice(i, i + 3));
    return n ? (date.L = +n[0], i + n[0].length) : -1;
  }
  function d3_time_zone(d) {
    var z = d.getTimezoneOffset(), zs = z > 0 ? "-" : "+", zh = abs(z) / 60 | 0, zm = abs(z) % 60;
    return zs + d3_time_formatPad(zh, "0", 2) + d3_time_formatPad(zm, "0", 2);
  }
  function d3_time_parseLiteralPercent(date, string, i) {
    d3_time_percentRe.lastIndex = 0;
    var n = d3_time_percentRe.exec(string.slice(i, i + 1));
    return n ? i + n[0].length : -1;
  }
  function d3_time_formatMulti(formats) {
    var n = formats.length, i = -1;
    while (++i < n) formats[i][0] = this(formats[i][0]);
    return function(date) {
      var i = 0, f = formats[i];
      while (!f[1](date)) f = formats[++i];
      return f[0](date);
    };
  }
  d3.locale = function(locale) {
    return {
      numberFormat: d3_locale_numberFormat(locale),
      timeFormat: d3_locale_timeFormat(locale)
    };
  };
  var d3_locale_enUS = d3.locale({
    decimal: ".",
    thousands: ",",
    grouping: [ 3 ],
    currency: [ "$", "" ],
    dateTime: "%a %b %e %X %Y",
    date: "%m/%d/%Y",
    time: "%H:%M:%S",
    periods: [ "AM", "PM" ],
    days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
    shortDays: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
    months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
    shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ]
  });
  d3.format = d3_locale_enUS.numberFormat;
  d3.geo = {};
  function d3_adder() {}
  d3_adder.prototype = {
    s: 0,
    t: 0,
    add: function(y) {
      d3_adderSum(y, this.t, d3_adderTemp);
      d3_adderSum(d3_adderTemp.s, this.s, this);
      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;
    },
    reset: function() {
      this.s = this.t = 0;
    },
    valueOf: function() {
      return this.s;
    }
  };
  var d3_adderTemp = new d3_adder();
  function d3_adderSum(a, b, o) {
    var x = o.s = a + b, bv = x - a, av = x - bv;
    o.t = a - av + (b - bv);
  }
  d3.geo.stream = function(object, listener) {
    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {
      d3_geo_streamObjectType[object.type](object, listener);
    } else {
      d3_geo_streamGeometry(object, listener);
    }
  };
  function d3_geo_streamGeometry(geometry, listener) {
    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {
      d3_geo_streamGeometryType[geometry.type](geometry, listener);
    }
  }
  var d3_geo_streamObjectType = {
    Feature: function(feature, listener) {
      d3_geo_streamGeometry(feature.geometry, listener);
    },
    FeatureCollection: function(object, listener) {
      var features = object.features, i = -1, n = features.length;
      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);
    }
  };
  var d3_geo_streamGeometryType = {
    Sphere: function(object, listener) {
      listener.sphere();
    },
    Point: function(object, listener) {
      object = object.coordinates;
      listener.point(object[0], object[1], object[2]);
    },
    MultiPoint: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);
    },
    LineString: function(object, listener) {
      d3_geo_streamLine(object.coordinates, listener, 0);
    },
    MultiLineString: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);
    },
    Polygon: function(object, listener) {
      d3_geo_streamPolygon(object.coordinates, listener);
    },
    MultiPolygon: function(object, listener) {
      var coordinates = object.coordinates, i = -1, n = coordinates.length;
      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);
    },
    GeometryCollection: function(object, listener) {
      var geometries = object.geometries, i = -1, n = geometries.length;
      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);
    }
  };
  function d3_geo_streamLine(coordinates, listener, closed) {
    var i = -1, n = coordinates.length - closed, coordinate;
    listener.lineStart();
    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);
    listener.lineEnd();
  }
  function d3_geo_streamPolygon(coordinates, listener) {
    var i = -1, n = coordinates.length;
    listener.polygonStart();
    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);
    listener.polygonEnd();
  }
  d3.geo.area = function(object) {
    d3_geo_areaSum = 0;
    d3.geo.stream(object, d3_geo_area);
    return d3_geo_areaSum;
  };
  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();
  var d3_geo_area = {
    sphere: function() {
      d3_geo_areaSum += 4 * π;
    },
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_areaRingSum.reset();
      d3_geo_area.lineStart = d3_geo_areaRingStart;
    },
    polygonEnd: function() {
      var area = 2 * d3_geo_areaRingSum;
      d3_geo_areaSum += area < 0 ? 4 * π + area : area;
      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;
    }
  };
  function d3_geo_areaRingStart() {
    var λ00, φ00, λ0, cosφ0, sinφ0;
    d3_geo_area.point = function(λ, φ) {
      d3_geo_area.point = nextPoint;
      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), 
      sinφ0 = Math.sin(φ);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      φ = φ * d3_radians / 2 + π / 4;
      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);
      d3_geo_areaRingSum.add(Math.atan2(v, u));
      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;
    }
    d3_geo_area.lineEnd = function() {
      nextPoint(λ00, φ00);
    };
  }
  function d3_geo_cartesian(spherical) {
    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);
    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];
  }
  function d3_geo_cartesianDot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  function d3_geo_cartesianCross(a, b) {
    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];
  }
  function d3_geo_cartesianAdd(a, b) {
    a[0] += b[0];
    a[1] += b[1];
    a[2] += b[2];
  }
  function d3_geo_cartesianScale(vector, k) {
    return [ vector[0] * k, vector[1] * k, vector[2] * k ];
  }
  function d3_geo_cartesianNormalize(d) {
    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
    d[0] /= l;
    d[1] /= l;
    d[2] /= l;
  }
  function d3_geo_spherical(cartesian) {
    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];
  }
  function d3_geo_sphericalEqual(a, b) {
    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;
  }
  d3.geo.bounds = function() {
    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;
    var bound = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function() {
        bound.point = ringPoint;
        bound.lineStart = ringStart;
        bound.lineEnd = ringEnd;
        dλSum = 0;
        d3_geo_area.polygonStart();
      },
      polygonEnd: function() {
        d3_geo_area.polygonEnd();
        bound.point = point;
        bound.lineStart = lineStart;
        bound.lineEnd = lineEnd;
        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;
        range[0] = λ0, range[1] = λ1;
      }
    };
    function point(λ, φ) {
      ranges.push(range = [ λ0 = λ, λ1 = λ ]);
      if (φ < φ0) φ0 = φ;
      if (φ > φ1) φ1 = φ;
    }
    function linePoint(λ, φ) {
      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);
      if (p0) {
        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);
        d3_geo_cartesianNormalize(inflection);
        inflection = d3_geo_spherical(inflection);
        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;
        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = inflection[1] * d3_degrees;
          if (φi > φ1) φ1 = φi;
        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {
          var φi = -inflection[1] * d3_degrees;
          if (φi < φ0) φ0 = φi;
        } else {
          if (φ < φ0) φ0 = φ;
          if (φ > φ1) φ1 = φ;
        }
        if (antimeridian) {
          if (λ < λ_) {
            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
          } else {
            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
          }
        } else {
          if (λ1 >= λ0) {
            if (λ < λ0) λ0 = λ;
            if (λ > λ1) λ1 = λ;
          } else {
            if (λ > λ_) {
              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;
            } else {
              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;
            }
          }
        }
      } else {
        point(λ, φ);
      }
      p0 = p, λ_ = λ;
    }
    function lineStart() {
      bound.point = linePoint;
    }
    function lineEnd() {
      range[0] = λ0, range[1] = λ1;
      bound.point = point;
      p0 = null;
    }
    function ringPoint(λ, φ) {
      if (p0) {
        var dλ = λ - λ_;
        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;
      } else λ__ = λ, φ__ = φ;
      d3_geo_area.point(λ, φ);
      linePoint(λ, φ);
    }
    function ringStart() {
      d3_geo_area.lineStart();
    }
    function ringEnd() {
      ringPoint(λ__, φ__);
      d3_geo_area.lineEnd();
      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);
      range[0] = λ0, range[1] = λ1;
      p0 = null;
    }
    function angle(λ0, λ1) {
      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;
    }
    function compareRanges(a, b) {
      return a[0] - b[0];
    }
    function withinRange(x, range) {
      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
    }
    return function(feature) {
      φ1 = λ1 = -(λ0 = φ0 = Infinity);
      ranges = [];
      d3.geo.stream(feature, bound);
      var n = ranges.length;
      if (n) {
        ranges.sort(compareRanges);
        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {
          b = ranges[i];
          if (withinRange(b[0], a) || withinRange(b[1], a)) {
            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
          } else {
            merged.push(a = b);
          }
        }
        var best = -Infinity, dλ;
        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {
          b = merged[i];
          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];
        }
      }
      ranges = range = null;
      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];
    };
  }();
  d3.geo.centroid = function(object) {
    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
    d3.geo.stream(object, d3_geo_centroid);
    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;
    if (m < ε2) {
      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;
      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;
      m = x * x + y * y + z * z;
      if (m < ε2) return [ NaN, NaN ];
    }
    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];
  };
  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;
  var d3_geo_centroid = {
    sphere: d3_noop,
    point: d3_geo_centroidPoint,
    lineStart: d3_geo_centroidLineStart,
    lineEnd: d3_geo_centroidLineEnd,
    polygonStart: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;
    }
  };
  function d3_geo_centroidPoint(λ, φ) {
    λ *= d3_radians;
    var cosφ = Math.cos(φ *= d3_radians);
    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));
  }
  function d3_geo_centroidPointXYZ(x, y, z) {
    ++d3_geo_centroidW0;
    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;
    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;
    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;
  }
  function d3_geo_centroidLineStart() {
    var x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroid.point = nextPoint;
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_centroidLineEnd() {
    d3_geo_centroid.point = d3_geo_centroidPoint;
  }
  function d3_geo_centroidRingStart() {
    var λ00, φ00, x0, y0, z0;
    d3_geo_centroid.point = function(λ, φ) {
      λ00 = λ, φ00 = φ;
      d3_geo_centroid.point = nextPoint;
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians);
      x0 = cosφ * Math.cos(λ);
      y0 = cosφ * Math.sin(λ);
      z0 = Math.sin(φ);
      d3_geo_centroidPointXYZ(x0, y0, z0);
    };
    d3_geo_centroid.lineEnd = function() {
      nextPoint(λ00, φ00);
      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;
      d3_geo_centroid.point = d3_geo_centroidPoint;
    };
    function nextPoint(λ, φ) {
      λ *= d3_radians;
      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);
      d3_geo_centroidX2 += v * cx;
      d3_geo_centroidY2 += v * cy;
      d3_geo_centroidZ2 += v * cz;
      d3_geo_centroidW1 += w;
      d3_geo_centroidX1 += w * (x0 + (x0 = x));
      d3_geo_centroidY1 += w * (y0 + (y0 = y));
      d3_geo_centroidZ1 += w * (z0 + (z0 = z));
      d3_geo_centroidPointXYZ(x0, y0, z0);
    }
  }
  function d3_geo_compose(a, b) {
    function compose(x, y) {
      return x = a(x, y), b(x[0], x[1]);
    }
    if (a.invert && b.invert) compose.invert = function(x, y) {
      return x = b.invert(x, y), x && a.invert(x[0], x[1]);
    };
    return compose;
  }
  function d3_true() {
    return true;
  }
  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {
    var subject = [], clip = [];
    segments.forEach(function(segment) {
      if ((n = segment.length - 1) <= 0) return;
      var n, p0 = segment[0], p1 = segment[n];
      if (d3_geo_sphericalEqual(p0, p1)) {
        listener.lineStart();
        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);
        listener.lineEnd();
        return;
      }
      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);
      a.o = b;
      subject.push(a);
      clip.push(b);
      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);
      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);
      a.o = b;
      subject.push(a);
      clip.push(b);
    });
    clip.sort(compare);
    d3_geo_clipPolygonLinkCircular(subject);
    d3_geo_clipPolygonLinkCircular(clip);
    if (!subject.length) return;
    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {
      clip[i].e = entry = !entry;
    }
    var start = subject[0], points, point;
    while (1) {
      var current = start, isSubject = true;
      while (current.v) if ((current = current.n) === start) return;
      points = current.z;
      listener.lineStart();
      do {
        current.v = current.o.v = true;
        if (current.e) {
          if (isSubject) {
            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.n.x, 1, listener);
          }
          current = current.n;
        } else {
          if (isSubject) {
            points = current.p.z;
            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);
          } else {
            interpolate(current.x, current.p.x, -1, listener);
          }
          current = current.p;
        }
        current = current.o;
        points = current.z;
        isSubject = !isSubject;
      } while (!current.v);
      listener.lineEnd();
    }
  }
  function d3_geo_clipPolygonLinkCircular(array) {
    if (!(n = array.length)) return;
    var n, i = 0, a = array[0], b;
    while (++i < n) {
      a.n = b = array[i];
      b.p = a;
      a = b;
    }
    a.n = b = array[0];
    b.p = a;
  }
  function d3_geo_clipPolygonIntersection(point, points, other, entry) {
    this.x = point;
    this.z = points;
    this.o = other;
    this.e = entry;
    this.v = false;
    this.n = this.p = null;
  }
  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {
    return function(rotate, listener) {
      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          clip.point = pointRing;
          clip.lineStart = ringStart;
          clip.lineEnd = ringEnd;
          segments = [];
          polygon = [];
        },
        polygonEnd: function() {
          clip.point = point;
          clip.lineStart = lineStart;
          clip.lineEnd = lineEnd;
          segments = d3.merge(segments);
          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);
          if (segments.length) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);
          } else if (clipStartInside) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            interpolate(null, null, 1, listener);
            listener.lineEnd();
          }
          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;
          segments = polygon = null;
        },
        sphere: function() {
          listener.polygonStart();
          listener.lineStart();
          interpolate(null, null, 1, listener);
          listener.lineEnd();
          listener.polygonEnd();
        }
      };
      function point(λ, φ) {
        var point = rotate(λ, φ);
        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);
      }
      function pointLine(λ, φ) {
        var point = rotate(λ, φ);
        line.point(point[0], point[1]);
      }
      function lineStart() {
        clip.point = pointLine;
        line.lineStart();
      }
      function lineEnd() {
        clip.point = point;
        line.lineEnd();
      }
      var segments;
      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;
      function pointRing(λ, φ) {
        ring.push([ λ, φ ]);
        var point = rotate(λ, φ);
        ringListener.point(point[0], point[1]);
      }
      function ringStart() {
        ringListener.lineStart();
        ring = [];
      }
      function ringEnd() {
        pointRing(ring[0][0], ring[0][1]);
        ringListener.lineEnd();
        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;
        ring.pop();
        polygon.push(ring);
        ring = null;
        if (!n) return;
        if (clean & 1) {
          segment = ringSegments[0];
          var n = segment.length - 1, i = -1, point;
          if (n > 0) {
            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;
            listener.lineStart();
            while (++i < n) listener.point((point = segment[i])[0], point[1]);
            listener.lineEnd();
          }
          return;
        }
        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));
      }
      return clip;
    };
  }
  function d3_geo_clipSegmentLength1(segment) {
    return segment.length > 1;
  }
  function d3_geo_clipBufferListener() {
    var lines = [], line;
    return {
      lineStart: function() {
        lines.push(line = []);
      },
      point: function(λ, φ) {
        line.push([ λ, φ ]);
      },
      lineEnd: d3_noop,
      buffer: function() {
        var buffer = lines;
        lines = [];
        line = null;
        return buffer;
      },
      rejoin: function() {
        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
      }
    };
  }
  function d3_geo_clipSort(a, b) {
    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);
  }
  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);
  function d3_geo_clipAntimeridianLine(listener) {
    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;
    return {
      lineStart: function() {
        listener.lineStart();
        clean = 1;
      },
      point: function(λ1, φ1) {
        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);
        if (abs(dλ - π) < ε) {
          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          listener.point(λ1, φ0);
          clean = 0;
        } else if (sλ0 !== sλ1 && dλ >= π) {
          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;
          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;
          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);
          listener.point(sλ0, φ0);
          listener.lineEnd();
          listener.lineStart();
          listener.point(sλ1, φ0);
          clean = 0;
        }
        listener.point(λ0 = λ1, φ0 = φ1);
        sλ0 = sλ1;
      },
      lineEnd: function() {
        listener.lineEnd();
        λ0 = φ0 = NaN;
      },
      clean: function() {
        return 2 - clean;
      }
    };
  }
  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {
    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);
    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;
  }
  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {
    var φ;
    if (from == null) {
      φ = direction * halfπ;
      listener.point(-π, φ);
      listener.point(0, φ);
      listener.point(π, φ);
      listener.point(π, 0);
      listener.point(π, -φ);
      listener.point(0, -φ);
      listener.point(-π, -φ);
      listener.point(-π, 0);
      listener.point(-π, φ);
    } else if (abs(from[0] - to[0]) > ε) {
      var s = from[0] < to[0] ? π : -π;
      φ = direction * s / 2;
      listener.point(-s, φ);
      listener.point(0, φ);
      listener.point(s, φ);
    } else {
      listener.point(to[0], to[1]);
    }
  }
  function d3_geo_pointInPolygon(point, polygon) {
    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;
    d3_geo_areaRingSum.reset();
    for (var i = 0, n = polygon.length; i < n; ++i) {
      var ring = polygon[i], m = ring.length;
      if (!m) continue;
      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;
      while (true) {
        if (j === m) j = 0;
        point = ring[j];
        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;
        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));
        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;
        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {
          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));
          d3_geo_cartesianNormalize(arc);
          var intersection = d3_geo_cartesianCross(meridianNormal, arc);
          d3_geo_cartesianNormalize(intersection);
          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);
          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {
            winding += antimeridian ^ dλ >= 0 ? 1 : -1;
          }
        }
        if (!j++) break;
        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;
      }
    }
    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < -ε) ^ winding & 1;
  }
  function d3_geo_clipCircle(radius) {
    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);
    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);
    function visible(λ, φ) {
      return Math.cos(λ) * Math.cos(φ) > cr;
    }
    function clipLine(listener) {
      var point0, c0, v0, v00, clean;
      return {
        lineStart: function() {
          v00 = v0 = false;
          clean = 1;
        },
        point: function(λ, φ) {
          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;
          if (!point0 && (v00 = v0 = v)) listener.lineStart();
          if (v !== v0) {
            point2 = intersect(point0, point1);
            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {
              point1[0] += ε;
              point1[1] += ε;
              v = visible(point1[0], point1[1]);
            }
          }
          if (v !== v0) {
            clean = 0;
            if (v) {
              listener.lineStart();
              point2 = intersect(point1, point0);
              listener.point(point2[0], point2[1]);
            } else {
              point2 = intersect(point0, point1);
              listener.point(point2[0], point2[1]);
              listener.lineEnd();
            }
            point0 = point2;
          } else if (notHemisphere && point0 && smallRadius ^ v) {
            var t;
            if (!(c & c0) && (t = intersect(point1, point0, true))) {
              clean = 0;
              if (smallRadius) {
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
              } else {
                listener.point(t[1][0], t[1][1]);
                listener.lineEnd();
                listener.lineStart();
                listener.point(t[0][0], t[0][1]);
              }
            }
          }
          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {
            listener.point(point1[0], point1[1]);
          }
          point0 = point1, v0 = v, c0 = c;
        },
        lineEnd: function() {
          if (v0) listener.lineEnd();
          point0 = null;
        },
        clean: function() {
          return clean | (v00 && v0) << 1;
        }
      };
    }
    function intersect(a, b, two) {
      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);
      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
      if (!determinant) return !two && a;
      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);
      d3_geo_cartesianAdd(A, B);
      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);
      if (t2 < 0) return;
      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);
      d3_geo_cartesianAdd(q, A);
      q = d3_geo_spherical(q);
      if (!two) return q;
      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;
      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;
      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;
      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;
      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {
        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);
        d3_geo_cartesianAdd(q1, A);
        return [ q, d3_geo_spherical(q1) ];
      }
    }
    function code(λ, φ) {
      var r = smallRadius ? radius : π - radius, code = 0;
      if (λ < -r) code |= 1; else if (λ > r) code |= 2;
      if (φ < -r) code |= 4; else if (φ > r) code |= 8;
      return code;
    }
  }
  function d3_geom_clipLine(x0, y0, x1, y1) {
    return function(line) {
      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;
      r = x0 - ax;
      if (!dx && r > 0) return;
      r /= dx;
      if (dx < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dx > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = x1 - ax;
      if (!dx && r < 0) return;
      r /= dx;
      if (dx < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dx > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      r = y0 - ay;
      if (!dy && r > 0) return;
      r /= dy;
      if (dy < 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      } else if (dy > 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      }
      r = y1 - ay;
      if (!dy && r < 0) return;
      r /= dy;
      if (dy < 0) {
        if (r > t1) return;
        if (r > t0) t0 = r;
      } else if (dy > 0) {
        if (r < t0) return;
        if (r < t1) t1 = r;
      }
      if (t0 > 0) line.a = {
        x: ax + t0 * dx,
        y: ay + t0 * dy
      };
      if (t1 < 1) line.b = {
        x: ax + t1 * dx,
        y: ay + t1 * dy
      };
      return line;
    };
  }
  var d3_geo_clipExtentMAX = 1e9;
  d3.geo.clipExtent = function() {
    var x0, y0, x1, y1, stream, clip, clipExtent = {
      stream: function(output) {
        if (stream) stream.valid = false;
        stream = clip(output);
        stream.valid = true;
        return stream;
      },
      extent: function(_) {
        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);
        if (stream) stream.valid = false, stream = null;
        return clipExtent;
      }
    };
    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);
  };
  function d3_geo_clipExtent(x0, y0, x1, y1) {
    return function(listener) {
      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;
      var clip = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          listener = bufferListener;
          segments = [];
          polygon = [];
          clean = true;
        },
        polygonEnd: function() {
          listener = listener_;
          segments = d3.merge(segments);
          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;
          if (inside || visible) {
            listener.polygonStart();
            if (inside) {
              listener.lineStart();
              interpolate(null, null, 1, listener);
              listener.lineEnd();
            }
            if (visible) {
              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);
            }
            listener.polygonEnd();
          }
          segments = polygon = ring = null;
        }
      };
      function insidePolygon(p) {
        var wn = 0, n = polygon.length, y = p[1];
        for (var i = 0; i < n; ++i) {
          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {
            b = v[j];
            if (a[1] <= y) {
              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;
            } else {
              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;
            }
            a = b;
          }
        }
        return wn !== 0;
      }
      function interpolate(from, to, direction, listener) {
        var a = 0, a1 = 0;
        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {
          do {
            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);
          } while ((a = (a + direction + 4) % 4) !== a1);
        } else {
          listener.point(to[0], to[1]);
        }
      }
      function pointVisible(x, y) {
        return x0 <= x && x <= x1 && y0 <= y && y <= y1;
      }
      function point(x, y) {
        if (pointVisible(x, y)) listener.point(x, y);
      }
      var x__, y__, v__, x_, y_, v_, first, clean;
      function lineStart() {
        clip.point = linePoint;
        if (polygon) polygon.push(ring = []);
        first = true;
        v_ = false;
        x_ = y_ = NaN;
      }
      function lineEnd() {
        if (segments) {
          linePoint(x__, y__);
          if (v__ && v_) bufferListener.rejoin();
          segments.push(bufferListener.buffer());
        }
        clip.point = point;
        if (v_) listener.lineEnd();
      }
      function linePoint(x, y) {
        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));
        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));
        var v = pointVisible(x, y);
        if (polygon) ring.push([ x, y ]);
        if (first) {
          x__ = x, y__ = y, v__ = v;
          first = false;
          if (v) {
            listener.lineStart();
            listener.point(x, y);
          }
        } else {
          if (v && v_) listener.point(x, y); else {
            var l = {
              a: {
                x: x_,
                y: y_
              },
              b: {
                x: x,
                y: y
              }
            };
            if (clipLine(l)) {
              if (!v_) {
                listener.lineStart();
                listener.point(l.a.x, l.a.y);
              }
              listener.point(l.b.x, l.b.y);
              if (!v) listener.lineEnd();
              clean = false;
            } else if (v) {
              listener.lineStart();
              listener.point(x, y);
              clean = false;
            }
          }
        }
        x_ = x, y_ = y, v_ = v;
      }
      return clip;
    };
    function corner(p, direction) {
      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;
    }
    function compare(a, b) {
      return comparePoints(a.x, b.x);
    }
    function comparePoints(a, b) {
      var ca = corner(a, 1), cb = corner(b, 1);
      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
    }
  }
  function d3_geo_conic(projectAt) {
    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);
    p.parallels = function(_) {
      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];
      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);
    };
    return p;
  }
  function d3_geo_conicEqualArea(φ0, φ1) {
    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;
    function forward(λ, φ) {
      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;
      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = ρ0 - y;
      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];
    };
    return forward;
  }
  (d3.geo.conicEqualArea = function() {
    return d3_geo_conic(d3_geo_conicEqualArea);
  }).raw = d3_geo_conicEqualArea;
  d3.geo.albers = function() {
    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);
  };
  d3.geo.albersUsa = function() {
    var lower48 = d3.geo.albers();
    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);
    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);
    var point, pointStream = {
      point: function(x, y) {
        point = [ x, y ];
      }
    }, lower48Point, alaskaPoint, hawaiiPoint;
    function albersUsa(coordinates) {
      var x = coordinates[0], y = coordinates[1];
      point = null;
      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);
      return point;
    }
    albersUsa.invert = function(coordinates) {
      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;
      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);
    };
    albersUsa.stream = function(stream) {
      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);
      return {
        point: function(x, y) {
          lower48Stream.point(x, y);
          alaskaStream.point(x, y);
          hawaiiStream.point(x, y);
        },
        sphere: function() {
          lower48Stream.sphere();
          alaskaStream.sphere();
          hawaiiStream.sphere();
        },
        lineStart: function() {
          lower48Stream.lineStart();
          alaskaStream.lineStart();
          hawaiiStream.lineStart();
        },
        lineEnd: function() {
          lower48Stream.lineEnd();
          alaskaStream.lineEnd();
          hawaiiStream.lineEnd();
        },
        polygonStart: function() {
          lower48Stream.polygonStart();
          alaskaStream.polygonStart();
          hawaiiStream.polygonStart();
        },
        polygonEnd: function() {
          lower48Stream.polygonEnd();
          alaskaStream.polygonEnd();
          hawaiiStream.polygonEnd();
        }
      };
    };
    albersUsa.precision = function(_) {
      if (!arguments.length) return lower48.precision();
      lower48.precision(_);
      alaska.precision(_);
      hawaii.precision(_);
      return albersUsa;
    };
    albersUsa.scale = function(_) {
      if (!arguments.length) return lower48.scale();
      lower48.scale(_);
      alaska.scale(_ * .35);
      hawaii.scale(_);
      return albersUsa.translate(lower48.translate());
    };
    albersUsa.translate = function(_) {
      if (!arguments.length) return lower48.translate();
      var k = lower48.scale(), x = +_[0], y = +_[1];
      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;
      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;
      return albersUsa;
    };
    return albersUsa.scale(1070);
  };
  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {
    point: d3_noop,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: function() {
      d3_geo_pathAreaPolygon = 0;
      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;
      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);
    }
  };
  function d3_geo_pathAreaRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathArea.point = function(x, y) {
      d3_geo_pathArea.point = nextPoint;
      x00 = x0 = x, y00 = y0 = y;
    };
    function nextPoint(x, y) {
      d3_geo_pathAreaPolygon += y0 * x - x0 * y;
      x0 = x, y0 = y;
    }
    d3_geo_pathArea.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;
  var d3_geo_pathBounds = {
    point: d3_geo_pathBoundsPoint,
    lineStart: d3_noop,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_pathBoundsPoint(x, y) {
    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;
    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;
    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;
    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;
  }
  function d3_geo_pathBuffer() {
    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointCircle = d3_geo_pathBufferCircle(_);
        return stream;
      },
      result: function() {
        if (buffer.length) {
          var result = buffer.join("");
          buffer = [];
          return result;
        }
      }
    };
    function point(x, y) {
      buffer.push("M", x, ",", y, pointCircle);
    }
    function pointLineStart(x, y) {
      buffer.push("M", x, ",", y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      buffer.push("L", x, ",", y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      buffer.push("Z");
    }
    return stream;
  }
  function d3_geo_pathBufferCircle(radius) {
    return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
  }
  var d3_geo_pathCentroid = {
    point: d3_geo_pathCentroidPoint,
    lineStart: d3_geo_pathCentroidLineStart,
    lineEnd: d3_geo_pathCentroidLineEnd,
    polygonStart: function() {
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;
    },
    polygonEnd: function() {
      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;
      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;
    }
  };
  function d3_geo_pathCentroidPoint(x, y) {
    d3_geo_centroidX0 += x;
    d3_geo_centroidY0 += y;
    ++d3_geo_centroidZ0;
  }
  function d3_geo_pathCentroidLineStart() {
    var x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
  }
  function d3_geo_pathCentroidLineEnd() {
    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;
  }
  function d3_geo_pathCentroidRingStart() {
    var x00, y00, x0, y0;
    d3_geo_pathCentroid.point = function(x, y) {
      d3_geo_pathCentroid.point = nextPoint;
      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);
    };
    function nextPoint(x, y) {
      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);
      d3_geo_centroidX1 += z * (x0 + x) / 2;
      d3_geo_centroidY1 += z * (y0 + y) / 2;
      d3_geo_centroidZ1 += z;
      z = y0 * x - x0 * y;
      d3_geo_centroidX2 += z * (x0 + x);
      d3_geo_centroidY2 += z * (y0 + y);
      d3_geo_centroidZ2 += z * 3;
      d3_geo_pathCentroidPoint(x0 = x, y0 = y);
    }
    d3_geo_pathCentroid.lineEnd = function() {
      nextPoint(x00, y00);
    };
  }
  function d3_geo_pathContext(context) {
    var pointRadius = 4.5;
    var stream = {
      point: point,
      lineStart: function() {
        stream.point = pointLineStart;
      },
      lineEnd: lineEnd,
      polygonStart: function() {
        stream.lineEnd = lineEndPolygon;
      },
      polygonEnd: function() {
        stream.lineEnd = lineEnd;
        stream.point = point;
      },
      pointRadius: function(_) {
        pointRadius = _;
        return stream;
      },
      result: d3_noop
    };
    function point(x, y) {
      context.moveTo(x + pointRadius, y);
      context.arc(x, y, pointRadius, 0, τ);
    }
    function pointLineStart(x, y) {
      context.moveTo(x, y);
      stream.point = pointLine;
    }
    function pointLine(x, y) {
      context.lineTo(x, y);
    }
    function lineEnd() {
      stream.point = point;
    }
    function lineEndPolygon() {
      context.closePath();
    }
    return stream;
  }
  function d3_geo_resample(project) {
    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;
    function resample(stream) {
      return (maxDepth ? resampleRecursive : resampleNone)(stream);
    }
    function resampleNone(stream) {
      return d3_geo_transformPoint(stream, function(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      });
    }
    function resampleRecursive(stream) {
      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;
      var resample = {
        point: point,
        lineStart: lineStart,
        lineEnd: lineEnd,
        polygonStart: function() {
          stream.polygonStart();
          resample.lineStart = ringStart;
        },
        polygonEnd: function() {
          stream.polygonEnd();
          resample.lineStart = lineStart;
        }
      };
      function point(x, y) {
        x = project(x, y);
        stream.point(x[0], x[1]);
      }
      function lineStart() {
        x0 = NaN;
        resample.point = linePoint;
        stream.lineStart();
      }
      function linePoint(λ, φ) {
        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
        stream.point(x0, y0);
      }
      function lineEnd() {
        resample.point = point;
        stream.lineEnd();
      }
      function ringStart() {
        lineStart();
        resample.point = ringPoint;
        resample.lineEnd = ringEnd;
      }
      function ringPoint(λ, φ) {
        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
        resample.point = linePoint;
      }
      function ringEnd() {
        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);
        resample.lineEnd = lineEnd;
        lineEnd();
      }
      return resample;
    }
    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {
      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;
      if (d2 > 4 * δ2 && depth--) {
        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;
        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);
          stream.point(x2, y2);
          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);
        }
      }
    }
    resample.precision = function(_) {
      if (!arguments.length) return Math.sqrt(δ2);
      maxDepth = (δ2 = _ * _) > 0 && 16;
      return resample;
    };
    return resample;
  }
  d3.geo.path = function() {
    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;
    function path(object) {
      if (object) {
        if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);
        d3.geo.stream(object, cacheStream);
      }
      return contextStream.result();
    }
    path.area = function(object) {
      d3_geo_pathAreaSum = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathArea));
      return d3_geo_pathAreaSum;
    };
    path.centroid = function(object) {
      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;
      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));
      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];
    };
    path.bounds = function(object) {
      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);
      d3.geo.stream(object, projectStream(d3_geo_pathBounds));
      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];
    };
    path.projection = function(_) {
      if (!arguments.length) return projection;
      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;
      return reset();
    };
    path.context = function(_) {
      if (!arguments.length) return context;
      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);
      if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
      return reset();
    };
    path.pointRadius = function(_) {
      if (!arguments.length) return pointRadius;
      pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
      return path;
    };
    function reset() {
      cacheStream = null;
      return path;
    }
    return path.projection(d3.geo.albersUsa()).context(null);
  };
  function d3_geo_pathProjectStream(project) {
    var resample = d3_geo_resample(function(x, y) {
      return project([ x * d3_degrees, y * d3_degrees ]);
    });
    return function(stream) {
      return d3_geo_projectionRadians(resample(stream));
    };
  }
  d3.geo.transform = function(methods) {
    return {
      stream: function(stream) {
        var transform = new d3_geo_transform(stream);
        for (var k in methods) transform[k] = methods[k];
        return transform;
      }
    };
  };
  function d3_geo_transform(stream) {
    this.stream = stream;
  }
  d3_geo_transform.prototype = {
    point: function(x, y) {
      this.stream.point(x, y);
    },
    sphere: function() {
      this.stream.sphere();
    },
    lineStart: function() {
      this.stream.lineStart();
    },
    lineEnd: function() {
      this.stream.lineEnd();
    },
    polygonStart: function() {
      this.stream.polygonStart();
    },
    polygonEnd: function() {
      this.stream.polygonEnd();
    }
  };
  function d3_geo_transformPoint(stream, point) {
    return {
      point: point,
      sphere: function() {
        stream.sphere();
      },
      lineStart: function() {
        stream.lineStart();
      },
      lineEnd: function() {
        stream.lineEnd();
      },
      polygonStart: function() {
        stream.polygonStart();
      },
      polygonEnd: function() {
        stream.polygonEnd();
      }
    };
  }
  d3.geo.projection = d3_geo_projection;
  d3.geo.projectionMutator = d3_geo_projectionMutator;
  function d3_geo_projection(project) {
    return d3_geo_projectionMutator(function() {
      return project;
    })();
  }
  function d3_geo_projectionMutator(projectAt) {
    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {
      x = project(x, y);
      return [ x[0] * k + δx, δy - x[1] * k ];
    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;
    function projection(point) {
      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);
      return [ point[0] * k + δx, δy - point[1] * k ];
    }
    function invert(point) {
      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);
      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];
    }
    projection.stream = function(output) {
      if (stream) stream.valid = false;
      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));
      stream.valid = true;
      return stream;
    };
    projection.clipAngle = function(_) {
      if (!arguments.length) return clipAngle;
      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);
      return invalidate();
    };
    projection.clipExtent = function(_) {
      if (!arguments.length) return clipExtent;
      clipExtent = _;
      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;
      return invalidate();
    };
    projection.scale = function(_) {
      if (!arguments.length) return k;
      k = +_;
      return reset();
    };
    projection.translate = function(_) {
      if (!arguments.length) return [ x, y ];
      x = +_[0];
      y = +_[1];
      return reset();
    };
    projection.center = function(_) {
      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];
      λ = _[0] % 360 * d3_radians;
      φ = _[1] % 360 * d3_radians;
      return reset();
    };
    projection.rotate = function(_) {
      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];
      δλ = _[0] % 360 * d3_radians;
      δφ = _[1] % 360 * d3_radians;
      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;
      return reset();
    };
    d3.rebind(projection, projectResample, "precision");
    function reset() {
      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);
      var center = project(λ, φ);
      δx = x - center[0] * k;
      δy = y + center[1] * k;
      return invalidate();
    }
    function invalidate() {
      if (stream) stream.valid = false, stream = null;
      return projection;
    }
    return function() {
      project = projectAt.apply(this, arguments);
      projection.invert = project.invert && invert;
      return reset();
    };
  }
  function d3_geo_projectionRadians(stream) {
    return d3_geo_transformPoint(stream, function(x, y) {
      stream.point(x * d3_radians, y * d3_radians);
    });
  }
  function d3_geo_equirectangular(λ, φ) {
    return [ λ, φ ];
  }
  (d3.geo.equirectangular = function() {
    return d3_geo_projection(d3_geo_equirectangular);
  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;
  d3.geo.rotation = function(rotate) {
    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);
    function forward(coordinates) {
      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    }
    forward.invert = function(coordinates) {
      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);
      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;
    };
    return forward;
  };
  function d3_geo_identityRotation(λ, φ) {
    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
  }
  d3_geo_identityRotation.invert = d3_geo_equirectangular;
  function d3_geo_rotation(δλ, δφ, δγ) {
    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;
  }
  function d3_geo_forwardRotationλ(δλ) {
    return function(λ, φ) {
      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];
    };
  }
  function d3_geo_rotationλ(δλ) {
    var rotation = d3_geo_forwardRotationλ(δλ);
    rotation.invert = d3_geo_forwardRotationλ(-δλ);
    return rotation;
  }
  function d3_geo_rotationφγ(δφ, δγ) {
    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);
    function rotation(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;
      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];
    }
    rotation.invert = function(λ, φ) {
      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;
      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];
    };
    return rotation;
  }
  d3.geo.circle = function() {
    var origin = [ 0, 0 ], angle, precision = 6, interpolate;
    function circle() {
      var center = typeof origin === "function" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];
      interpolate(null, null, 1, {
        point: function(x, y) {
          ring.push(x = rotate(x, y));
          x[0] *= d3_degrees, x[1] *= d3_degrees;
        }
      });
      return {
        type: "Polygon",
        coordinates: [ ring ]
      };
    }
    circle.origin = function(x) {
      if (!arguments.length) return origin;
      origin = x;
      return circle;
    };
    circle.angle = function(x) {
      if (!arguments.length) return angle;
      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);
      return circle;
    };
    circle.precision = function(_) {
      if (!arguments.length) return precision;
      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);
      return circle;
    };
    return circle.angle(90);
  };
  function d3_geo_circleInterpolate(radius, precision) {
    var cr = Math.cos(radius), sr = Math.sin(radius);
    return function(from, to, direction, listener) {
      var step = direction * precision;
      if (from != null) {
        from = d3_geo_circleAngle(cr, from);
        to = d3_geo_circleAngle(cr, to);
        if (direction > 0 ? from < to : from > to) from += direction * τ;
      } else {
        from = radius + direction * τ;
        to = radius - .5 * step;
      }
      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {
        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);
      }
    };
  }
  function d3_geo_circleAngle(cr, point) {
    var a = d3_geo_cartesian(point);
    a[0] -= cr;
    d3_geo_cartesianNormalize(a);
    var angle = d3_acos(-a[1]);
    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);
  }
  d3.geo.distance = function(a, b) {
    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;
    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);
  };
  d3.geo.graticule = function() {
    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;
    function graticule() {
      return {
        type: "MultiLineString",
        coordinates: lines()
      };
    }
    function lines() {
      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {
        return abs(x % DX) > ε;
      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {
        return abs(y % DY) > ε;
      }).map(y));
    }
    graticule.lines = function() {
      return lines().map(function(coordinates) {
        return {
          type: "LineString",
          coordinates: coordinates
        };
      });
    };
    graticule.outline = function() {
      return {
        type: "Polygon",
        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]
      };
    };
    graticule.extent = function(_) {
      if (!arguments.length) return graticule.minorExtent();
      return graticule.majorExtent(_).minorExtent(_);
    };
    graticule.majorExtent = function(_) {
      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];
      X0 = +_[0][0], X1 = +_[1][0];
      Y0 = +_[0][1], Y1 = +_[1][1];
      if (X0 > X1) _ = X0, X0 = X1, X1 = _;
      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
      return graticule.precision(precision);
    };
    graticule.minorExtent = function(_) {
      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];
      x0 = +_[0][0], x1 = +_[1][0];
      y0 = +_[0][1], y1 = +_[1][1];
      if (x0 > x1) _ = x0, x0 = x1, x1 = _;
      if (y0 > y1) _ = y0, y0 = y1, y1 = _;
      return graticule.precision(precision);
    };
    graticule.step = function(_) {
      if (!arguments.length) return graticule.minorStep();
      return graticule.majorStep(_).minorStep(_);
    };
    graticule.majorStep = function(_) {
      if (!arguments.length) return [ DX, DY ];
      DX = +_[0], DY = +_[1];
      return graticule;
    };
    graticule.minorStep = function(_) {
      if (!arguments.length) return [ dx, dy ];
      dx = +_[0], dy = +_[1];
      return graticule;
    };
    graticule.precision = function(_) {
      if (!arguments.length) return precision;
      precision = +_;
      x = d3_geo_graticuleX(y0, y1, 90);
      y = d3_geo_graticuleY(x0, x1, precision);
      X = d3_geo_graticuleX(Y0, Y1, 90);
      Y = d3_geo_graticuleY(X0, X1, precision);
      return graticule;
    };
    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);
  };
  function d3_geo_graticuleX(y0, y1, dy) {
    var y = d3.range(y0, y1 - ε, dy).concat(y1);
    return function(x) {
      return y.map(function(y) {
        return [ x, y ];
      });
    };
  }
  function d3_geo_graticuleY(x0, x1, dx) {
    var x = d3.range(x0, x1 - ε, dx).concat(x1);
    return function(y) {
      return x.map(function(x) {
        return [ x, y ];
      });
    };
  }
  function d3_source(d) {
    return d.source;
  }
  function d3_target(d) {
    return d.target;
  }
  d3.geo.greatArc = function() {
    var source = d3_source, source_, target = d3_target, target_;
    function greatArc() {
      return {
        type: "LineString",
        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]
      };
    }
    greatArc.distance = function() {
      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));
    };
    greatArc.source = function(_) {
      if (!arguments.length) return source;
      source = _, source_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.target = function(_) {
      if (!arguments.length) return target;
      target = _, target_ = typeof _ === "function" ? null : _;
      return greatArc;
    };
    greatArc.precision = function() {
      return arguments.length ? greatArc : 0;
    };
    return greatArc;
  };
  d3.geo.interpolate = function(source, target) {
    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);
  };
  function d3_geo_interpolate(x0, y0, x1, y1) {
    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);
    var interpolate = d ? function(t) {
      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;
      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];
    } : function() {
      return [ x0 * d3_degrees, y0 * d3_degrees ];
    };
    interpolate.distance = d;
    return interpolate;
  }
  d3.geo.length = function(object) {
    d3_geo_lengthSum = 0;
    d3.geo.stream(object, d3_geo_length);
    return d3_geo_lengthSum;
  };
  var d3_geo_lengthSum;
  var d3_geo_length = {
    sphere: d3_noop,
    point: d3_noop,
    lineStart: d3_geo_lengthLineStart,
    lineEnd: d3_noop,
    polygonStart: d3_noop,
    polygonEnd: d3_noop
  };
  function d3_geo_lengthLineStart() {
    var λ0, sinφ0, cosφ0;
    d3_geo_length.point = function(λ, φ) {
      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);
      d3_geo_length.point = nextPoint;
    };
    d3_geo_length.lineEnd = function() {
      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;
    };
    function nextPoint(λ, φ) {
      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);
      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);
      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;
    }
  }
  function d3_geo_azimuthal(scale, angle) {
    function azimuthal(λ, φ) {
      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);
      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];
    }
    azimuthal.invert = function(x, y) {
      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);
      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];
    };
    return azimuthal;
  }
  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {
    return Math.sqrt(2 / (1 + cosλcosφ));
  }, function(ρ) {
    return 2 * Math.asin(ρ / 2);
  });
  (d3.geo.azimuthalEqualArea = function() {
    return d3_geo_projection(d3_geo_azimuthalEqualArea);
  }).raw = d3_geo_azimuthalEqualArea;
  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {
    var c = Math.acos(cosλcosφ);
    return c && c / Math.sin(c);
  }, d3_identity);
  (d3.geo.azimuthalEquidistant = function() {
    return d3_geo_projection(d3_geo_azimuthalEquidistant);
  }).raw = d3_geo_azimuthalEquidistant;
  function d3_geo_conicConformal(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), t = function(φ) {
      return Math.tan(π / 4 + φ / 2);
    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;
    if (!n) return d3_geo_mercator;
    function forward(λ, φ) {
      if (F > 0) {
        if (φ < -halfπ + ε) φ = -halfπ + ε;
      } else {
        if (φ > halfπ - ε) φ = halfπ - ε;
      }
      var ρ = F / Math.pow(t(φ), n);
      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);
      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];
    };
    return forward;
  }
  (d3.geo.conicConformal = function() {
    return d3_geo_conic(d3_geo_conicConformal);
  }).raw = d3_geo_conicConformal;
  function d3_geo_conicEquidistant(φ0, φ1) {
    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;
    if (abs(n) < ε) return d3_geo_equirectangular;
    function forward(λ, φ) {
      var ρ = G - φ;
      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];
    }
    forward.invert = function(x, y) {
      var ρ0_y = G - y;
      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];
    };
    return forward;
  }
  (d3.geo.conicEquidistant = function() {
    return d3_geo_conic(d3_geo_conicEquidistant);
  }).raw = d3_geo_conicEquidistant;
  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / cosλcosφ;
  }, Math.atan);
  (d3.geo.gnomonic = function() {
    return d3_geo_projection(d3_geo_gnomonic);
  }).raw = d3_geo_gnomonic;
  function d3_geo_mercator(λ, φ) {
    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];
  }
  d3_geo_mercator.invert = function(x, y) {
    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];
  };
  function d3_geo_mercatorProjection(project) {
    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;
    m.scale = function() {
      var v = scale.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.translate = function() {
      var v = translate.apply(m, arguments);
      return v === m ? clipAuto ? m.clipExtent(null) : m : v;
    };
    m.clipExtent = function(_) {
      var v = clipExtent.apply(m, arguments);
      if (v === m) {
        if (clipAuto = _ == null) {
          var k = π * scale(), t = translate();
          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);
        }
      } else if (clipAuto) {
        v = null;
      }
      return v;
    };
    return m.clipExtent(null);
  }
  (d3.geo.mercator = function() {
    return d3_geo_mercatorProjection(d3_geo_mercator);
  }).raw = d3_geo_mercator;
  var d3_geo_orthographic = d3_geo_azimuthal(function() {
    return 1;
  }, Math.asin);
  (d3.geo.orthographic = function() {
    return d3_geo_projection(d3_geo_orthographic);
  }).raw = d3_geo_orthographic;
  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {
    return 1 / (1 + cosλcosφ);
  }, function(ρ) {
    return 2 * Math.atan(ρ);
  });
  (d3.geo.stereographic = function() {
    return d3_geo_projection(d3_geo_stereographic);
  }).raw = d3_geo_stereographic;
  function d3_geo_transverseMercator(λ, φ) {
    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];
  }
  d3_geo_transverseMercator.invert = function(x, y) {
    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];
  };
  (d3.geo.transverseMercator = function() {
    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;
    projection.center = function(_) {
      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);
    };
    projection.rotate = function(_) {
      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), 
      [ _[0], _[1], _[2] - 90 ]);
    };
    return rotate([ 0, 0, 90 ]);
  }).raw = d3_geo_transverseMercator;
  d3.geom = {};
  function d3_geom_pointX(d) {
    return d[0];
  }
  function d3_geom_pointY(d) {
    return d[1];
  }
  d3.geom.hull = function(vertices) {
    var x = d3_geom_pointX, y = d3_geom_pointY;
    if (arguments.length) return hull(vertices);
    function hull(data) {
      if (data.length < 3) return [];
      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];
      for (i = 0; i < n; i++) {
        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);
      }
      points.sort(d3_geom_hullOrder);
      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);
      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);
      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];
      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);
      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);
      return polygon;
    }
    hull.x = function(_) {
      return arguments.length ? (x = _, hull) : x;
    };
    hull.y = function(_) {
      return arguments.length ? (y = _, hull) : y;
    };
    return hull;
  };
  function d3_geom_hullUpper(points) {
    var n = points.length, hull = [ 0, 1 ], hs = 2;
    for (var i = 2; i < n; i++) {
      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;
      hull[hs++] = i;
    }
    return hull.slice(0, hs);
  }
  function d3_geom_hullOrder(a, b) {
    return a[0] - b[0] || a[1] - b[1];
  }
  d3.geom.polygon = function(coordinates) {
    d3_subclass(coordinates, d3_geom_polygonPrototype);
    return coordinates;
  };
  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];
  d3_geom_polygonPrototype.area = function() {
    var i = -1, n = this.length, a, b = this[n - 1], area = 0;
    while (++i < n) {
      a = b;
      b = this[i];
      area += a[1] * b[0] - a[0] * b[1];
    }
    return area * .5;
  };
  d3_geom_polygonPrototype.centroid = function(k) {
    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;
    if (!arguments.length) k = -1 / (6 * this.area());
    while (++i < n) {
      a = b;
      b = this[i];
      c = a[0] * b[1] - b[0] * a[1];
      x += (a[0] + b[0]) * c;
      y += (a[1] + b[1]) * c;
    }
    return [ x * k, y * k ];
  };
  d3_geom_polygonPrototype.clip = function(subject) {
    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;
    while (++i < n) {
      input = subject.slice();
      subject.length = 0;
      b = this[i];
      c = input[(m = input.length - closed) - 1];
      j = -1;
      while (++j < m) {
        d = input[j];
        if (d3_geom_polygonInside(d, a, b)) {
          if (!d3_geom_polygonInside(c, a, b)) {
            subject.push(d3_geom_polygonIntersect(c, d, a, b));
          }
          subject.push(d);
        } else if (d3_geom_polygonInside(c, a, b)) {
          subject.push(d3_geom_polygonIntersect(c, d, a, b));
        }
        c = d;
      }
      if (closed) subject.push(subject[0]);
      a = b;
    }
    return subject;
  };
  function d3_geom_polygonInside(p, a, b) {
    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);
  }
  function d3_geom_polygonIntersect(c, d, a, b) {
    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);
    return [ x1 + ua * x21, y1 + ua * y21 ];
  }
  function d3_geom_polygonClosed(coordinates) {
    var a = coordinates[0], b = coordinates[coordinates.length - 1];
    return !(a[0] - b[0] || a[1] - b[1]);
  }
  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];
  function d3_geom_voronoiBeach() {
    d3_geom_voronoiRedBlackNode(this);
    this.edge = this.site = this.circle = null;
  }
  function d3_geom_voronoiCreateBeach(site) {
    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();
    beach.site = site;
    return beach;
  }
  function d3_geom_voronoiDetachBeach(beach) {
    d3_geom_voronoiDetachCircle(beach);
    d3_geom_voronoiBeaches.remove(beach);
    d3_geom_voronoiBeachPool.push(beach);
    d3_geom_voronoiRedBlackNode(beach);
  }
  function d3_geom_voronoiRemoveBeach(beach) {
    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {
      x: x,
      y: y
    }, previous = beach.P, next = beach.N, disappearing = [ beach ];
    d3_geom_voronoiDetachBeach(beach);
    var lArc = previous;
    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {
      previous = lArc.P;
      disappearing.unshift(lArc);
      d3_geom_voronoiDetachBeach(lArc);
      lArc = previous;
    }
    disappearing.unshift(lArc);
    d3_geom_voronoiDetachCircle(lArc);
    var rArc = next;
    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {
      next = rArc.N;
      disappearing.push(rArc);
      d3_geom_voronoiDetachBeach(rArc);
      rArc = next;
    }
    disappearing.push(rArc);
    d3_geom_voronoiDetachCircle(rArc);
    var nArcs = disappearing.length, iArc;
    for (iArc = 1; iArc < nArcs; ++iArc) {
      rArc = disappearing[iArc];
      lArc = disappearing[iArc - 1];
      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
    }
    lArc = disappearing[0];
    rArc = disappearing[nArcs - 1];
    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiAddBeach(site) {
    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;
    while (node) {
      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;
      if (dxl > ε) node = node.L; else {
        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);
        if (dxr > ε) {
          if (!node.R) {
            lArc = node;
            break;
          }
          node = node.R;
        } else {
          if (dxl > -ε) {
            lArc = node.P;
            rArc = node;
          } else if (dxr > -ε) {
            lArc = node;
            rArc = node.N;
          } else {
            lArc = rArc = node;
          }
          break;
        }
      }
    }
    var newArc = d3_geom_voronoiCreateBeach(site);
    d3_geom_voronoiBeaches.insert(lArc, newArc);
    if (!lArc && !rArc) return;
    if (lArc === rArc) {
      d3_geom_voronoiDetachCircle(lArc);
      rArc = d3_geom_voronoiCreateBeach(lArc.site);
      d3_geom_voronoiBeaches.insert(newArc, rArc);
      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      d3_geom_voronoiAttachCircle(lArc);
      d3_geom_voronoiAttachCircle(rArc);
      return;
    }
    if (!rArc) {
      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);
      return;
    }
    d3_geom_voronoiDetachCircle(lArc);
    d3_geom_voronoiDetachCircle(rArc);
    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {
      x: (cy * hb - by * hc) / d + ax,
      y: (bx * hc - cx * hb) / d + ay
    };
    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);
    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);
    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);
    d3_geom_voronoiAttachCircle(lArc);
    d3_geom_voronoiAttachCircle(rArc);
  }
  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {
    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;
    if (!pby2) return rfocx;
    var lArc = arc.P;
    if (!lArc) return -Infinity;
    site = lArc.site;
    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;
    if (!plby2) return lfocx;
    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
    return (rfocx + lfocx) / 2;
  }
  function d3_geom_voronoiRightBreakPoint(arc, directrix) {
    var rArc = arc.N;
    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);
    var site = arc.site;
    return site.y === directrix ? site.x : Infinity;
  }
  function d3_geom_voronoiCell(site) {
    this.site = site;
    this.edges = [];
  }
  d3_geom_voronoiCell.prototype.prepare = function() {
    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;
    while (iHalfEdge--) {
      edge = halfEdges[iHalfEdge].edge;
      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);
    }
    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);
    return halfEdges.length;
  };
  function d3_geom_voronoiCloseCells(extent) {
    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;
    while (iCell--) {
      cell = cells[iCell];
      if (!cell || !cell.prepare()) continue;
      halfEdges = cell.edges;
      nHalfEdges = halfEdges.length;
      iHalfEdge = 0;
      while (iHalfEdge < nHalfEdges) {
        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;
        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;
        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {
          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {
            x: x0,
            y: abs(x2 - x0) < ε ? y2 : y1
          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {
            x: abs(y2 - y1) < ε ? x2 : x1,
            y: y1
          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {
            x: x1,
            y: abs(x2 - x1) < ε ? y2 : y0
          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {
            x: abs(y2 - y0) < ε ? x2 : x0,
            y: y0
          } : null), cell.site, null));
          ++nHalfEdges;
        }
      }
    }
  }
  function d3_geom_voronoiHalfEdgeOrder(a, b) {
    return b.angle - a.angle;
  }
  function d3_geom_voronoiCircle() {
    d3_geom_voronoiRedBlackNode(this);
    this.x = this.y = this.arc = this.site = this.cy = null;
  }
  function d3_geom_voronoiAttachCircle(arc) {
    var lArc = arc.P, rArc = arc.N;
    if (!lArc || !rArc) return;
    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;
    if (lSite === rSite) return;
    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;
    var d = 2 * (ax * cy - ay * cx);
    if (d >= -ε2) return;
    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;
    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();
    circle.arc = arc;
    circle.site = cSite;
    circle.x = x + bx;
    circle.y = cy + Math.sqrt(x * x + y * y);
    circle.cy = cy;
    arc.circle = circle;
    var before = null, node = d3_geom_voronoiCircles._;
    while (node) {
      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
        if (node.L) node = node.L; else {
          before = node.P;
          break;
        }
      } else {
        if (node.R) node = node.R; else {
          before = node;
          break;
        }
      }
    }
    d3_geom_voronoiCircles.insert(before, circle);
    if (!before) d3_geom_voronoiFirstCircle = circle;
  }
  function d3_geom_voronoiDetachCircle(arc) {
    var circle = arc.circle;
    if (circle) {
      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;
      d3_geom_voronoiCircles.remove(circle);
      d3_geom_voronoiCirclePool.push(circle);
      d3_geom_voronoiRedBlackNode(circle);
      arc.circle = null;
    }
  }
  function d3_geom_voronoiClipEdges(extent) {
    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;
    while (i--) {
      e = edges[i];
      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {
        e.a = e.b = null;
        edges.splice(i, 1);
      }
    }
  }
  function d3_geom_voronoiConnectEdge(edge, extent) {
    var vb = edge.b;
    if (vb) return true;
    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
    if (ry === ly) {
      if (fx < x0 || fx >= x1) return;
      if (lx > rx) {
        if (!va) va = {
          x: fx,
          y: y0
        }; else if (va.y >= y1) return;
        vb = {
          x: fx,
          y: y1
        };
      } else {
        if (!va) va = {
          x: fx,
          y: y1
        }; else if (va.y < y0) return;
        vb = {
          x: fx,
          y: y0
        };
      }
    } else {
      fm = (lx - rx) / (ry - ly);
      fb = fy - fm * fx;
      if (fm < -1 || fm > 1) {
        if (lx > rx) {
          if (!va) va = {
            x: (y0 - fb) / fm,
            y: y0
          }; else if (va.y >= y1) return;
          vb = {
            x: (y1 - fb) / fm,
            y: y1
          };
        } else {
          if (!va) va = {
            x: (y1 - fb) / fm,
            y: y1
          }; else if (va.y < y0) return;
          vb = {
            x: (y0 - fb) / fm,
            y: y0
          };
        }
      } else {
        if (ly < ry) {
          if (!va) va = {
            x: x0,
            y: fm * x0 + fb
          }; else if (va.x >= x1) return;
          vb = {
            x: x1,
            y: fm * x1 + fb
          };
        } else {
          if (!va) va = {
            x: x1,
            y: fm * x1 + fb
          }; else if (va.x < x0) return;
          vb = {
            x: x0,
            y: fm * x0 + fb
          };
        }
      }
    }
    edge.a = va;
    edge.b = vb;
    return true;
  }
  function d3_geom_voronoiEdge(lSite, rSite) {
    this.l = lSite;
    this.r = rSite;
    this.a = this.b = null;
  }
  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, rSite);
    d3_geom_voronoiEdges.push(edge);
    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);
    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);
    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));
    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));
    return edge;
  }
  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {
    var edge = new d3_geom_voronoiEdge(lSite, null);
    edge.a = va;
    edge.b = vb;
    d3_geom_voronoiEdges.push(edge);
    return edge;
  }
  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {
    if (!edge.a && !edge.b) {
      edge.a = vertex;
      edge.l = lSite;
      edge.r = rSite;
    } else if (edge.l === rSite) {
      edge.b = vertex;
    } else {
      edge.a = vertex;
    }
  }
  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {
    var va = edge.a, vb = edge.b;
    this.edge = edge;
    this.site = lSite;
    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);
  }
  d3_geom_voronoiHalfEdge.prototype = {
    start: function() {
      return this.edge.l === this.site ? this.edge.a : this.edge.b;
    },
    end: function() {
      return this.edge.l === this.site ? this.edge.b : this.edge.a;
    }
  };
  function d3_geom_voronoiRedBlackTree() {
    this._ = null;
  }
  function d3_geom_voronoiRedBlackNode(node) {
    node.U = node.C = node.L = node.R = node.P = node.N = null;
  }
  d3_geom_voronoiRedBlackTree.prototype = {
    insert: function(after, node) {
      var parent, grandpa, uncle;
      if (after) {
        node.P = after;
        node.N = after.N;
        if (after.N) after.N.P = node;
        after.N = node;
        if (after.R) {
          after = after.R;
          while (after.L) after = after.L;
          after.L = node;
        } else {
          after.R = node;
        }
        parent = after;
      } else if (this._) {
        after = d3_geom_voronoiRedBlackFirst(this._);
        node.P = null;
        node.N = after;
        after.P = after.L = node;
        parent = after;
      } else {
        node.P = node.N = null;
        this._ = node;
        parent = null;
      }
      node.L = node.R = null;
      node.U = parent;
      node.C = true;
      after = node;
      while (parent && parent.C) {
        grandpa = parent.U;
        if (parent === grandpa.L) {
          uncle = grandpa.R;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.R) {
              d3_geom_voronoiRedBlackRotateLeft(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, grandpa);
          }
        } else {
          uncle = grandpa.L;
          if (uncle && uncle.C) {
            parent.C = uncle.C = false;
            grandpa.C = true;
            after = grandpa;
          } else {
            if (after === parent.L) {
              d3_geom_voronoiRedBlackRotateRight(this, parent);
              after = parent;
              parent = after.U;
            }
            parent.C = false;
            grandpa.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);
          }
        }
        parent = after.U;
      }
      this._.C = false;
    },
    remove: function(node) {
      if (node.N) node.N.P = node.P;
      if (node.P) node.P.N = node.N;
      node.N = node.P = null;
      var parent = node.U, sibling, left = node.L, right = node.R, next, red;
      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);
      if (parent) {
        if (parent.L === node) parent.L = next; else parent.R = next;
      } else {
        this._ = next;
      }
      if (left && right) {
        red = next.C;
        next.C = node.C;
        next.L = left;
        left.U = next;
        if (next !== right) {
          parent = next.U;
          next.U = node.U;
          node = next.R;
          parent.L = node;
          next.R = right;
          right.U = next;
        } else {
          next.U = parent;
          parent = next;
          node = next.R;
        }
      } else {
        red = node.C;
        node = next;
      }
      if (node) node.U = parent;
      if (red) return;
      if (node && node.C) {
        node.C = false;
        return;
      }
      do {
        if (node === this._) break;
        if (node === parent.L) {
          sibling = parent.R;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            sibling = parent.R;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.R || !sibling.R.C) {
              sibling.L.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateRight(this, sibling);
              sibling = parent.R;
            }
            sibling.C = parent.C;
            parent.C = sibling.R.C = false;
            d3_geom_voronoiRedBlackRotateLeft(this, parent);
            node = this._;
            break;
          }
        } else {
          sibling = parent.L;
          if (sibling.C) {
            sibling.C = false;
            parent.C = true;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            sibling = parent.L;
          }
          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
            if (!sibling.L || !sibling.L.C) {
              sibling.R.C = false;
              sibling.C = true;
              d3_geom_voronoiRedBlackRotateLeft(this, sibling);
              sibling = parent.L;
            }
            sibling.C = parent.C;
            parent.C = sibling.L.C = false;
            d3_geom_voronoiRedBlackRotateRight(this, parent);
            node = this._;
            break;
          }
        }
        sibling.C = true;
        node = parent;
        parent = parent.U;
      } while (!node.C);
      if (node) node.C = false;
    }
  };
  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {
    var p = node, q = node.R, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.R = q.L;
    if (p.R) p.R.U = p;
    q.L = p;
  }
  function d3_geom_voronoiRedBlackRotateRight(tree, node) {
    var p = node, q = node.L, parent = p.U;
    if (parent) {
      if (parent.L === p) parent.L = q; else parent.R = q;
    } else {
      tree._ = q;
    }
    q.U = parent;
    p.U = q;
    p.L = q.R;
    if (p.L) p.L.U = p;
    q.R = p;
  }
  function d3_geom_voronoiRedBlackFirst(node) {
    while (node.L) node = node.L;
    return node;
  }
  function d3_geom_voronoi(sites, bbox) {
    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;
    d3_geom_voronoiEdges = [];
    d3_geom_voronoiCells = new Array(sites.length);
    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();
    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();
    while (true) {
      circle = d3_geom_voronoiFirstCircle;
      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {
        if (site.x !== x0 || site.y !== y0) {
          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);
          d3_geom_voronoiAddBeach(site);
          x0 = site.x, y0 = site.y;
        }
        site = sites.pop();
      } else if (circle) {
        d3_geom_voronoiRemoveBeach(circle.arc);
      } else {
        break;
      }
    }
    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);
    var diagram = {
      cells: d3_geom_voronoiCells,
      edges: d3_geom_voronoiEdges
    };
    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;
    return diagram;
  }
  function d3_geom_voronoiVertexOrder(a, b) {
    return b.y - a.y || b.x - a.x;
  }
  d3.geom.voronoi = function(points) {
    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;
    if (points) return voronoi(points);
    function voronoi(data) {
      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];
      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {
        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {
          var s = e.start();
          return [ s.x, s.y ];
        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];
        polygon.point = data[i];
      });
      return polygons;
    }
    function sites(data) {
      return data.map(function(d, i) {
        return {
          x: Math.round(fx(d, i) / ε) * ε,
          y: Math.round(fy(d, i) / ε) * ε,
          i: i
        };
      });
    }
    voronoi.links = function(data) {
      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {
        return edge.l && edge.r;
      }).map(function(edge) {
        return {
          source: data[edge.l.i],
          target: data[edge.r.i]
        };
      });
    };
    voronoi.triangles = function(data) {
      var triangles = [];
      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {
        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;
        while (++j < m) {
          e0 = e1;
          s0 = s1;
          e1 = edges[j].edge;
          s1 = e1.l === site ? e1.r : e1.l;
          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {
            triangles.push([ data[i], data[s0.i], data[s1.i] ]);
          }
        }
      });
      return triangles;
    };
    voronoi.x = function(_) {
      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;
    };
    voronoi.y = function(_) {
      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;
    };
    voronoi.clipExtent = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;
      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;
      return voronoi;
    };
    voronoi.size = function(_) {
      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];
      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);
    };
    return voronoi;
  };
  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];
  function d3_geom_voronoiTriangleArea(a, b, c) {
    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);
  }
  d3.geom.delaunay = function(vertices) {
    return d3.geom.voronoi().triangles(vertices);
  };
  d3.geom.quadtree = function(points, x1, y1, x2, y2) {
    var x = d3_geom_pointX, y = d3_geom_pointY, compat;
    if (compat = arguments.length) {
      x = d3_geom_quadtreeCompatX;
      y = d3_geom_quadtreeCompatY;
      if (compat === 3) {
        y2 = y1;
        x2 = x1;
        y1 = x1 = 0;
      }
      return quadtree(points);
    }
    function quadtree(data) {
      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;
      if (x1 != null) {
        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;
      } else {
        x2_ = y2_ = -(x1_ = y1_ = Infinity);
        xs = [], ys = [];
        n = data.length;
        if (compat) for (i = 0; i < n; ++i) {
          d = data[i];
          if (d.x < x1_) x1_ = d.x;
          if (d.y < y1_) y1_ = d.y;
          if (d.x > x2_) x2_ = d.x;
          if (d.y > y2_) y2_ = d.y;
          xs.push(d.x);
          ys.push(d.y);
        } else for (i = 0; i < n; ++i) {
          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);
          if (x_ < x1_) x1_ = x_;
          if (y_ < y1_) y1_ = y_;
          if (x_ > x2_) x2_ = x_;
          if (y_ > y2_) y2_ = y_;
          xs.push(x_);
          ys.push(y_);
        }
      }
      var dx = x2_ - x1_, dy = y2_ - y1_;
      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;
      function insert(n, d, x, y, x1, y1, x2, y2) {
        if (isNaN(x) || isNaN(y)) return;
        if (n.leaf) {
          var nx = n.x, ny = n.y;
          if (nx != null) {
            if (abs(nx - x) + abs(ny - y) < .01) {
              insertChild(n, d, x, y, x1, y1, x2, y2);
            } else {
              var nPoint = n.point;
              n.x = n.y = n.point = null;
              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);
              insertChild(n, d, x, y, x1, y1, x2, y2);
            }
          } else {
            n.x = x, n.y = y, n.point = d;
          }
        } else {
          insertChild(n, d, x, y, x1, y1, x2, y2);
        }
      }
      function insertChild(n, d, x, y, x1, y1, x2, y2) {
        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;
        n.leaf = false;
        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());
        if (right) x1 = xm; else x2 = xm;
        if (below) y1 = ym; else y2 = ym;
        insert(n, d, x, y, x1, y1, x2, y2);
      }
      var root = d3_geom_quadtreeNode();
      root.add = function(d) {
        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);
      };
      root.visit = function(f) {
        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);
      };
      root.find = function(point) {
        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);
      };
      i = -1;
      if (x1 == null) {
        while (++i < n) {
          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);
        }
        --i;
      } else data.forEach(root.add);
      xs = ys = data = d = null;
      return root;
    }
    quadtree.x = function(_) {
      return arguments.length ? (x = _, quadtree) : x;
    };
    quadtree.y = function(_) {
      return arguments.length ? (y = _, quadtree) : y;
    };
    quadtree.extent = function(_) {
      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], 
      y2 = +_[1][1];
      return quadtree;
    };
    quadtree.size = function(_) {
      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];
      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];
      return quadtree;
    };
    return quadtree;
  };
  function d3_geom_quadtreeCompatX(d) {
    return d.x;
  }
  function d3_geom_quadtreeCompatY(d) {
    return d.y;
  }
  function d3_geom_quadtreeNode() {
    return {
      leaf: true,
      nodes: [],
      point: null,
      x: null,
      y: null
    };
  }
  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {
    if (!f(node, x1, y1, x2, y2)) {
      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;
      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);
      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);
      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);
      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);
    }
  }
  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {
    var minDistance2 = Infinity, closestPoint;
    (function find(node, x1, y1, x2, y2) {
      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;
      if (point = node.point) {
        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;
        if (distance2 < minDistance2) {
          var distance = Math.sqrt(minDistance2 = distance2);
          x0 = x - distance, y0 = y - distance;
          x3 = x + distance, y3 = y + distance;
          closestPoint = point;
        }
      }
      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;
      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {
        if (node = children[i & 3]) switch (i & 3) {
         case 0:
          find(node, x1, y1, xm, ym);
          break;

         case 1:
          find(node, xm, y1, x2, ym);
          break;

         case 2:
          find(node, x1, ym, xm, y2);
          break;

         case 3:
          find(node, xm, ym, x2, y2);
          break;
        }
      }
    })(root, x0, y0, x3, y3);
    return closestPoint;
  }
  d3.interpolateRgb = d3_interpolateRgb;
  function d3_interpolateRgb(a, b) {
    a = d3.rgb(a);
    b = d3.rgb(b);
    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;
    return function(t) {
      return "#" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));
    };
  }
  d3.interpolateObject = d3_interpolateObject;
  function d3_interpolateObject(a, b) {
    var i = {}, c = {}, k;
    for (k in a) {
      if (k in b) {
        i[k] = d3_interpolate(a[k], b[k]);
      } else {
        c[k] = a[k];
      }
    }
    for (k in b) {
      if (!(k in a)) {
        c[k] = b[k];
      }
    }
    return function(t) {
      for (k in i) c[k] = i[k](t);
      return c;
    };
  }
  d3.interpolateNumber = d3_interpolateNumber;
  function d3_interpolateNumber(a, b) {
    a = +a, b = +b;
    return function(t) {
      return a * (1 - t) + b * t;
    };
  }
  d3.interpolateString = d3_interpolateString;
  function d3_interpolateString(a, b) {
    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
    a = a + "", b = b + "";
    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {
      if ((bs = bm.index) > bi) {
        bs = b.slice(bi, bs);
        if (s[i]) s[i] += bs; else s[++i] = bs;
      }
      if ((am = am[0]) === (bm = bm[0])) {
        if (s[i]) s[i] += bm; else s[++i] = bm;
      } else {
        s[++i] = null;
        q.push({
          i: i,
          x: d3_interpolateNumber(am, bm)
        });
      }
      bi = d3_interpolate_numberB.lastIndex;
    }
    if (bi < b.length) {
      bs = b.slice(bi);
      if (s[i]) s[i] += bs; else s[++i] = bs;
    }
    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {
      return b(t) + "";
    }) : function() {
      return b;
    } : (b = q.length, function(t) {
      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    });
  }
  var d3_interpolate_numberA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, "g");
  d3.interpolate = d3_interpolate;
  function d3_interpolate(a, b) {
    var i = d3.interpolators.length, f;
    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;
    return f;
  }
  d3.interpolators = [ function(a, b) {
    var t = typeof b;
    return (t === "string" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\(|hsl\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === "object" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);
  } ];
  d3.interpolateArray = d3_interpolateArray;
  function d3_interpolateArray(a, b) {
    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;
    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));
    for (;i < na; ++i) c[i] = a[i];
    for (;i < nb; ++i) c[i] = b[i];
    return function(t) {
      for (i = 0; i < n0; ++i) c[i] = x[i](t);
      return c;
    };
  }
  var d3_ease_default = function() {
    return d3_identity;
  };
  var d3_ease = d3.map({
    linear: d3_ease_default,
    poly: d3_ease_poly,
    quad: function() {
      return d3_ease_quad;
    },
    cubic: function() {
      return d3_ease_cubic;
    },
    sin: function() {
      return d3_ease_sin;
    },
    exp: function() {
      return d3_ease_exp;
    },
    circle: function() {
      return d3_ease_circle;
    },
    elastic: d3_ease_elastic,
    back: d3_ease_back,
    bounce: function() {
      return d3_ease_bounce;
    }
  });
  var d3_ease_mode = d3.map({
    "in": d3_identity,
    out: d3_ease_reverse,
    "in-out": d3_ease_reflect,
    "out-in": function(f) {
      return d3_ease_reflect(d3_ease_reverse(f));
    }
  });
  d3.ease = function(name) {
    var i = name.indexOf("-"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : "in";
    t = d3_ease.get(t) || d3_ease_default;
    m = d3_ease_mode.get(m) || d3_identity;
    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));
  };
  function d3_ease_clamp(f) {
    return function(t) {
      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);
    };
  }
  function d3_ease_reverse(f) {
    return function(t) {
      return 1 - f(1 - t);
    };
  }
  function d3_ease_reflect(f) {
    return function(t) {
      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));
    };
  }
  function d3_ease_quad(t) {
    return t * t;
  }
  function d3_ease_cubic(t) {
    return t * t * t;
  }
  function d3_ease_cubicInOut(t) {
    if (t <= 0) return 0;
    if (t >= 1) return 1;
    var t2 = t * t, t3 = t2 * t;
    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);
  }
  function d3_ease_poly(e) {
    return function(t) {
      return Math.pow(t, e);
    };
  }
  function d3_ease_sin(t) {
    return 1 - Math.cos(t * halfπ);
  }
  function d3_ease_exp(t) {
    return Math.pow(2, 10 * (t - 1));
  }
  function d3_ease_circle(t) {
    return 1 - Math.sqrt(1 - t * t);
  }
  function d3_ease_elastic(a, p) {
    var s;
    if (arguments.length < 2) p = .45;
    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;
    return function(t) {
      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);
    };
  }
  function d3_ease_back(s) {
    if (!s) s = 1.70158;
    return function(t) {
      return t * t * ((s + 1) * t - s);
    };
  }
  function d3_ease_bounce(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  d3.interpolateHcl = d3_interpolateHcl;
  function d3_interpolateHcl(a, b) {
    a = d3.hcl(a);
    b = d3.hcl(b);
    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;
    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + "";
    };
  }
  d3.interpolateHsl = d3_interpolateHsl;
  function d3_interpolateHsl(a, b) {
    a = d3.hsl(a);
    b = d3.hsl(b);
    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;
    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;
    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;
    return function(t) {
      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + "";
    };
  }
  d3.interpolateLab = d3_interpolateLab;
  function d3_interpolateLab(a, b) {
    a = d3.lab(a);
    b = d3.lab(b);
    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;
    return function(t) {
      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + "";
    };
  }
  d3.interpolateRound = d3_interpolateRound;
  function d3_interpolateRound(a, b) {
    b -= a;
    return function(t) {
      return Math.round(a + b * t);
    };
  }
  d3.transform = function(string) {
    var g = d3_document.createElementNS(d3.ns.prefix.svg, "g");
    return (d3.transform = function(string) {
      if (string != null) {
        g.setAttribute("transform", string);
        var t = g.transform.baseVal.consolidate();
      }
      return new d3_transform(t ? t.matrix : d3_transformIdentity);
    })(string);
  };
  function d3_transform(m) {
    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;
    if (r0[0] * r1[1] < r1[0] * r0[1]) {
      r0[0] *= -1;
      r0[1] *= -1;
      kx *= -1;
      kz *= -1;
    }
    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;
    this.translate = [ m.e, m.f ];
    this.scale = [ kx, ky ];
    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;
  }
  d3_transform.prototype.toString = function() {
    return "translate(" + this.translate + ")rotate(" + this.rotate + ")skewX(" + this.skew + ")scale(" + this.scale + ")";
  };
  function d3_transformDot(a, b) {
    return a[0] * b[0] + a[1] * b[1];
  }
  function d3_transformNormalize(a) {
    var k = Math.sqrt(d3_transformDot(a, a));
    if (k) {
      a[0] /= k;
      a[1] /= k;
    }
    return k;
  }
  function d3_transformCombine(a, b, k) {
    a[0] += k * b[0];
    a[1] += k * b[1];
    return a;
  }
  var d3_transformIdentity = {
    a: 1,
    b: 0,
    c: 0,
    d: 1,
    e: 0,
    f: 0
  };
  d3.interpolateTransform = d3_interpolateTransform;
  function d3_interpolateTransformPop(s) {
    return s.length ? s.pop() + "," : "";
  }
  function d3_interpolateTranslate(ta, tb, s, q) {
    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {
      var i = s.push("translate(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ta[0], tb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ta[1], tb[1])
      });
    } else if (tb[0] || tb[1]) {
      s.push("translate(" + tb + ")");
    }
  }
  function d3_interpolateRotate(ra, rb, s, q) {
    if (ra !== rb) {
      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "rotate(", null, ")") - 2,
        x: d3_interpolateNumber(ra, rb)
      });
    } else if (rb) {
      s.push(d3_interpolateTransformPop(s) + "rotate(" + rb + ")");
    }
  }
  function d3_interpolateSkew(wa, wb, s, q) {
    if (wa !== wb) {
      q.push({
        i: s.push(d3_interpolateTransformPop(s) + "skewX(", null, ")") - 2,
        x: d3_interpolateNumber(wa, wb)
      });
    } else if (wb) {
      s.push(d3_interpolateTransformPop(s) + "skewX(" + wb + ")");
    }
  }
  function d3_interpolateScale(ka, kb, s, q) {
    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {
      var i = s.push(d3_interpolateTransformPop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: d3_interpolateNumber(ka[0], kb[0])
      }, {
        i: i - 2,
        x: d3_interpolateNumber(ka[1], kb[1])
      });
    } else if (kb[0] !== 1 || kb[1] !== 1) {
      s.push(d3_interpolateTransformPop(s) + "scale(" + kb + ")");
    }
  }
  function d3_interpolateTransform(a, b) {
    var s = [], q = [];
    a = d3.transform(a), b = d3.transform(b);
    d3_interpolateTranslate(a.translate, b.translate, s, q);
    d3_interpolateRotate(a.rotate, b.rotate, s, q);
    d3_interpolateSkew(a.skew, b.skew, s, q);
    d3_interpolateScale(a.scale, b.scale, s, q);
    a = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  }
  function d3_uninterpolateNumber(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return (x - a) / b;
    };
  }
  function d3_uninterpolateClamp(a, b) {
    b = (b -= a = +a) || 1 / b;
    return function(x) {
      return Math.max(0, Math.min(1, (x - a) / b));
    };
  }
  d3.layout = {};
  d3.layout.bundle = function() {
    return function(links) {
      var paths = [], i = -1, n = links.length;
      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));
      return paths;
    };
  };
  function d3_layout_bundlePath(link) {
    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];
    while (start !== lca) {
      start = start.parent;
      points.push(start);
    }
    var k = points.length;
    while (end !== lca) {
      points.splice(k, 0, end);
      end = end.parent;
    }
    return points;
  }
  function d3_layout_bundleAncestors(node) {
    var ancestors = [], parent = node.parent;
    while (parent != null) {
      ancestors.push(node);
      node = parent;
      parent = parent.parent;
    }
    ancestors.push(node);
    return ancestors;
  }
  function d3_layout_bundleLeastCommonAncestor(a, b) {
    if (a === b) return a;
    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;
    while (aNode === bNode) {
      sharedNode = aNode;
      aNode = aNodes.pop();
      bNode = bNodes.pop();
    }
    return sharedNode;
  }
  d3.layout.chord = function() {
    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;
    function relayout() {
      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;
      chords = [];
      groups = [];
      k = 0, i = -1;
      while (++i < n) {
        x = 0, j = -1;
        while (++j < n) {
          x += matrix[i][j];
        }
        groupSums.push(x);
        subgroupIndex.push(d3.range(n));
        k += x;
      }
      if (sortGroups) {
        groupIndex.sort(function(a, b) {
          return sortGroups(groupSums[a], groupSums[b]);
        });
      }
      if (sortSubgroups) {
        subgroupIndex.forEach(function(d, i) {
          d.sort(function(a, b) {
            return sortSubgroups(matrix[i][a], matrix[i][b]);
          });
        });
      }
      k = (τ - padding * n) / k;
      x = 0, i = -1;
      while (++i < n) {
        x0 = x, j = -1;
        while (++j < n) {
          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;
          subgroups[di + "-" + dj] = {
            index: di,
            subindex: dj,
            startAngle: a0,
            endAngle: a1,
            value: v
          };
        }
        groups[di] = {
          index: di,
          startAngle: x0,
          endAngle: x,
          value: groupSums[di]
        };
        x += padding;
      }
      i = -1;
      while (++i < n) {
        j = i - 1;
        while (++j < n) {
          var source = subgroups[i + "-" + j], target = subgroups[j + "-" + i];
          if (source.value || target.value) {
            chords.push(source.value < target.value ? {
              source: target,
              target: source
            } : {
              source: source,
              target: target
            });
          }
        }
      }
      if (sortChords) resort();
    }
    function resort() {
      chords.sort(function(a, b) {
        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);
      });
    }
    chord.matrix = function(x) {
      if (!arguments.length) return matrix;
      n = (matrix = x) && matrix.length;
      chords = groups = null;
      return chord;
    };
    chord.padding = function(x) {
      if (!arguments.length) return padding;
      padding = x;
      chords = groups = null;
      return chord;
    };
    chord.sortGroups = function(x) {
      if (!arguments.length) return sortGroups;
      sortGroups = x;
      chords = groups = null;
      return chord;
    };
    chord.sortSubgroups = function(x) {
      if (!arguments.length) return sortSubgroups;
      sortSubgroups = x;
      chords = null;
      return chord;
    };
    chord.sortChords = function(x) {
      if (!arguments.length) return sortChords;
      sortChords = x;
      if (chords) resort();
      return chord;
    };
    chord.chords = function() {
      if (!chords) relayout();
      return chords;
    };
    chord.groups = function() {
      if (!groups) relayout();
      return groups;
    };
    return chord;
  };
  d3.layout.force = function() {
    var force = {}, event = d3.dispatch("start", "tick", "end"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;
    function repulse(node) {
      return function(quad, x1, _, x2) {
        if (quad.point !== node) {
          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;
          if (dw * dw / theta2 < dn) {
            if (dn < chargeDistance2) {
              var k = quad.charge / dn;
              node.px -= dx * k;
              node.py -= dy * k;
            }
            return true;
          }
          if (quad.point && dn && dn < chargeDistance2) {
            var k = quad.pointCharge / dn;
            node.px -= dx * k;
            node.py -= dy * k;
          }
        }
        return !quad.charge;
      };
    }
    force.tick = function() {
      if ((alpha *= .99) < .005) {
        timer = null;
        event.end({
          type: "end",
          alpha: alpha = 0
        });
        return true;
      }
      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;
      for (i = 0; i < m; ++i) {
        o = links[i];
        s = o.source;
        t = o.target;
        x = t.x - s.x;
        y = t.y - s.y;
        if (l = x * x + y * y) {
          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;
          x *= l;
          y *= l;
          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);
          t.y -= y * k;
          s.x += x * (k = 1 - k);
          s.y += y * k;
        }
      }
      if (k = alpha * gravity) {
        x = size[0] / 2;
        y = size[1] / 2;
        i = -1;
        if (k) while (++i < n) {
          o = nodes[i];
          o.x += (x - o.x) * k;
          o.y += (y - o.y) * k;
        }
      }
      if (charge) {
        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);
        i = -1;
        while (++i < n) {
          if (!(o = nodes[i]).fixed) {
            q.visit(repulse(o));
          }
        }
      }
      i = -1;
      while (++i < n) {
        o = nodes[i];
        if (o.fixed) {
          o.x = o.px;
          o.y = o.py;
        } else {
          o.x -= (o.px - (o.px = o.x)) * friction;
          o.y -= (o.py - (o.py = o.y)) * friction;
        }
      }
      event.tick({
        type: "tick",
        alpha: alpha
      });
    };
    force.nodes = function(x) {
      if (!arguments.length) return nodes;
      nodes = x;
      return force;
    };
    force.links = function(x) {
      if (!arguments.length) return links;
      links = x;
      return force;
    };
    force.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return force;
    };
    force.linkDistance = function(x) {
      if (!arguments.length) return linkDistance;
      linkDistance = typeof x === "function" ? x : +x;
      return force;
    };
    force.distance = force.linkDistance;
    force.linkStrength = function(x) {
      if (!arguments.length) return linkStrength;
      linkStrength = typeof x === "function" ? x : +x;
      return force;
    };
    force.friction = function(x) {
      if (!arguments.length) return friction;
      friction = +x;
      return force;
    };
    force.charge = function(x) {
      if (!arguments.length) return charge;
      charge = typeof x === "function" ? x : +x;
      return force;
    };
    force.chargeDistance = function(x) {
      if (!arguments.length) return Math.sqrt(chargeDistance2);
      chargeDistance2 = x * x;
      return force;
    };
    force.gravity = function(x) {
      if (!arguments.length) return gravity;
      gravity = +x;
      return force;
    };
    force.theta = function(x) {
      if (!arguments.length) return Math.sqrt(theta2);
      theta2 = x * x;
      return force;
    };
    force.alpha = function(x) {
      if (!arguments.length) return alpha;
      x = +x;
      if (alpha) {
        if (x > 0) {
          alpha = x;
        } else {
          timer.c = null, timer.t = NaN, timer = null;
          event.end({
            type: "end",
            alpha: alpha = 0
          });
        }
      } else if (x > 0) {
        event.start({
          type: "start",
          alpha: alpha = x
        });
        timer = d3_timer(force.tick);
      }
      return force;
    };
    force.start = function() {
      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;
      for (i = 0; i < n; ++i) {
        (o = nodes[i]).index = i;
        o.weight = 0;
      }
      for (i = 0; i < m; ++i) {
        o = links[i];
        if (typeof o.source == "number") o.source = nodes[o.source];
        if (typeof o.target == "number") o.target = nodes[o.target];
        ++o.source.weight;
        ++o.target.weight;
      }
      for (i = 0; i < n; ++i) {
        o = nodes[i];
        if (isNaN(o.x)) o.x = position("x", w);
        if (isNaN(o.y)) o.y = position("y", h);
        if (isNaN(o.px)) o.px = o.x;
        if (isNaN(o.py)) o.py = o.y;
      }
      distances = [];
      if (typeof linkDistance === "function") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;
      strengths = [];
      if (typeof linkStrength === "function") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;
      charges = [];
      if (typeof charge === "function") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;
      function position(dimension, size) {
        if (!neighbors) {
          neighbors = new Array(n);
          for (j = 0; j < n; ++j) {
            neighbors[j] = [];
          }
          for (j = 0; j < m; ++j) {
            var o = links[j];
            neighbors[o.source.index].push(o.target);
            neighbors[o.target.index].push(o.source);
          }
        }
        var candidates = neighbors[i], j = -1, l = candidates.length, x;
        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;
        return Math.random() * size;
      }
      return force.resume();
    };
    force.resume = function() {
      return force.alpha(.1);
    };
    force.stop = function() {
      return force.alpha(0);
    };
    force.drag = function() {
      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on("dragstart.force", d3_layout_forceDragstart).on("drag.force", dragmove).on("dragend.force", d3_layout_forceDragend);
      if (!arguments.length) return drag;
      this.on("mouseover.force", d3_layout_forceMouseover).on("mouseout.force", d3_layout_forceMouseout).call(drag);
    };
    function dragmove(d) {
      d.px = d3.event.x, d.py = d3.event.y;
      force.resume();
    }
    return d3.rebind(force, event, "on");
  };
  function d3_layout_forceDragstart(d) {
    d.fixed |= 2;
  }
  function d3_layout_forceDragend(d) {
    d.fixed &= ~6;
  }
  function d3_layout_forceMouseover(d) {
    d.fixed |= 4;
    d.px = d.x, d.py = d.y;
  }
  function d3_layout_forceMouseout(d) {
    d.fixed &= ~4;
  }
  function d3_layout_forceAccumulate(quad, alpha, charges) {
    var cx = 0, cy = 0;
    quad.charge = 0;
    if (!quad.leaf) {
      var nodes = quad.nodes, n = nodes.length, i = -1, c;
      while (++i < n) {
        c = nodes[i];
        if (c == null) continue;
        d3_layout_forceAccumulate(c, alpha, charges);
        quad.charge += c.charge;
        cx += c.charge * c.cx;
        cy += c.charge * c.cy;
      }
    }
    if (quad.point) {
      if (!quad.leaf) {
        quad.point.x += Math.random() - .5;
        quad.point.y += Math.random() - .5;
      }
      var k = alpha * charges[quad.point.index];
      quad.charge += quad.pointCharge = k;
      cx += k * quad.point.x;
      cy += k * quad.point.y;
    }
    quad.cx = cx / quad.charge;
    quad.cy = cy / quad.charge;
  }
  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;
  d3.layout.hierarchy = function() {
    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;
    function hierarchy(root) {
      var stack = [ root ], nodes = [], node;
      root.depth = 0;
      while ((node = stack.pop()) != null) {
        nodes.push(node);
        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {
          var n, childs, child;
          while (--n >= 0) {
            stack.push(child = childs[n]);
            child.parent = node;
            child.depth = node.depth + 1;
          }
          if (value) node.value = 0;
          node.children = childs;
        } else {
          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;
          delete node.children;
        }
      }
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var childs, parent;
        if (sort && (childs = node.children)) childs.sort(sort);
        if (value && (parent = node.parent)) parent.value += node.value;
      });
      return nodes;
    }
    hierarchy.sort = function(x) {
      if (!arguments.length) return sort;
      sort = x;
      return hierarchy;
    };
    hierarchy.children = function(x) {
      if (!arguments.length) return children;
      children = x;
      return hierarchy;
    };
    hierarchy.value = function(x) {
      if (!arguments.length) return value;
      value = x;
      return hierarchy;
    };
    hierarchy.revalue = function(root) {
      if (value) {
        d3_layout_hierarchyVisitBefore(root, function(node) {
          if (node.children) node.value = 0;
        });
        d3_layout_hierarchyVisitAfter(root, function(node) {
          var parent;
          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;
          if (parent = node.parent) parent.value += node.value;
        });
      }
      return root;
    };
    return hierarchy;
  };
  function d3_layout_hierarchyRebind(object, hierarchy) {
    d3.rebind(object, hierarchy, "sort", "children", "value");
    object.nodes = object;
    object.links = d3_layout_hierarchyLinks;
    return object;
  }
  function d3_layout_hierarchyVisitBefore(node, callback) {
    var nodes = [ node ];
    while ((node = nodes.pop()) != null) {
      callback(node);
      if ((children = node.children) && (n = children.length)) {
        var n, children;
        while (--n >= 0) nodes.push(children[n]);
      }
    }
  }
  function d3_layout_hierarchyVisitAfter(node, callback) {
    var nodes = [ node ], nodes2 = [];
    while ((node = nodes.pop()) != null) {
      nodes2.push(node);
      if ((children = node.children) && (n = children.length)) {
        var i = -1, n, children;
        while (++i < n) nodes.push(children[i]);
      }
    }
    while ((node = nodes2.pop()) != null) {
      callback(node);
    }
  }
  function d3_layout_hierarchyChildren(d) {
    return d.children;
  }
  function d3_layout_hierarchyValue(d) {
    return d.value;
  }
  function d3_layout_hierarchySort(a, b) {
    return b.value - a.value;
  }
  function d3_layout_hierarchyLinks(nodes) {
    return d3.merge(nodes.map(function(parent) {
      return (parent.children || []).map(function(child) {
        return {
          source: parent,
          target: child
        };
      });
    }));
  }
  d3.layout.partition = function() {
    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];
    function position(node, x, dx, dy) {
      var children = node.children;
      node.x = x;
      node.y = node.depth * dy;
      node.dx = dx;
      node.dy = dy;
      if (children && (n = children.length)) {
        var i = -1, n, c, d;
        dx = node.value ? dx / node.value : 0;
        while (++i < n) {
          position(c = children[i], x, d = c.value * dx, dy);
          x += d;
        }
      }
    }
    function depth(node) {
      var children = node.children, d = 0;
      if (children && (n = children.length)) {
        var i = -1, n;
        while (++i < n) d = Math.max(d, depth(children[i]));
      }
      return 1 + d;
    }
    function partition(d, i) {
      var nodes = hierarchy.call(this, d, i);
      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));
      return nodes;
    }
    partition.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return partition;
    };
    return d3_layout_hierarchyRebind(partition, hierarchy);
  };
  d3.layout.pie = function() {
    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;
    function pie(data) {
      var n = data.length, values = data.map(function(d, i) {
        return +value.call(pie, d, i);
      }), a = +(typeof startAngle === "function" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === "function" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === "function" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;
      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {
        return values[j] - values[i];
      } : function(i, j) {
        return sort(data[i], data[j]);
      });
      index.forEach(function(i) {
        arcs[i] = {
          data: data[i],
          value: v = values[i],
          startAngle: a,
          endAngle: a += v * k + pa,
          padAngle: p
        };
      });
      return arcs;
    }
    pie.value = function(_) {
      if (!arguments.length) return value;
      value = _;
      return pie;
    };
    pie.sort = function(_) {
      if (!arguments.length) return sort;
      sort = _;
      return pie;
    };
    pie.startAngle = function(_) {
      if (!arguments.length) return startAngle;
      startAngle = _;
      return pie;
    };
    pie.endAngle = function(_) {
      if (!arguments.length) return endAngle;
      endAngle = _;
      return pie;
    };
    pie.padAngle = function(_) {
      if (!arguments.length) return padAngle;
      padAngle = _;
      return pie;
    };
    return pie;
  };
  var d3_layout_pieSortByValue = {};
  d3.layout.stack = function() {
    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;
    function stack(data, index) {
      if (!(n = data.length)) return data;
      var series = data.map(function(d, i) {
        return values.call(stack, d, i);
      });
      var points = series.map(function(d) {
        return d.map(function(v, i) {
          return [ x.call(stack, v, i), y.call(stack, v, i) ];
        });
      });
      var orders = order.call(stack, points, index);
      series = d3.permute(series, orders);
      points = d3.permute(points, orders);
      var offsets = offset.call(stack, points, index);
      var m = series[0].length, n, i, j, o;
      for (j = 0; j < m; ++j) {
        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);
        for (i = 1; i < n; ++i) {
          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);
        }
      }
      return data;
    }
    stack.values = function(x) {
      if (!arguments.length) return values;
      values = x;
      return stack;
    };
    stack.order = function(x) {
      if (!arguments.length) return order;
      order = typeof x === "function" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;
      return stack;
    };
    stack.offset = function(x) {
      if (!arguments.length) return offset;
      offset = typeof x === "function" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;
      return stack;
    };
    stack.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      return stack;
    };
    stack.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      return stack;
    };
    stack.out = function(z) {
      if (!arguments.length) return out;
      out = z;
      return stack;
    };
    return stack;
  };
  function d3_layout_stackX(d) {
    return d.x;
  }
  function d3_layout_stackY(d) {
    return d.y;
  }
  function d3_layout_stackOut(d, y0, y) {
    d.y0 = y0;
    d.y = y;
  }
  var d3_layout_stackOrders = d3.map({
    "inside-out": function(data) {
      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {
        return max[a] - max[b];
      }), top = 0, bottom = 0, tops = [], bottoms = [];
      for (i = 0; i < n; ++i) {
        j = index[i];
        if (top < bottom) {
          top += sums[j];
          tops.push(j);
        } else {
          bottom += sums[j];
          bottoms.push(j);
        }
      }
      return bottoms.reverse().concat(tops);
    },
    reverse: function(data) {
      return d3.range(data.length).reverse();
    },
    "default": d3_layout_stackOrderDefault
  });
  var d3_layout_stackOffsets = d3.map({
    silhouette: function(data) {
      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o > max) max = o;
        sums.push(o);
      }
      for (j = 0; j < m; ++j) {
        y0[j] = (max - sums[j]) / 2;
      }
      return y0;
    },
    wiggle: function(data) {
      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];
      y0[0] = o = o0 = 0;
      for (j = 1; j < m; ++j) {
        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];
        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {
          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {
            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;
          }
          s2 += s3 * data[i][j][1];
        }
        y0[j] = o -= s1 ? s2 / s1 * dx : 0;
        if (o < o0) o0 = o;
      }
      for (j = 0; j < m; ++j) y0[j] -= o0;
      return y0;
    },
    expand: function(data) {
      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];
      for (j = 0; j < m; ++j) {
        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];
        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;
      }
      for (j = 0; j < m; ++j) y0[j] = 0;
      return y0;
    },
    zero: d3_layout_stackOffsetZero
  });
  function d3_layout_stackOrderDefault(data) {
    return d3.range(data.length);
  }
  function d3_layout_stackOffsetZero(data) {
    var j = -1, m = data[0].length, y0 = [];
    while (++j < m) y0[j] = 0;
    return y0;
  }
  function d3_layout_stackMaxIndex(array) {
    var i = 1, j = 0, v = array[0][1], k, n = array.length;
    for (;i < n; ++i) {
      if ((k = array[i][1]) > v) {
        j = i;
        v = k;
      }
    }
    return j;
  }
  function d3_layout_stackReduceSum(d) {
    return d.reduce(d3_layout_stackSum, 0);
  }
  function d3_layout_stackSum(p, d) {
    return p + d[1];
  }
  d3.layout.histogram = function() {
    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;
    function histogram(data, i) {
      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;
      while (++i < m) {
        bin = bins[i] = [];
        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);
        bin.y = 0;
      }
      if (m > 0) {
        i = -1;
        while (++i < n) {
          x = values[i];
          if (x >= range[0] && x <= range[1]) {
            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];
            bin.y += k;
            bin.push(data[i]);
          }
        }
      }
      return bins;
    }
    histogram.value = function(x) {
      if (!arguments.length) return valuer;
      valuer = x;
      return histogram;
    };
    histogram.range = function(x) {
      if (!arguments.length) return ranger;
      ranger = d3_functor(x);
      return histogram;
    };
    histogram.bins = function(x) {
      if (!arguments.length) return binner;
      binner = typeof x === "number" ? function(range) {
        return d3_layout_histogramBinFixed(range, x);
      } : d3_functor(x);
      return histogram;
    };
    histogram.frequency = function(x) {
      if (!arguments.length) return frequency;
      frequency = !!x;
      return histogram;
    };
    return histogram;
  };
  function d3_layout_histogramBinSturges(range, values) {
    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));
  }
  function d3_layout_histogramBinFixed(range, n) {
    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];
    while (++x <= n) f[x] = m * x + b;
    return f;
  }
  function d3_layout_histogramRange(values) {
    return [ d3.min(values), d3.max(values) ];
  }
  d3.layout.pack = function() {
    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;
    function pack(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === "function" ? radius : function() {
        return radius;
      };
      root.x = root.y = 0;
      d3_layout_hierarchyVisitAfter(root, function(d) {
        d.r = +r(d.value);
      });
      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
      if (padding) {
        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r += dr;
        });
        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);
        d3_layout_hierarchyVisitAfter(root, function(d) {
          d.r -= dr;
        });
      }
      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));
      return nodes;
    }
    pack.size = function(_) {
      if (!arguments.length) return size;
      size = _;
      return pack;
    };
    pack.radius = function(_) {
      if (!arguments.length) return radius;
      radius = _ == null || typeof _ === "function" ? _ : +_;
      return pack;
    };
    pack.padding = function(_) {
      if (!arguments.length) return padding;
      padding = +_;
      return pack;
    };
    return d3_layout_hierarchyRebind(pack, hierarchy);
  };
  function d3_layout_packSort(a, b) {
    return a.value - b.value;
  }
  function d3_layout_packInsert(a, b) {
    var c = a._pack_next;
    a._pack_next = b;
    b._pack_prev = a;
    b._pack_next = c;
    c._pack_prev = b;
  }
  function d3_layout_packSplice(a, b) {
    a._pack_next = b;
    b._pack_prev = a;
  }
  function d3_layout_packIntersects(a, b) {
    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;
    return .999 * dr * dr > dx * dx + dy * dy;
  }
  function d3_layout_packSiblings(node) {
    if (!(nodes = node.children) || !(n = nodes.length)) return;
    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;
    function bound(node) {
      xMin = Math.min(node.x - node.r, xMin);
      xMax = Math.max(node.x + node.r, xMax);
      yMin = Math.min(node.y - node.r, yMin);
      yMax = Math.max(node.y + node.r, yMax);
    }
    nodes.forEach(d3_layout_packLink);
    a = nodes[0];
    a.x = -a.r;
    a.y = 0;
    bound(a);
    if (n > 1) {
      b = nodes[1];
      b.x = b.r;
      b.y = 0;
      bound(b);
      if (n > 2) {
        c = nodes[2];
        d3_layout_packPlace(a, b, c);
        bound(c);
        d3_layout_packInsert(a, c);
        a._pack_prev = c;
        d3_layout_packInsert(c, b);
        b = a._pack_next;
        for (i = 3; i < n; i++) {
          d3_layout_packPlace(a, b, c = nodes[i]);
          var isect = 0, s1 = 1, s2 = 1;
          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {
            if (d3_layout_packIntersects(j, c)) {
              isect = 1;
              break;
            }
          }
          if (isect == 1) {
            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {
              if (d3_layout_packIntersects(k, c)) {
                break;
              }
            }
          }
          if (isect) {
            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);
            i--;
          } else {
            d3_layout_packInsert(a, c);
            b = c;
            bound(c);
          }
        }
      }
    }
    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;
    for (i = 0; i < n; i++) {
      c = nodes[i];
      c.x -= cx;
      c.y -= cy;
      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));
    }
    node.r = cr;
    nodes.forEach(d3_layout_packUnlink);
  }
  function d3_layout_packLink(node) {
    node._pack_next = node._pack_prev = node;
  }
  function d3_layout_packUnlink(node) {
    delete node._pack_next;
    delete node._pack_prev;
  }
  function d3_layout_packTransform(node, x, y, k) {
    var children = node.children;
    node.x = x += k * node.x;
    node.y = y += k * node.y;
    node.r *= k;
    if (children) {
      var i = -1, n = children.length;
      while (++i < n) d3_layout_packTransform(children[i], x, y, k);
    }
  }
  function d3_layout_packPlace(a, b, c) {
    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;
    if (db && (dx || dy)) {
      var da = b.r + c.r, dc = dx * dx + dy * dy;
      da *= da;
      db *= db;
      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
      c.x = a.x + x * dx + y * dy;
      c.y = a.y + x * dy - y * dx;
    } else {
      c.x = a.x + db;
      c.y = a.y;
    }
  }
  d3.layout.tree = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;
    function tree(d, i) {
      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);
      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;
      d3_layout_hierarchyVisitBefore(root1, secondWalk);
      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {
        var left = root0, right = root0, bottom = root0;
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);
        d3_layout_hierarchyVisitBefore(root0, function(node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
      return nodes;
    }
    function wrapTree(root0) {
      var root1 = {
        A: null,
        children: [ root0 ]
      }, queue = [ root1 ], node1;
      while ((node1 = queue.pop()) != null) {
        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {
          queue.push((children[i] = child = {
            _: children[i],
            parent: node1,
            children: (child = children[i].children) && child.slice() || [],
            A: null,
            a: null,
            z: 0,
            m: 0,
            c: 0,
            s: 0,
            t: null,
            i: i
          }).a = child);
        }
      }
      return root1.children[0];
    }
    function firstWalk(v) {
      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;
      if (children.length) {
        d3_layout_treeShift(v);
        var midpoint = (children[0].z + children[children.length - 1].z) / 2;
        if (w) {
          v.z = w.z + separation(v._, w._);
          v.m = v.z - midpoint;
        } else {
          v.z = midpoint;
        }
      } else if (w) {
        v.z = w.z + separation(v._, w._);
      }
      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
    }
    function secondWalk(v) {
      v._.x = v.z + v.parent.m;
      v.m += v.parent.m;
    }
    function apportion(v, w, ancestor) {
      if (w) {
        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {
          vom = d3_layout_treeLeft(vom);
          vop = d3_layout_treeRight(vop);
          vop.a = v;
          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
          if (shift > 0) {
            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);
            sip += shift;
            sop += shift;
          }
          sim += vim.m;
          sip += vip.m;
          som += vom.m;
          sop += vop.m;
        }
        if (vim && !d3_layout_treeRight(vop)) {
          vop.t = vim;
          vop.m += sim - sop;
        }
        if (vip && !d3_layout_treeLeft(vom)) {
          vom.t = vip;
          vom.m += sip - som;
          ancestor = v;
        }
      }
      return ancestor;
    }
    function sizeNode(node) {
      node.x *= size[0];
      node.y = node.depth * size[1];
    }
    tree.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return tree;
    };
    tree.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null ? sizeNode : null;
      return tree;
    };
    tree.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) == null ? null : sizeNode;
      return tree;
    };
    return d3_layout_hierarchyRebind(tree, hierarchy);
  };
  function d3_layout_treeSeparation(a, b) {
    return a.parent == b.parent ? 1 : 2;
  }
  function d3_layout_treeLeft(v) {
    var children = v.children;
    return children.length ? children[0] : v.t;
  }
  function d3_layout_treeRight(v) {
    var children = v.children, n;
    return (n = children.length) ? children[n - 1] : v.t;
  }
  function d3_layout_treeMove(wm, wp, shift) {
    var change = shift / (wp.i - wm.i);
    wp.c -= change;
    wp.s += shift;
    wm.c += change;
    wp.z += shift;
    wp.m += shift;
  }
  function d3_layout_treeShift(v) {
    var shift = 0, change = 0, children = v.children, i = children.length, w;
    while (--i >= 0) {
      w = children[i];
      w.z += shift;
      w.m += shift;
      shift += w.s + (change += w.c);
    }
  }
  function d3_layout_treeAncestor(vim, v, ancestor) {
    return vim.a.parent === v.parent ? vim.a : ancestor;
  }
  d3.layout.cluster = function() {
    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;
    function cluster(d, i) {
      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;
      d3_layout_hierarchyVisitAfter(root, function(node) {
        var children = node.children;
        if (children && children.length) {
          node.x = d3_layout_clusterX(children);
          node.y = d3_layout_clusterY(children);
        } else {
          node.x = previousNode ? x += separation(node, previousNode) : 0;
          node.y = 0;
          previousNode = node;
        }
      });
      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;
      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {
        node.x = (node.x - root.x) * size[0];
        node.y = (root.y - node.y) * size[1];
      } : function(node) {
        node.x = (node.x - x0) / (x1 - x0) * size[0];
        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];
      });
      return nodes;
    }
    cluster.separation = function(x) {
      if (!arguments.length) return separation;
      separation = x;
      return cluster;
    };
    cluster.size = function(x) {
      if (!arguments.length) return nodeSize ? null : size;
      nodeSize = (size = x) == null;
      return cluster;
    };
    cluster.nodeSize = function(x) {
      if (!arguments.length) return nodeSize ? size : null;
      nodeSize = (size = x) != null;
      return cluster;
    };
    return d3_layout_hierarchyRebind(cluster, hierarchy);
  };
  function d3_layout_clusterY(children) {
    return 1 + d3.max(children, function(child) {
      return child.y;
    });
  }
  function d3_layout_clusterX(children) {
    return children.reduce(function(x, child) {
      return x + child.x;
    }, 0) / children.length;
  }
  function d3_layout_clusterLeft(node) {
    var children = node.children;
    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;
  }
  function d3_layout_clusterRight(node) {
    var children = node.children, n;
    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;
  }
  d3.layout.treemap = function() {
    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = "squarify", ratio = .5 * (1 + Math.sqrt(5));
    function scale(children, k) {
      var i = -1, n = children.length, child, area;
      while (++i < n) {
        area = (child = children[i]).value * (k < 0 ? 0 : k);
        child.area = isNaN(area) || area <= 0 ? 0 : area;
      }
    }
    function squarify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === "slice" ? rect.dx : mode === "dice" ? rect.dy : mode === "slice-dice" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while ((n = remaining.length) > 0) {
          row.push(child = remaining[n - 1]);
          row.area += child.area;
          if (mode !== "squarify" || (score = worst(row, u)) <= best) {
            remaining.pop();
            best = score;
          } else {
            row.area -= row.pop().area;
            position(row, u, rect, false);
            u = Math.min(rect.dx, rect.dy);
            row.length = row.area = 0;
            best = Infinity;
          }
        }
        if (row.length) {
          position(row, u, rect, true);
          row.length = row.area = 0;
        }
        children.forEach(squarify);
      }
    }
    function stickify(node) {
      var children = node.children;
      if (children && children.length) {
        var rect = pad(node), remaining = children.slice(), child, row = [];
        scale(remaining, rect.dx * rect.dy / node.value);
        row.area = 0;
        while (child = remaining.pop()) {
          row.push(child);
          row.area += child.area;
          if (child.z != null) {
            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);
            row.length = row.area = 0;
          }
        }
        children.forEach(stickify);
      }
    }
    function worst(row, u) {
      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;
      while (++i < n) {
        if (!(r = row[i].area)) continue;
        if (r < rmin) rmin = r;
        if (r > rmax) rmax = r;
      }
      s *= s;
      u *= u;
      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;
    }
    function position(row, u, rect, flush) {
      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;
      if (u == rect.dx) {
        if (flush || v > rect.dy) v = rect.dy;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dy = v;
          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);
        }
        o.z = true;
        o.dx += rect.x + rect.dx - x;
        rect.y += v;
        rect.dy -= v;
      } else {
        if (flush || v > rect.dx) v = rect.dx;
        while (++i < n) {
          o = row[i];
          o.x = x;
          o.y = y;
          o.dx = v;
          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);
        }
        o.z = false;
        o.dy += rect.y + rect.dy - y;
        rect.x += v;
        rect.dx -= v;
      }
    }
    function treemap(d) {
      var nodes = stickies || hierarchy(d), root = nodes[0];
      root.x = root.y = 0;
      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;
      if (stickies) hierarchy.revalue(root);
      scale([ root ], root.dx * root.dy / root.value);
      (stickies ? stickify : squarify)(root);
      if (sticky) stickies = nodes;
      return nodes;
    }
    treemap.size = function(x) {
      if (!arguments.length) return size;
      size = x;
      return treemap;
    };
    treemap.padding = function(x) {
      if (!arguments.length) return padding;
      function padFunction(node) {
        var p = x.call(treemap, node, node.depth);
        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === "number" ? [ p, p, p, p ] : p);
      }
      function padConstant(node) {
        return d3_layout_treemapPad(node, x);
      }
      var type;
      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === "function" ? padFunction : type === "number" ? (x = [ x, x, x, x ], 
      padConstant) : padConstant;
      return treemap;
    };
    treemap.round = function(x) {
      if (!arguments.length) return round != Number;
      round = x ? Math.round : Number;
      return treemap;
    };
    treemap.sticky = function(x) {
      if (!arguments.length) return sticky;
      sticky = x;
      stickies = null;
      return treemap;
    };
    treemap.ratio = function(x) {
      if (!arguments.length) return ratio;
      ratio = x;
      return treemap;
    };
    treemap.mode = function(x) {
      if (!arguments.length) return mode;
      mode = x + "";
      return treemap;
    };
    return d3_layout_hierarchyRebind(treemap, hierarchy);
  };
  function d3_layout_treemapPadNull(node) {
    return {
      x: node.x,
      y: node.y,
      dx: node.dx,
      dy: node.dy
    };
  }
  function d3_layout_treemapPad(node, padding) {
    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];
    if (dx < 0) {
      x += dx / 2;
      dx = 0;
    }
    if (dy < 0) {
      y += dy / 2;
      dy = 0;
    }
    return {
      x: x,
      y: y,
      dx: dx,
      dy: dy
    };
  }
  d3.random = {
    normal: function(µ, σ) {
      var n = arguments.length;
      if (n < 2) σ = 1;
      if (n < 1) µ = 0;
      return function() {
        var x, y, r;
        do {
          x = Math.random() * 2 - 1;
          y = Math.random() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);
      };
    },
    logNormal: function() {
      var random = d3.random.normal.apply(d3, arguments);
      return function() {
        return Math.exp(random());
      };
    },
    bates: function(m) {
      var random = d3.random.irwinHall(m);
      return function() {
        return random() / m;
      };
    },
    irwinHall: function(m) {
      return function() {
        for (var s = 0, j = 0; j < m; j++) s += Math.random();
        return s;
      };
    }
  };
  d3.scale = {};
  function d3_scaleExtent(domain) {
    var start = domain[0], stop = domain[domain.length - 1];
    return start < stop ? [ start, stop ] : [ stop, start ];
  }
  function d3_scaleRange(scale) {
    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());
  }
  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {
    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);
    return function(x) {
      return i(u(x));
    };
  }
  function d3_scale_nice(domain, nice) {
    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;
    if (x1 < x0) {
      dx = i0, i0 = i1, i1 = dx;
      dx = x0, x0 = x1, x1 = dx;
    }
    domain[i0] = nice.floor(x0);
    domain[i1] = nice.ceil(x1);
    return domain;
  }
  function d3_scale_niceStep(step) {
    return step ? {
      floor: function(x) {
        return Math.floor(x / step) * step;
      },
      ceil: function(x) {
        return Math.ceil(x / step) * step;
      }
    } : d3_scale_niceIdentity;
  }
  var d3_scale_niceIdentity = {
    floor: d3_identity,
    ceil: d3_identity
  };
  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {
    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;
    if (domain[k] < domain[0]) {
      domain = domain.slice().reverse();
      range = range.slice().reverse();
    }
    while (++j <= k) {
      u.push(uninterpolate(domain[j - 1], domain[j]));
      i.push(interpolate(range[j - 1], range[j]));
    }
    return function(x) {
      var j = d3.bisect(domain, x, 1, k) - 1;
      return i[j](u[j](x));
    };
  }
  d3.scale.linear = function() {
    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);
  };
  function d3_scale_linear(domain, range, interpolate, clamp) {
    var output, input;
    function rescale() {
      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;
      output = linear(domain, range, uninterpolate, interpolate);
      input = linear(range, domain, uninterpolate, d3_interpolate);
      return scale;
    }
    function scale(x) {
      return output(x);
    }
    scale.invert = function(y) {
      return input(y);
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(Number);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.rangeRound = function(x) {
      return scale.range(x).interpolate(d3_interpolateRound);
    };
    scale.clamp = function(x) {
      if (!arguments.length) return clamp;
      clamp = x;
      return rescale();
    };
    scale.interpolate = function(x) {
      if (!arguments.length) return interpolate;
      interpolate = x;
      return rescale();
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      d3_scale_linearNice(domain, m);
      return rescale();
    };
    scale.copy = function() {
      return d3_scale_linear(domain, range, interpolate, clamp);
    };
    return rescale();
  }
  function d3_scale_linearRebind(scale, linear) {
    return d3.rebind(scale, linear, "range", "rangeRound", "interpolate", "clamp");
  }
  function d3_scale_linearNice(domain, m) {
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));
    return domain;
  }
  function d3_scale_linearTickRange(domain, m) {
    if (m == null) m = 10;
    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;
    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;
    extent[0] = Math.ceil(extent[0] / step) * step;
    extent[1] = Math.floor(extent[1] / step) * step + step * .5;
    extent[2] = step;
    return extent;
  }
  function d3_scale_linearTicks(domain, m) {
    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));
  }
  function d3_scale_linearTickFormat(domain, m, format) {
    var range = d3_scale_linearTickRange(domain, m);
    if (format) {
      var match = d3_format_re.exec(format);
      match.shift();
      if (match[8] === "s") {
        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));
        if (!match[7]) match[7] = "." + d3_scale_linearPrecision(prefix.scale(range[2]));
        match[8] = "f";
        format = d3.format(match.join(""));
        return function(d) {
          return format(prefix.scale(d)) + prefix.symbol;
        };
      }
      if (!match[7]) match[7] = "." + d3_scale_linearFormatPrecision(match[8], range);
      format = match.join("");
    } else {
      format = ",." + d3_scale_linearPrecision(range[2]) + "f";
    }
    return d3.format(format);
  }
  var d3_scale_linearFormatSignificant = {
    s: 1,
    g: 1,
    p: 1,
    r: 1,
    e: 1
  };
  function d3_scale_linearPrecision(value) {
    return -Math.floor(Math.log(value) / Math.LN10 + .01);
  }
  function d3_scale_linearFormatPrecision(type, range) {
    var p = d3_scale_linearPrecision(range[2]);
    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== "e") : p - (type === "%") * 2;
  }
  d3.scale.log = function() {
    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);
  };
  function d3_scale_log(linear, base, positive, domain) {
    function log(x) {
      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);
    }
    function pow(x) {
      return positive ? Math.pow(base, x) : -Math.pow(base, -x);
    }
    function scale(x) {
      return linear(log(x));
    }
    scale.invert = function(x) {
      return pow(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      positive = x[0] >= 0;
      linear.domain((domain = x.map(Number)).map(log));
      return scale;
    };
    scale.base = function(_) {
      if (!arguments.length) return base;
      base = +_;
      linear.domain(domain.map(log));
      return scale;
    };
    scale.nice = function() {
      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);
      linear.domain(niced);
      domain = niced.map(pow);
      return scale;
    };
    scale.ticks = function() {
      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;
      if (isFinite(j - i)) {
        if (positive) {
          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);
          ticks.push(pow(i));
        } else {
          ticks.push(pow(i));
          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);
        }
        for (i = 0; ticks[i] < u; i++) {}
        for (j = ticks.length; ticks[j - 1] > v; j--) {}
        ticks = ticks.slice(i, j);
      }
      return ticks;
    };
    scale.tickFormat = function(n, format) {
      if (!arguments.length) return d3_scale_logFormat;
      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== "function") format = d3.format(format);
      var k = Math.max(1, base * n / scale.ticks().length);
      return function(d) {
        var i = d / pow(Math.round(log(d)));
        if (i * base < base - .5) i *= base;
        return i <= k ? format(d) : "";
      };
    };
    scale.copy = function() {
      return d3_scale_log(linear.copy(), base, positive, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  var d3_scale_logFormat = d3.format(".0e"), d3_scale_logNiceNegative = {
    floor: function(x) {
      return -Math.ceil(-x);
    },
    ceil: function(x) {
      return -Math.floor(-x);
    }
  };
  d3.scale.pow = function() {
    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);
  };
  function d3_scale_pow(linear, exponent, domain) {
    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);
    function scale(x) {
      return linear(powp(x));
    }
    scale.invert = function(x) {
      return powb(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      linear.domain((domain = x.map(Number)).map(powp));
      return scale;
    };
    scale.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    scale.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    scale.nice = function(m) {
      return scale.domain(d3_scale_linearNice(domain, m));
    };
    scale.exponent = function(x) {
      if (!arguments.length) return exponent;
      powp = d3_scale_powPow(exponent = x);
      powb = d3_scale_powPow(1 / exponent);
      linear.domain(domain.map(powp));
      return scale;
    };
    scale.copy = function() {
      return d3_scale_pow(linear.copy(), exponent, domain);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_scale_powPow(e) {
    return function(x) {
      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);
    };
  }
  d3.scale.sqrt = function() {
    return d3.scale.pow().exponent(.5);
  };
  d3.scale.ordinal = function() {
    return d3_scale_ordinal([], {
      t: "range",
      a: [ [] ]
    });
  };
  function d3_scale_ordinal(domain, ranger) {
    var index, range, rangeBand;
    function scale(x) {
      return range[((index.get(x) || (ranger.t === "range" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];
    }
    function steps(start, step) {
      return d3.range(domain.length).map(function(i) {
        return start + step * i;
      });
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = [];
      index = new d3_Map();
      var i = -1, n = x.length, xi;
      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));
      return scale[ranger.t].apply(scale, ranger.a);
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      rangeBand = 0;
      ranger = {
        t: "range",
        a: arguments
      };
      return scale;
    };
    scale.rangePoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, 
      0) : (stop - start) / (domain.length - 1 + padding);
      range = steps(start + step * padding / 2, step);
      rangeBand = 0;
      ranger = {
        t: "rangePoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundPoints = function(x, padding) {
      if (arguments.length < 2) padding = 0;
      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), 
      0) : (stop - start) / (domain.length - 1 + padding) | 0;
      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);
      rangeBand = 0;
      ranger = {
        t: "rangeRoundPoints",
        a: arguments
      };
      return scale;
    };
    scale.rangeBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);
      range = steps(start + step * outerPadding, step);
      if (reverse) range.reverse();
      rangeBand = step * (1 - padding);
      ranger = {
        t: "rangeBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeRoundBands = function(x, padding, outerPadding) {
      if (arguments.length < 2) padding = 0;
      if (arguments.length < 3) outerPadding = padding;
      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));
      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);
      if (reverse) range.reverse();
      rangeBand = Math.round(step * (1 - padding));
      ranger = {
        t: "rangeRoundBands",
        a: arguments
      };
      return scale;
    };
    scale.rangeBand = function() {
      return rangeBand;
    };
    scale.rangeExtent = function() {
      return d3_scaleExtent(ranger.a[0]);
    };
    scale.copy = function() {
      return d3_scale_ordinal(domain, ranger);
    };
    return scale.domain(domain);
  }
  d3.scale.category10 = function() {
    return d3.scale.ordinal().range(d3_category10);
  };
  d3.scale.category20 = function() {
    return d3.scale.ordinal().range(d3_category20);
  };
  d3.scale.category20b = function() {
    return d3.scale.ordinal().range(d3_category20b);
  };
  d3.scale.category20c = function() {
    return d3.scale.ordinal().range(d3_category20c);
  };
  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);
  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);
  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);
  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);
  d3.scale.quantile = function() {
    return d3_scale_quantile([], []);
  };
  function d3_scale_quantile(domain, range) {
    var thresholds;
    function rescale() {
      var k = 0, q = range.length;
      thresholds = [];
      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);
      return scale;
    }
    function scale(x) {
      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];
    }
    scale.domain = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.quantiles = function() {
      return thresholds;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];
    };
    scale.copy = function() {
      return d3_scale_quantile(domain, range);
    };
    return rescale();
  }
  d3.scale.quantize = function() {
    return d3_scale_quantize(0, 1, [ 0, 1 ]);
  };
  function d3_scale_quantize(x0, x1, range) {
    var kx, i;
    function scale(x) {
      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];
    }
    function rescale() {
      kx = range.length / (x1 - x0);
      i = range.length - 1;
      return scale;
    }
    scale.domain = function(x) {
      if (!arguments.length) return [ x0, x1 ];
      x0 = +x[0];
      x1 = +x[x.length - 1];
      return rescale();
    };
    scale.range = function(x) {
      if (!arguments.length) return range;
      range = x;
      return rescale();
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      y = y < 0 ? NaN : y / kx + x0;
      return [ y, y + 1 / kx ];
    };
    scale.copy = function() {
      return d3_scale_quantize(x0, x1, range);
    };
    return rescale();
  }
  d3.scale.threshold = function() {
    return d3_scale_threshold([ .5 ], [ 0, 1 ]);
  };
  function d3_scale_threshold(domain, range) {
    function scale(x) {
      if (x <= x) return range[d3.bisect(domain, x)];
    }
    scale.domain = function(_) {
      if (!arguments.length) return domain;
      domain = _;
      return scale;
    };
    scale.range = function(_) {
      if (!arguments.length) return range;
      range = _;
      return scale;
    };
    scale.invertExtent = function(y) {
      y = range.indexOf(y);
      return [ domain[y - 1], domain[y] ];
    };
    scale.copy = function() {
      return d3_scale_threshold(domain, range);
    };
    return scale;
  }
  d3.scale.identity = function() {
    return d3_scale_identity([ 0, 1 ]);
  };
  function d3_scale_identity(domain) {
    function identity(x) {
      return +x;
    }
    identity.invert = identity;
    identity.domain = identity.range = function(x) {
      if (!arguments.length) return domain;
      domain = x.map(identity);
      return identity;
    };
    identity.ticks = function(m) {
      return d3_scale_linearTicks(domain, m);
    };
    identity.tickFormat = function(m, format) {
      return d3_scale_linearTickFormat(domain, m, format);
    };
    identity.copy = function() {
      return d3_scale_identity(domain);
    };
    return identity;
  }
  d3.svg = {};
  function d3_zero() {
    return 0;
  }
  d3.svg.arc = function() {
    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;
    function arc() {
      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;
      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;
      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : "") + "Z";
      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];
      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {
        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);
        if (!cw) p1 *= -1;
        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));
        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));
      }
      if (r1) {
        x0 = r1 * Math.cos(a0 + p1);
        y0 = r1 * Math.sin(a0 + p1);
        x1 = r1 * Math.cos(a1 - p1);
        y1 = r1 * Math.sin(a1 - p1);
        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;
        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {
          var h1 = (a0 + a1) / 2;
          x0 = r1 * Math.cos(h1);
          y0 = r1 * Math.sin(h1);
          x1 = y1 = null;
        }
      } else {
        x0 = y0 = 0;
      }
      if (r0) {
        x2 = r0 * Math.cos(a1 - p0);
        y2 = r0 * Math.sin(a1 - p0);
        x3 = r0 * Math.cos(a0 + p0);
        y3 = r0 * Math.sin(a0 + p0);
        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;
        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {
          var h0 = (a0 + a1) / 2;
          x2 = r0 * Math.cos(h0);
          y2 = r0 * Math.sin(h0);
          x3 = y3 = null;
        }
      } else {
        x2 = y2 = 0;
      }
      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {
        cr = r0 < r1 ^ cw ? 0 : 1;
        var rc1 = rc, rc0 = rc;
        if (da < π) {
          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));
          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));
        }
        if (x1 != null) {
          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);
          if (rc === rc1) {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 0,", cr, " ", t30[1], "A", r1, ",", r1, " 0 ", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), ",", cw, " ", t12[1], "A", rc1, ",", rc1, " 0 0,", cr, " ", t12[0]);
          } else {
            path.push("M", t30[0], "A", rc1, ",", rc1, " 0 1,", cr, " ", t12[0]);
          }
        } else {
          path.push("M", x0, ",", y0);
        }
        if (x3 != null) {
          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);
          if (rc === rc0) {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t21[1], "A", r0, ",", r0, " 0 ", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), ",", 1 - cw, " ", t03[1], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          } else {
            path.push("L", t21[0], "A", rc0, ",", rc0, " 0 0,", cr, " ", t03[0]);
          }
        } else {
          path.push("L", x2, ",", y2);
        }
      } else {
        path.push("M", x0, ",", y0);
        if (x1 != null) path.push("A", r1, ",", r1, " 0 ", l1, ",", cw, " ", x1, ",", y1);
        path.push("L", x2, ",", y2);
        if (x3 != null) path.push("A", r0, ",", r0, " 0 ", l0, ",", 1 - cw, " ", x3, ",", y3);
      }
      path.push("Z");
      return path.join("");
    }
    function circleSegment(r1, cw) {
      return "M0," + r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + -r1 + "A" + r1 + "," + r1 + " 0 1," + cw + " 0," + r1;
    }
    arc.innerRadius = function(v) {
      if (!arguments.length) return innerRadius;
      innerRadius = d3_functor(v);
      return arc;
    };
    arc.outerRadius = function(v) {
      if (!arguments.length) return outerRadius;
      outerRadius = d3_functor(v);
      return arc;
    };
    arc.cornerRadius = function(v) {
      if (!arguments.length) return cornerRadius;
      cornerRadius = d3_functor(v);
      return arc;
    };
    arc.padRadius = function(v) {
      if (!arguments.length) return padRadius;
      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);
      return arc;
    };
    arc.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return arc;
    };
    arc.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return arc;
    };
    arc.padAngle = function(v) {
      if (!arguments.length) return padAngle;
      padAngle = d3_functor(v);
      return arc;
    };
    arc.centroid = function() {
      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;
      return [ Math.cos(a) * r, Math.sin(a) * r ];
    };
    return arc;
  };
  var d3_svg_arcAuto = "auto";
  function d3_svg_arcInnerRadius(d) {
    return d.innerRadius;
  }
  function d3_svg_arcOuterRadius(d) {
    return d.outerRadius;
  }
  function d3_svg_arcStartAngle(d) {
    return d.startAngle;
  }
  function d3_svg_arcEndAngle(d) {
    return d.endAngle;
  }
  function d3_svg_arcPadAngle(d) {
    return d && d.padAngle;
  }
  function d3_svg_arcSweep(x0, y0, x1, y1) {
    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;
  }
  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {
    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];
  }
  function d3_svg_line(projection) {
    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;
    function line(data) {
      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);
      function segment() {
        segments.push("M", interpolate(projection(points), tension));
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);
        } else if (points.length) {
          segment();
          points = [];
        }
      }
      if (points.length) segment();
      return segments.length ? segments.join("") : null;
    }
    line.x = function(_) {
      if (!arguments.length) return x;
      x = _;
      return line;
    };
    line.y = function(_) {
      if (!arguments.length) return y;
      y = _;
      return line;
    };
    line.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return line;
    };
    line.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      return line;
    };
    line.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return line;
    };
    return line;
  }
  d3.svg.line = function() {
    return d3_svg_line(d3_identity);
  };
  var d3_svg_lineInterpolators = d3.map({
    linear: d3_svg_lineLinear,
    "linear-closed": d3_svg_lineLinearClosed,
    step: d3_svg_lineStep,
    "step-before": d3_svg_lineStepBefore,
    "step-after": d3_svg_lineStepAfter,
    basis: d3_svg_lineBasis,
    "basis-open": d3_svg_lineBasisOpen,
    "basis-closed": d3_svg_lineBasisClosed,
    bundle: d3_svg_lineBundle,
    cardinal: d3_svg_lineCardinal,
    "cardinal-open": d3_svg_lineCardinalOpen,
    "cardinal-closed": d3_svg_lineCardinalClosed,
    monotone: d3_svg_lineMonotone
  });
  d3_svg_lineInterpolators.forEach(function(key, value) {
    value.key = key;
    value.closed = /-closed$/.test(key);
  });
  function d3_svg_lineLinear(points) {
    return points.length > 1 ? points.join("L") : points + "Z";
  }
  function d3_svg_lineLinearClosed(points) {
    return points.join("L") + "Z";
  }
  function d3_svg_lineStep(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p[0] + (p = points[i])[0]) / 2, "V", p[1]);
    if (n > 1) path.push("H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepBefore(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("V", (p = points[i])[1], "H", p[0]);
    return path.join("");
  }
  function d3_svg_lineStepAfter(points) {
    var i = 0, n = points.length, p = points[0], path = [ p[0], ",", p[1] ];
    while (++i < n) path.push("H", (p = points[i])[0], "V", p[1]);
    return path.join("");
  }
  function d3_svg_lineCardinalOpen(points, tension) {
    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineCardinalClosed(points, tension) {
    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), 
    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));
  }
  function d3_svg_lineCardinal(points, tension) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));
  }
  function d3_svg_lineHermite(points, tangents) {
    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {
      return d3_svg_lineLinear(points);
    }
    var quad = points.length != tangents.length, path = "", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;
    if (quad) {
      path += "Q" + (p[0] - t0[0] * 2 / 3) + "," + (p[1] - t0[1] * 2 / 3) + "," + p[0] + "," + p[1];
      p0 = points[1];
      pi = 2;
    }
    if (tangents.length > 1) {
      t = tangents[1];
      p = points[pi];
      pi++;
      path += "C" + (p0[0] + t0[0]) + "," + (p0[1] + t0[1]) + "," + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      for (var i = 2; i < tangents.length; i++, pi++) {
        p = points[pi];
        t = tangents[i];
        path += "S" + (p[0] - t[0]) + "," + (p[1] - t[1]) + "," + p[0] + "," + p[1];
      }
    }
    if (quad) {
      var lp = points[pi];
      path += "Q" + (p[0] + t[0] * 2 / 3) + "," + (p[1] + t[1] * 2 / 3) + "," + lp[0] + "," + lp[1];
    }
    return path;
  }
  function d3_svg_lineCardinalTangents(points, tension) {
    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;
    while (++i < n) {
      p0 = p1;
      p1 = p2;
      p2 = points[i];
      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);
    }
    return tangents;
  }
  function d3_svg_lineBasis(points) {
    if (points.length < 3) return d3_svg_lineLinear(points);
    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, ",", y0, "L", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    points.push(points[n - 1]);
    while (++i <= n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    points.pop();
    path.push("L", pi);
    return path.join("");
  }
  function d3_svg_lineBasisOpen(points) {
    if (points.length < 4) return d3_svg_lineLinear(points);
    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];
    while (++i < 3) {
      pi = points[i];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + "," + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));
    --i;
    while (++i < n) {
      pi = points[i];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBasisClosed(points) {
    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];
    while (++i < 4) {
      pi = points[i % n];
      px.push(pi[0]);
      py.push(pi[1]);
    }
    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];
    --i;
    while (++i < m) {
      pi = points[i % n];
      px.shift();
      px.push(pi[0]);
      py.shift();
      py.push(pi[1]);
      d3_svg_lineBasisBezier(path, px, py);
    }
    return path.join("");
  }
  function d3_svg_lineBundle(points, tension) {
    var n = points.length - 1;
    if (n) {
      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;
      while (++i <= n) {
        p = points[i];
        t = i / n;
        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);
        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);
      }
    }
    return d3_svg_lineBasis(points);
  }
  function d3_svg_lineDot4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
  }
  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];
  function d3_svg_lineBasisBezier(path, x, y) {
    path.push("C", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), ",", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));
  }
  function d3_svg_lineSlope(p0, p1) {
    return (p1[1] - p0[1]) / (p1[0] - p0[0]);
  }
  function d3_svg_lineFiniteDifferences(points) {
    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);
    while (++i < j) {
      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;
    }
    m[i] = d;
    return m;
  }
  function d3_svg_lineMonotoneTangents(points) {
    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;
    while (++i < j) {
      d = d3_svg_lineSlope(points[i], points[i + 1]);
      if (abs(d) < ε) {
        m[i] = m[i + 1] = 0;
      } else {
        a = m[i] / d;
        b = m[i + 1] / d;
        s = a * a + b * b;
        if (s > 9) {
          s = d * 3 / Math.sqrt(s);
          m[i] = s * a;
          m[i + 1] = s * b;
        }
      }
    }
    i = -1;
    while (++i <= j) {
      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));
      tangents.push([ s || 0, m[i] * s || 0 ]);
    }
    return tangents;
  }
  function d3_svg_lineMonotone(points) {
    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));
  }
  d3.svg.line.radial = function() {
    var line = d3_svg_line(d3_svg_lineRadial);
    line.radius = line.x, delete line.x;
    line.angle = line.y, delete line.y;
    return line;
  };
  function d3_svg_lineRadial(points) {
    var point, i = -1, n = points.length, r, a;
    while (++i < n) {
      point = points[i];
      r = point[0];
      a = point[1] - halfπ;
      point[0] = r * Math.cos(a);
      point[1] = r * Math.sin(a);
    }
    return points;
  }
  function d3_svg_area(projection) {
    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = "L", tension = .7;
    function area(data) {
      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {
        return x;
      } : d3_functor(x1), fy1 = y0 === y1 ? function() {
        return y;
      } : d3_functor(y1), x, y;
      function segment() {
        segments.push("M", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), "Z");
      }
      while (++i < n) {
        if (defined.call(this, d = data[i], i)) {
          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);
          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);
        } else if (points0.length) {
          segment();
          points0 = [];
          points1 = [];
        }
      }
      if (points0.length) segment();
      return segments.length ? segments.join("") : null;
    }
    area.x = function(_) {
      if (!arguments.length) return x1;
      x0 = x1 = _;
      return area;
    };
    area.x0 = function(_) {
      if (!arguments.length) return x0;
      x0 = _;
      return area;
    };
    area.x1 = function(_) {
      if (!arguments.length) return x1;
      x1 = _;
      return area;
    };
    area.y = function(_) {
      if (!arguments.length) return y1;
      y0 = y1 = _;
      return area;
    };
    area.y0 = function(_) {
      if (!arguments.length) return y0;
      y0 = _;
      return area;
    };
    area.y1 = function(_) {
      if (!arguments.length) return y1;
      y1 = _;
      return area;
    };
    area.defined = function(_) {
      if (!arguments.length) return defined;
      defined = _;
      return area;
    };
    area.interpolate = function(_) {
      if (!arguments.length) return interpolateKey;
      if (typeof _ === "function") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;
      interpolateReverse = interpolate.reverse || interpolate;
      L = interpolate.closed ? "M" : "L";
      return area;
    };
    area.tension = function(_) {
      if (!arguments.length) return tension;
      tension = _;
      return area;
    };
    return area;
  }
  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;
  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;
  d3.svg.area = function() {
    return d3_svg_area(d3_identity);
  };
  d3.svg.area.radial = function() {
    var area = d3_svg_area(d3_svg_lineRadial);
    area.radius = area.x, delete area.x;
    area.innerRadius = area.x0, delete area.x0;
    area.outerRadius = area.x1, delete area.x1;
    area.angle = area.y, delete area.y;
    area.startAngle = area.y0, delete area.y0;
    area.endAngle = area.y1, delete area.y1;
    return area;
  };
  d3.svg.chord = function() {
    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;
    function chord(d, i) {
      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);
      return "M" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + "Z";
    }
    function subgroup(self, f, d, i) {
      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;
      return {
        r: r,
        a0: a0,
        a1: a1,
        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],
        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]
      };
    }
    function equals(a, b) {
      return a.a0 == b.a0 && a.a1 == b.a1;
    }
    function arc(r, p, a) {
      return "A" + r + "," + r + " 0 " + +(a > π) + ",1 " + p;
    }
    function curve(r0, p0, r1, p1) {
      return "Q 0,0 " + p1;
    }
    chord.radius = function(v) {
      if (!arguments.length) return radius;
      radius = d3_functor(v);
      return chord;
    };
    chord.source = function(v) {
      if (!arguments.length) return source;
      source = d3_functor(v);
      return chord;
    };
    chord.target = function(v) {
      if (!arguments.length) return target;
      target = d3_functor(v);
      return chord;
    };
    chord.startAngle = function(v) {
      if (!arguments.length) return startAngle;
      startAngle = d3_functor(v);
      return chord;
    };
    chord.endAngle = function(v) {
      if (!arguments.length) return endAngle;
      endAngle = d3_functor(v);
      return chord;
    };
    return chord;
  };
  function d3_svg_chordRadius(d) {
    return d.radius;
  }
  d3.svg.diagonal = function() {
    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;
    function diagonal(d, i) {
      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {
        x: p0.x,
        y: m
      }, {
        x: p3.x,
        y: m
      }, p3 ];
      p = p.map(projection);
      return "M" + p[0] + "C" + p[1] + " " + p[2] + " " + p[3];
    }
    diagonal.source = function(x) {
      if (!arguments.length) return source;
      source = d3_functor(x);
      return diagonal;
    };
    diagonal.target = function(x) {
      if (!arguments.length) return target;
      target = d3_functor(x);
      return diagonal;
    };
    diagonal.projection = function(x) {
      if (!arguments.length) return projection;
      projection = x;
      return diagonal;
    };
    return diagonal;
  };
  function d3_svg_diagonalProjection(d) {
    return [ d.x, d.y ];
  }
  d3.svg.diagonal.radial = function() {
    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;
    diagonal.projection = function(x) {
      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;
    };
    return diagonal;
  };
  function d3_svg_diagonalRadialProjection(projection) {
    return function() {
      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;
      return [ r * Math.cos(a), r * Math.sin(a) ];
    };
  }
  d3.svg.symbol = function() {
    var type = d3_svg_symbolType, size = d3_svg_symbolSize;
    function symbol(d, i) {
      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));
    }
    symbol.type = function(x) {
      if (!arguments.length) return type;
      type = d3_functor(x);
      return symbol;
    };
    symbol.size = function(x) {
      if (!arguments.length) return size;
      size = d3_functor(x);
      return symbol;
    };
    return symbol;
  };
  function d3_svg_symbolSize() {
    return 64;
  }
  function d3_svg_symbolType() {
    return "circle";
  }
  function d3_svg_symbolCircle(size) {
    var r = Math.sqrt(size / π);
    return "M0," + r + "A" + r + "," + r + " 0 1,1 0," + -r + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
  }
  var d3_svg_symbols = d3.map({
    circle: d3_svg_symbolCircle,
    cross: function(size) {
      var r = Math.sqrt(size / 5) / 2;
      return "M" + -3 * r + "," + -r + "H" + -r + "V" + -3 * r + "H" + r + "V" + -r + "H" + 3 * r + "V" + r + "H" + r + "V" + 3 * r + "H" + -r + "V" + r + "H" + -3 * r + "Z";
    },
    diamond: function(size) {
      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;
      return "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
    },
    square: function(size) {
      var r = Math.sqrt(size) / 2;
      return "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
    },
    "triangle-down": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
    },
    "triangle-up": function(size) {
      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;
      return "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
    }
  });
  d3.svg.symbolTypes = d3_svg_symbols.keys();
  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);
  d3_selectionPrototype.transition = function(name) {
    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {
      time: Date.now(),
      ease: d3_ease_cubicInOut,
      delay: 0,
      duration: 250
    };
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_selectionPrototype.interrupt = function(name) {
    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));
  };
  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());
  function d3_selection_interruptNS(ns) {
    return function() {
      var lock, activeId, active;
      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {
        active.timer.c = null;
        active.timer.t = NaN;
        if (--lock.count) delete lock[activeId]; else delete this[ns];
        lock.active += .5;
        active.event && active.event.interrupt.call(this, this.__data__, active.index);
      }
    };
  }
  function d3_transition(groups, ns, id) {
    d3_subclass(groups, d3_transitionPrototype);
    groups.namespace = ns;
    groups.id = id;
    return groups;
  }
  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;
  d3_transitionPrototype.call = d3_selectionPrototype.call;
  d3_transitionPrototype.empty = d3_selectionPrototype.empty;
  d3_transitionPrototype.node = d3_selectionPrototype.node;
  d3_transitionPrototype.size = d3_selectionPrototype.size;
  d3.transition = function(selection, name) {
    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);
  };
  d3.transition.prototype = d3_transitionPrototype;
  d3_transitionPrototype.select = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;
    selector = d3_selection_selector(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {
          if ("__data__" in node) subnode.__data__ = node.__data__;
          d3_transitionNode(subnode, i, ns, id, node[ns][id]);
          subgroup.push(subnode);
        } else {
          subgroup.push(null);
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.selectAll = function(selector) {
    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;
    selector = d3_selection_selectorAll(selector);
    for (var j = -1, m = this.length; ++j < m; ) {
      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {
        if (node = group[i]) {
          transition = node[ns][id];
          subnodes = selector.call(node, node.__data__, i, j);
          subgroups.push(subgroup = []);
          for (var k = -1, o = subnodes.length; ++k < o; ) {
            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);
            subgroup.push(subnode);
          }
        }
      }
    }
    return d3_transition(subgroups, ns, id);
  };
  d3_transitionPrototype.filter = function(filter) {
    var subgroups = [], subgroup, group, node;
    if (typeof filter !== "function") filter = d3_selection_filter(filter);
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {
          subgroup.push(node);
        }
      }
    }
    return d3_transition(subgroups, this.namespace, this.id);
  };
  d3_transitionPrototype.tween = function(name, tween) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);
    return d3_selection_each(this, tween == null ? function(node) {
      node[ns][id].tween.remove(name);
    } : function(node) {
      node[ns][id].tween.set(name, tween);
    });
  };
  function d3_transition_tween(groups, name, value, tween) {
    var id = groups.id, ns = groups.namespace;
    return d3_selection_each(groups, typeof value === "function" ? function(node, i, j) {
      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));
    } : (value = tween(value), function(node) {
      node[ns][id].tween.set(name, value);
    }));
  }
  d3_transitionPrototype.attr = function(nameNS, value) {
    if (arguments.length < 2) {
      for (value in nameNS) this.attr(value, nameNS[value]);
      return this;
    }
    var interpolate = nameNS == "transform" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);
    function attrNull() {
      this.removeAttribute(name);
    }
    function attrNullNS() {
      this.removeAttributeNS(name.space, name.local);
    }
    function attrTween(b) {
      return b == null ? attrNull : (b += "", function() {
        var a = this.getAttribute(name), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttribute(name, i(t));
        });
      });
    }
    function attrTweenNS(b) {
      return b == null ? attrNullNS : (b += "", function() {
        var a = this.getAttributeNS(name.space, name.local), i;
        return a !== b && (i = interpolate(a, b), function(t) {
          this.setAttributeNS(name.space, name.local, i(t));
        });
      });
    }
    return d3_transition_tween(this, "attr." + nameNS, value, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.attrTween = function(nameNS, tween) {
    var name = d3.ns.qualify(nameNS);
    function attrTween(d, i) {
      var f = tween.call(this, d, i, this.getAttribute(name));
      return f && function(t) {
        this.setAttribute(name, f(t));
      };
    }
    function attrTweenNS(d, i) {
      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));
      return f && function(t) {
        this.setAttributeNS(name.space, name.local, f(t));
      };
    }
    return this.tween("attr." + nameNS, name.local ? attrTweenNS : attrTween);
  };
  d3_transitionPrototype.style = function(name, value, priority) {
    var n = arguments.length;
    if (n < 3) {
      if (typeof name !== "string") {
        if (n < 2) value = "";
        for (priority in name) this.style(priority, name[priority], value);
        return this;
      }
      priority = "";
    }
    function styleNull() {
      this.style.removeProperty(name);
    }
    function styleString(b) {
      return b == null ? styleNull : (b += "", function() {
        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;
        return a !== b && (i = d3_interpolate(a, b), function(t) {
          this.style.setProperty(name, i(t), priority);
        });
      });
    }
    return d3_transition_tween(this, "style." + name, value, styleString);
  };
  d3_transitionPrototype.styleTween = function(name, tween, priority) {
    if (arguments.length < 3) priority = "";
    function styleTween(d, i) {
      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));
      return f && function(t) {
        this.style.setProperty(name, f(t), priority);
      };
    }
    return this.tween("style." + name, styleTween);
  };
  d3_transitionPrototype.text = function(value) {
    return d3_transition_tween(this, "text", value, d3_transition_text);
  };
  function d3_transition_text(b) {
    if (b == null) b = "";
    return function() {
      this.textContent = b;
    };
  }
  d3_transitionPrototype.remove = function() {
    var ns = this.namespace;
    return this.each("end.transition", function() {
      var p;
      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);
    });
  };
  d3_transitionPrototype.ease = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].ease;
    if (typeof value !== "function") value = d3.ease.apply(d3, arguments);
    return d3_selection_each(this, function(node) {
      node[ns][id].ease = value;
    });
  };
  d3_transitionPrototype.delay = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].delay;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].delay = +value.call(node, node.__data__, i, j);
    } : (value = +value, function(node) {
      node[ns][id].delay = value;
    }));
  };
  d3_transitionPrototype.duration = function(value) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 1) return this.node()[ns][id].duration;
    return d3_selection_each(this, typeof value === "function" ? function(node, i, j) {
      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));
    } : (value = Math.max(1, value), function(node) {
      node[ns][id].duration = value;
    }));
  };
  d3_transitionPrototype.each = function(type, listener) {
    var id = this.id, ns = this.namespace;
    if (arguments.length < 2) {
      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;
      try {
        d3_transitionInheritId = id;
        d3_selection_each(this, function(node, i, j) {
          d3_transitionInherit = node[ns][id];
          type.call(node, node.__data__, i, j);
        });
      } finally {
        d3_transitionInherit = inherit;
        d3_transitionInheritId = inheritId;
      }
    } else {
      d3_selection_each(this, function(node) {
        var transition = node[ns][id];
        (transition.event || (transition.event = d3.dispatch("start", "end", "interrupt"))).on(type, listener);
      });
    }
    return this;
  };
  d3_transitionPrototype.transition = function() {
    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;
    for (var j = 0, m = this.length; j < m; j++) {
      subgroups.push(subgroup = []);
      for (var group = this[j], i = 0, n = group.length; i < n; i++) {
        if (node = group[i]) {
          transition = node[ns][id0];
          d3_transitionNode(node, i, ns, id1, {
            time: transition.time,
            ease: transition.ease,
            delay: transition.delay + transition.duration,
            duration: transition.duration
          });
        }
        subgroup.push(node);
      }
    }
    return d3_transition(subgroups, ns, id1);
  };
  function d3_transitionNamespace(name) {
    return name == null ? "__transition__" : "__transition_" + name + "__";
  }
  function d3_transitionNode(node, i, ns, id, inherit) {
    var lock = node[ns] || (node[ns] = {
      active: 0,
      count: 0
    }), transition = lock[id], time, timer, duration, ease, tweens;
    function schedule(elapsed) {
      var delay = transition.delay;
      timer.t = delay + time;
      if (delay <= elapsed) return start(elapsed - delay);
      timer.c = start;
    }
    function start(elapsed) {
      var activeId = lock.active, active = lock[activeId];
      if (active) {
        active.timer.c = null;
        active.timer.t = NaN;
        --lock.count;
        delete lock[activeId];
        active.event && active.event.interrupt.call(node, node.__data__, active.index);
      }
      for (var cancelId in lock) {
        if (+cancelId < id) {
          var cancel = lock[cancelId];
          cancel.timer.c = null;
          cancel.timer.t = NaN;
          --lock.count;
          delete lock[cancelId];
        }
      }
      timer.c = tick;
      d3_timer(function() {
        if (timer.c && tick(elapsed || 1)) {
          timer.c = null;
          timer.t = NaN;
        }
        return 1;
      }, 0, time);
      lock.active = id;
      transition.event && transition.event.start.call(node, node.__data__, i);
      tweens = [];
      transition.tween.forEach(function(key, value) {
        if (value = value.call(node, node.__data__, i)) {
          tweens.push(value);
        }
      });
      ease = transition.ease;
      duration = transition.duration;
    }
    function tick(elapsed) {
      var t = elapsed / duration, e = ease(t), n = tweens.length;
      while (n > 0) {
        tweens[--n].call(node, e);
      }
      if (t >= 1) {
        transition.event && transition.event.end.call(node, node.__data__, i);
        if (--lock.count) delete lock[id]; else delete node[ns];
        return 1;
      }
    }
    if (!transition) {
      time = inherit.time;
      timer = d3_timer(schedule, 0, time);
      transition = lock[id] = {
        tween: new d3_Map(),
        time: time,
        timer: timer,
        delay: inherit.delay,
        duration: inherit.duration,
        ease: inherit.ease,
        index: i
      };
      inherit = null;
      ++lock.count;
    }
  }
  d3.svg.axis = function() {
    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;
    function axis(g) {
      g.each(function() {
        var g = d3.select(this);
        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();
        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(".tick").data(ticks, scale1), tickEnter = tick.enter().insert("g", ".domain").attr("class", "tick").style("opacity", ε), tickExit = d3.transition(tick.exit()).style("opacity", ε).remove(), tickUpdate = d3.transition(tick.order()).style("opacity", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;
        var range = d3_scaleRange(scale1), path = g.selectAll(".domain").data([ 0 ]), pathUpdate = (path.enter().append("path").attr("class", "domain"), 
        d3.transition(path));
        tickEnter.append("line");
        tickEnter.append("text");
        var lineEnter = tickEnter.select("line"), lineUpdate = tickUpdate.select("line"), text = tick.select("text").text(tickFormat), textEnter = tickEnter.select("text"), textUpdate = tickUpdate.select("text"), sign = orient === "top" || orient === "left" ? -1 : 1, x1, x2, y1, y2;
        if (orient === "bottom" || orient === "top") {
          tickTransform = d3_svg_axisX, x1 = "x", y1 = "y", x2 = "x2", y2 = "y2";
          text.attr("dy", sign < 0 ? "0em" : ".71em").style("text-anchor", "middle");
          pathUpdate.attr("d", "M" + range[0] + "," + sign * outerTickSize + "V0H" + range[1] + "V" + sign * outerTickSize);
        } else {
          tickTransform = d3_svg_axisY, x1 = "y", y1 = "x", x2 = "y2", y2 = "x2";
          text.attr("dy", ".32em").style("text-anchor", sign < 0 ? "end" : "start");
          pathUpdate.attr("d", "M" + sign * outerTickSize + "," + range[0] + "H0V" + range[1] + "H" + sign * outerTickSize);
        }
        lineEnter.attr(y2, sign * innerTickSize);
        textEnter.attr(y1, sign * tickSpacing);
        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);
        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);
        if (scale1.rangeBand) {
          var x = scale1, dx = x.rangeBand() / 2;
          scale0 = scale1 = function(d) {
            return x(d) + dx;
          };
        } else if (scale0.rangeBand) {
          scale0 = scale1;
        } else {
          tickExit.call(tickTransform, scale1, scale0);
        }
        tickEnter.call(tickTransform, scale0, scale1);
        tickUpdate.call(tickTransform, scale1, scale1);
      });
    }
    axis.scale = function(x) {
      if (!arguments.length) return scale;
      scale = x;
      return axis;
    };
    axis.orient = function(x) {
      if (!arguments.length) return orient;
      orient = x in d3_svg_axisOrients ? x + "" : d3_svg_axisDefaultOrient;
      return axis;
    };
    axis.ticks = function() {
      if (!arguments.length) return tickArguments_;
      tickArguments_ = d3_array(arguments);
      return axis;
    };
    axis.tickValues = function(x) {
      if (!arguments.length) return tickValues;
      tickValues = x;
      return axis;
    };
    axis.tickFormat = function(x) {
      if (!arguments.length) return tickFormat_;
      tickFormat_ = x;
      return axis;
    };
    axis.tickSize = function(x) {
      var n = arguments.length;
      if (!n) return innerTickSize;
      innerTickSize = +x;
      outerTickSize = +arguments[n - 1];
      return axis;
    };
    axis.innerTickSize = function(x) {
      if (!arguments.length) return innerTickSize;
      innerTickSize = +x;
      return axis;
    };
    axis.outerTickSize = function(x) {
      if (!arguments.length) return outerTickSize;
      outerTickSize = +x;
      return axis;
    };
    axis.tickPadding = function(x) {
      if (!arguments.length) return tickPadding;
      tickPadding = +x;
      return axis;
    };
    axis.tickSubdivide = function() {
      return arguments.length && axis;
    };
    return axis;
  };
  var d3_svg_axisDefaultOrient = "bottom", d3_svg_axisOrients = {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  };
  function d3_svg_axisX(selection, x0, x1) {
    selection.attr("transform", function(d) {
      var v0 = x0(d);
      return "translate(" + (isFinite(v0) ? v0 : x1(d)) + ",0)";
    });
  }
  function d3_svg_axisY(selection, y0, y1) {
    selection.attr("transform", function(d) {
      var v0 = y0(d);
      return "translate(0," + (isFinite(v0) ? v0 : y1(d)) + ")";
    });
  }
  d3.svg.brush = function() {
    var event = d3_eventDispatch(brush, "brushstart", "brush", "brushend"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];
    function brush(g) {
      g.each(function() {
        var g = d3.select(this).style("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush", brushstart).on("touchstart.brush", brushstart);
        var background = g.selectAll(".background").data([ 0 ]);
        background.enter().append("rect").attr("class", "background").style("visibility", "hidden").style("cursor", "crosshair");
        g.selectAll(".extent").data([ 0 ]).enter().append("rect").attr("class", "extent").style("cursor", "move");
        var resize = g.selectAll(".resize").data(resizes, d3_identity);
        resize.exit().remove();
        resize.enter().append("g").attr("class", function(d) {
          return "resize " + d;
        }).style("cursor", function(d) {
          return d3_svg_brushCursor[d];
        }).append("rect").attr("x", function(d) {
          return /[ew]$/.test(d) ? -3 : null;
        }).attr("y", function(d) {
          return /^[ns]/.test(d) ? -3 : null;
        }).attr("width", 6).attr("height", 6).style("visibility", "hidden");
        resize.style("display", brush.empty() ? "none" : null);
        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;
        if (x) {
          range = d3_scaleRange(x);
          backgroundUpdate.attr("x", range[0]).attr("width", range[1] - range[0]);
          redrawX(gUpdate);
        }
        if (y) {
          range = d3_scaleRange(y);
          backgroundUpdate.attr("y", range[0]).attr("height", range[1] - range[0]);
          redrawY(gUpdate);
        }
        redraw(gUpdate);
      });
    }
    brush.event = function(g) {
      g.each(function() {
        var event_ = event.of(this, arguments), extent1 = {
          x: xExtent,
          y: yExtent,
          i: xExtentDomain,
          j: yExtentDomain
        }, extent0 = this.__chart__ || extent1;
        this.__chart__ = extent1;
        if (d3_transitionInheritId) {
          d3.select(this).transition().each("start.brush", function() {
            xExtentDomain = extent0.i;
            yExtentDomain = extent0.j;
            xExtent = extent0.x;
            yExtent = extent0.y;
            event_({
              type: "brushstart"
            });
          }).tween("brush:brush", function() {
            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);
            xExtentDomain = yExtentDomain = null;
            return function(t) {
              xExtent = extent1.x = xi(t);
              yExtent = extent1.y = yi(t);
              event_({
                type: "brush",
                mode: "resize"
              });
            };
          }).each("end.brush", function() {
            xExtentDomain = extent1.i;
            yExtentDomain = extent1.j;
            event_({
              type: "brush",
              mode: "resize"
            });
            event_({
              type: "brushend"
            });
          });
        } else {
          event_({
            type: "brushstart"
          });
          event_({
            type: "brush",
            mode: "resize"
          });
          event_({
            type: "brushend"
          });
        }
      });
    };
    function redraw(g) {
      g.selectAll(".resize").attr("transform", function(d) {
        return "translate(" + xExtent[+/e$/.test(d)] + "," + yExtent[+/^s/.test(d)] + ")";
      });
    }
    function redrawX(g) {
      g.select(".extent").attr("x", xExtent[0]);
      g.selectAll(".extent,.n>rect,.s>rect").attr("width", xExtent[1] - xExtent[0]);
    }
    function redrawY(g) {
      g.select(".extent").attr("y", yExtent[0]);
      g.selectAll(".extent,.e>rect,.w>rect").attr("height", yExtent[1] - yExtent[0]);
    }
    function brushstart() {
      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed("extent"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;
      var w = d3.select(d3_window(target)).on("keydown.brush", keydown).on("keyup.brush", keyup);
      if (d3.event.changedTouches) {
        w.on("touchmove.brush", brushmove).on("touchend.brush", brushend);
      } else {
        w.on("mousemove.brush", brushmove).on("mouseup.brush", brushend);
      }
      g.interrupt().selectAll("*").interrupt();
      if (dragging) {
        origin[0] = xExtent[0] - origin[0];
        origin[1] = yExtent[0] - origin[1];
      } else if (resizing) {
        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);
        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];
        origin[0] = xExtent[ex];
        origin[1] = yExtent[ey];
      } else if (d3.event.altKey) center = origin.slice();
      g.style("pointer-events", "none").selectAll(".resize").style("display", null);
      d3.select("body").style("cursor", eventTarget.style("cursor"));
      event_({
        type: "brushstart"
      });
      brushmove();
      function keydown() {
        if (d3.event.keyCode == 32) {
          if (!dragging) {
            center = null;
            origin[0] -= xExtent[1];
            origin[1] -= yExtent[1];
            dragging = 2;
          }
          d3_eventPreventDefault();
        }
      }
      function keyup() {
        if (d3.event.keyCode == 32 && dragging == 2) {
          origin[0] += xExtent[1];
          origin[1] += yExtent[1];
          dragging = 0;
          d3_eventPreventDefault();
        }
      }
      function brushmove() {
        var point = d3.mouse(target), moved = false;
        if (offset) {
          point[0] += offset[0];
          point[1] += offset[1];
        }
        if (!dragging) {
          if (d3.event.altKey) {
            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];
            origin[0] = xExtent[+(point[0] < center[0])];
            origin[1] = yExtent[+(point[1] < center[1])];
          } else center = null;
        }
        if (resizingX && move1(point, x, 0)) {
          redrawX(g);
          moved = true;
        }
        if (resizingY && move1(point, y, 1)) {
          redrawY(g);
          moved = true;
        }
        if (moved) {
          redraw(g);
          event_({
            type: "brush",
            mode: dragging ? "move" : "resize"
          });
        }
      }
      function move1(point, scale, i) {
        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;
        if (dragging) {
          r0 -= position;
          r1 -= size + position;
        }
        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];
        if (dragging) {
          max = (min += position) + size;
        } else {
          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));
          if (position < min) {
            max = min;
            min = position;
          } else {
            max = position;
          }
        }
        if (extent[0] != min || extent[1] != max) {
          if (i) yExtentDomain = null; else xExtentDomain = null;
          extent[0] = min;
          extent[1] = max;
          return true;
        }
      }
      function brushend() {
        brushmove();
        g.style("pointer-events", "all").selectAll(".resize").style("display", brush.empty() ? "none" : null);
        d3.select("body").style("cursor", null);
        w.on("mousemove.brush", null).on("mouseup.brush", null).on("touchmove.brush", null).on("touchend.brush", null).on("keydown.brush", null).on("keyup.brush", null);
        dragRestore();
        event_({
          type: "brushend"
        });
      }
    }
    brush.x = function(z) {
      if (!arguments.length) return x;
      x = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.y = function(z) {
      if (!arguments.length) return y;
      y = z;
      resizes = d3_svg_brushResizes[!x << 1 | !y];
      return brush;
    };
    brush.clamp = function(z) {
      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;
      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;
      return brush;
    };
    brush.extent = function(z) {
      var x0, x1, y0, y1, t;
      if (!arguments.length) {
        if (x) {
          if (xExtentDomain) {
            x0 = xExtentDomain[0], x1 = xExtentDomain[1];
          } else {
            x0 = xExtent[0], x1 = xExtent[1];
            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);
            if (x1 < x0) t = x0, x0 = x1, x1 = t;
          }
        }
        if (y) {
          if (yExtentDomain) {
            y0 = yExtentDomain[0], y1 = yExtentDomain[1];
          } else {
            y0 = yExtent[0], y1 = yExtent[1];
            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);
            if (y1 < y0) t = y0, y0 = y1, y1 = t;
          }
        }
        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];
      }
      if (x) {
        x0 = z[0], x1 = z[1];
        if (y) x0 = x0[0], x1 = x1[0];
        xExtentDomain = [ x0, x1 ];
        if (x.invert) x0 = x(x0), x1 = x(x1);
        if (x1 < x0) t = x0, x0 = x1, x1 = t;
        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];
      }
      if (y) {
        y0 = z[0], y1 = z[1];
        if (x) y0 = y0[1], y1 = y1[1];
        yExtentDomain = [ y0, y1 ];
        if (y.invert) y0 = y(y0), y1 = y(y1);
        if (y1 < y0) t = y0, y0 = y1, y1 = t;
        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];
      }
      return brush;
    };
    brush.clear = function() {
      if (!brush.empty()) {
        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];
        xExtentDomain = yExtentDomain = null;
      }
      return brush;
    };
    brush.empty = function() {
      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];
    };
    return d3.rebind(brush, event, "on");
  };
  var d3_svg_brushCursor = {
    n: "ns-resize",
    e: "ew-resize",
    s: "ns-resize",
    w: "ew-resize",
    nw: "nwse-resize",
    ne: "nesw-resize",
    se: "nwse-resize",
    sw: "nesw-resize"
  };
  var d3_svg_brushResizes = [ [ "n", "e", "s", "w", "nw", "ne", "se", "sw" ], [ "e", "w" ], [ "n", "s" ], [] ];
  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;
  var d3_time_formatUtc = d3_time_format.utc;
  var d3_time_formatIso = d3_time_formatUtc("%Y-%m-%dT%H:%M:%S.%LZ");
  d3_time_format.iso = Date.prototype.toISOString && +new Date("2000-01-01T00:00:00.000Z") ? d3_time_formatIsoNative : d3_time_formatIso;
  function d3_time_formatIsoNative(date) {
    return date.toISOString();
  }
  d3_time_formatIsoNative.parse = function(string) {
    var date = new Date(string);
    return isNaN(date) ? null : date;
  };
  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;
  d3_time.second = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 1e3) * 1e3);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 1e3);
  }, function(date) {
    return date.getSeconds();
  });
  d3_time.seconds = d3_time.second.range;
  d3_time.seconds.utc = d3_time.second.utc.range;
  d3_time.minute = d3_time_interval(function(date) {
    return new d3_date(Math.floor(date / 6e4) * 6e4);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 6e4);
  }, function(date) {
    return date.getMinutes();
  });
  d3_time.minutes = d3_time.minute.range;
  d3_time.minutes.utc = d3_time.minute.utc.range;
  d3_time.hour = d3_time_interval(function(date) {
    var timezone = date.getTimezoneOffset() / 60;
    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);
  }, function(date, offset) {
    date.setTime(date.getTime() + Math.floor(offset) * 36e5);
  }, function(date) {
    return date.getHours();
  });
  d3_time.hours = d3_time.hour.range;
  d3_time.hours.utc = d3_time.hour.utc.range;
  d3_time.month = d3_time_interval(function(date) {
    date = d3_time.day(date);
    date.setDate(1);
    return date;
  }, function(date, offset) {
    date.setMonth(date.getMonth() + offset);
  }, function(date) {
    return date.getMonth();
  });
  d3_time.months = d3_time.month.range;
  d3_time.months.utc = d3_time.month.utc.range;
  function d3_time_scale(linear, methods, format) {
    function scale(x) {
      return linear(x);
    }
    scale.invert = function(x) {
      return d3_time_scaleDate(linear.invert(x));
    };
    scale.domain = function(x) {
      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);
      linear.domain(x);
      return scale;
    };
    function tickMethod(extent, count) {
      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);
      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {
        return d / 31536e6;
      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];
    }
    scale.nice = function(interval, skip) {
      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" && tickMethod(extent, interval);
      if (method) interval = method[0], skip = method[1];
      function skipped(date) {
        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;
      }
      return scale.domain(d3_scale_nice(domain, skip > 1 ? {
        floor: function(date) {
          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);
          return date;
        },
        ceil: function(date) {
          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);
          return date;
        }
      } : interval));
    };
    scale.ticks = function(interval, skip) {
      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === "number" ? tickMethod(extent, interval) : !interval.range && [ {
        range: interval
      }, skip ];
      if (method) interval = method[0], skip = method[1];
      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);
    };
    scale.tickFormat = function() {
      return format;
    };
    scale.copy = function() {
      return d3_time_scale(linear.copy(), methods, format);
    };
    return d3_scale_linearRebind(scale, linear);
  }
  function d3_time_scaleDate(t) {
    return new Date(t);
  }
  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];
  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];
  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ ".%L", function(d) {
    return d.getMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getMinutes();
  } ], [ "%I %p", function(d) {
    return d.getHours();
  } ], [ "%a %d", function(d) {
    return d.getDay() && d.getDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getDate() != 1;
  } ], [ "%B", function(d) {
    return d.getMonth();
  } ], [ "%Y", d3_true ] ]);
  var d3_time_scaleMilliseconds = {
    range: function(start, stop, step) {
      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);
    },
    floor: d3_identity,
    ceil: d3_identity
  };
  d3_time_scaleLocalMethods.year = d3_time.year;
  d3_time.scale = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);
  };
  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {
    return [ m[0].utc, m[1] ];
  });
  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ ".%L", function(d) {
    return d.getUTCMilliseconds();
  } ], [ ":%S", function(d) {
    return d.getUTCSeconds();
  } ], [ "%I:%M", function(d) {
    return d.getUTCMinutes();
  } ], [ "%I %p", function(d) {
    return d.getUTCHours();
  } ], [ "%a %d", function(d) {
    return d.getUTCDay() && d.getUTCDate() != 1;
  } ], [ "%b %d", function(d) {
    return d.getUTCDate() != 1;
  } ], [ "%B", function(d) {
    return d.getUTCMonth();
  } ], [ "%Y", d3_true ] ]);
  d3_time_scaleUtcMethods.year = d3_time.year.utc;
  d3_time.scale.utc = function() {
    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);
  };
  d3.text = d3_xhrType(function(request) {
    return request.responseText;
  });
  d3.json = function(url, callback) {
    return d3_xhr(url, "application/json", d3_json, callback);
  };
  function d3_json(request) {
    return JSON.parse(request.responseText);
  }
  d3.html = function(url, callback) {
    return d3_xhr(url, "text/html", d3_html, callback);
  };
  function d3_html(request) {
    var range = d3_document.createRange();
    range.selectNode(d3_document.body);
    return range.createContextualFragment(request.responseText);
  }
  d3.xml = d3_xhrType(function(request) {
    return request.responseXML;
  });
  if (true) this.d3 = d3, !(__WEBPACK_AMD_DEFINE_FACTORY__ = (d3),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)); else if (typeof module === "object" && module.exports) module.exports = d3; else this.d3 = d3;
}();

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(143);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    return exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (typeof process !== 'undefined' && 'env' in process) {
    return process.env.DEBUG;
  }
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.', pluginName) : _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.', pluginName) : _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.', eventName) : _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.', registrationName) : _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;

  if (process.env.NODE_ENV !== 'production') {
    var lowerCasedName = registrationName.toLowerCase();
    EventPluginRegistry.possibleRegistrationNames[lowerCasedName] = registrationName;

    if (registrationName === 'onDoubleClick') {
      EventPluginRegistry.possibleRegistrationNames.ondblclick = registrationName;
    }
  }
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: process.env.NODE_ENV !== 'production' ? {} : null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.') : _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.', pluginName) : _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      var possibleRegistrationNames = EventPluginRegistry.possibleRegistrationNames;
      for (var lowerCasedName in possibleRegistrationNames) {
        if (possibleRegistrationNames.hasOwnProperty(lowerCasedName)) {
          delete possibleRegistrationNames[lowerCasedName];
        }
      }
    }
  }

};

module.exports = EventPluginRegistry;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var EventPluginRegistry = __webpack_require__(34);
var ReactEventEmitterMixin = __webpack_require__(195);
var ViewportMetrics = __webpack_require__(95);

var getVendorPrefixedEventName = __webpack_require__(231);
var isEventSupported = __webpack_require__(59);

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(28);
var ViewportMetrics = __webpack_require__(95);

var getEventModifierState = __webpack_require__(57);

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there is already an outstanding transaction.') : _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */



// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);
var DOMNamespaces = __webpack_require__(48);

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = __webpack_require__(55);

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {
/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(247);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  try {
    return JSON.stringify(v);
  } catch (err) {
    return '[UnexpectedJSONParseError]: ' + err.message;
  }
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    return exports.storage.debug;
  } catch(e) {}

  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
  if (typeof process !== 'undefined' && 'env' in process) {
    return process.env.DEBUG;
  }
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.latLongToVector3 = exports.getColor = exports.rando = exports.getTween = exports.debounce = exports.memoize = undefined;

var _d = __webpack_require__(32);

var _d2 = _interopRequireDefault(_d);

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// adapted from memoize.js by @philogb and @addyosmani
var memoize = exports.memoize = function memoize(fn) {
  return function () {
    var args = Array.prototype.slice.call(arguments),
        key = "",
        len = args.length,
        cur = null;

    while (len--) {
      cur = args[len];
      key += cur === Object(cur) ? JSON.stringify(cur) : cur;

      fn.memoize || (fn.memoize = {});
    }

    return key in fn.memoize ? fn.memoize[key] : fn.memoize[key] = fn.apply(this, args);
  };
};

var debounce = exports.debounce = function debounce(func, wait, immediate) {
  var timeout = void 0;

  return function () {
    var context = this,
        args = arguments,
        later = function later() {
      timeout = null;
      if (!immediate) {
        func.apply(context, args);
      }
    },
        callNow = immediate && !timeout;

    clearTimeout(timeout);

    timeout = setTimeout(later, wait);

    if (callNow) {
      func.apply(context, args);
    }
  };
};

var getTween = exports.getTween = function getTween(prop, to) {
  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;

  var node = this,
      curr = node[prop],
      interpol = _d2.default.interpolateObject(curr, to);

  return function (t) {
    node[prop].copy(interpol(t / time));
    if (t >= time) {
      return true;
    }
  };
};

/*
 * Helper function that returns a random number between the two supplied
 * numbers. 
 *
 *  @param min  :  Integer
 *  @param max  :  Integer
 */
var rando = exports.rando = function rando(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
};

/**
 * Returns a color code based on the sentiment score. Colors range
 * from red to green.
 *
 * @param     score    :    Integer
 *
 */
var getColor = exports.getColor = function getColor(score) {
  if (score < -2) {
    return 0xff0000;
  } else if (score < -1) {
    return 0xff8000;
  } else if (score < 0) {
    return 0xffff00;
  } else if (score == 0) {
    return 0xffffff;
  } else if (score > 0) {
    return 0xbfff00;
  } else if (score > 1) {
    return 0x40ff00;
  } else if (score > 2) {
    return 0x00ff00;
  }
};

/**
 * convert the positions from a lat, lon to a position on a sphere.
 *
 * @param     lat    : Number 
 * @param     lon    : Number 
 * @param     radius : Number 
 * @param     height : Number 
 *
 */
var latLongToVector3 = exports.latLongToVector3 = function latLongToVector3(lat, lon, radius, height) {
  var phi = lat * Math.PI / 180,
      theta = (lon - 180) * Math.PI / 180,
      x = -(radius + height) * Math.cos(phi) * Math.cos(theta),
      y = (radius + height) * Math.sin(phi),
      z = (radius + height) * Math.cos(phi) * Math.sin(theta);

  return new _THREE2.default.Vector3(x, y, z);
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var parser = __webpack_require__(20);
var Emitter = __webpack_require__(44);

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
  this.enablesXDR = opts.enablesXDR;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;
  this.forceNode = opts.forceNode;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;
  this.localAddress = opts.localAddress;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' === this.readyState || '' === this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function (packets) {
  if ('open' === this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function (data) {
  var packet = parser.decodePacket(data, this.socket.binaryType);
  this.onPacket(packet);
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// browser shim for xmlhttprequest module

var hasCORS = __webpack_require__(160);

module.exports = function (opts) {
  var xdomain = opts.xdomain;

  // scheme must be same when usign XDomainRequest
  // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
  var xscheme = opts.xscheme;

  // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
  // https://github.com/Automattic/engine.io-client/pull/217
  var enablesXDR = opts.enablesXDR;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  // Use XDomainRequest for IE8 if enablesXDR is true
  // because loading bar keeps flashing when using jsonp-polling
  // https://github.com/yujiosaka/socke.io-ie8-loading-example
  try {
    if ('undefined' !== typeof XDomainRequest && !xscheme && enablesXDR) {
      return new XDomainRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new global[['Active'].concat('Object').join('X')]('Microsoft.XMLHTTP');
    } catch (e) { }
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 46 */
/***/ (function(module, exports) {

/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMLazyTree = __webpack_require__(21);
var Danger = __webpack_require__(168);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstrumentation = __webpack_require__(9);

var createMicrosoftUnsafeLocalFunction = __webpack_require__(55);
var setInnerHTML = __webpack_require__(39);
var setTextContent = __webpack_require__(102);

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }

  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onHostOperation({
      instanceID: ReactDOMComponentTree.getInstanceFromNode(openingComment)._debugID,
      type: 'replace text',
      payload: stringText
    });
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;
if (process.env.NODE_ENV !== 'production') {
  dangerouslyReplaceNodeWithMarkup = function (oldChild, markup, prevInstance) {
    Danger.dangerouslyReplaceNodeWithMarkup(oldChild, markup);
    if (prevInstance._debugID !== 0) {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: prevInstance._debugID,
        type: 'replace with',
        payload: markup.toString()
      });
    } else {
      var nextInstance = ReactDOMComponentTree.getInstanceFromNode(markup.node);
      if (nextInstance._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: nextInstance._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  };
}

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    if (process.env.NODE_ENV !== 'production') {
      var parentNodeDebugID = ReactDOMComponentTree.getInstanceFromNode(parentNode)._debugID;
    }

    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'insert child',
              payload: { toIndex: update.toIndex, content: update.content.toString() }
            });
          }
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'move child',
              payload: { fromIndex: update.fromIndex, toIndex: update.toIndex }
            });
          }
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace children',
              payload: update.content.toString()
            });
          }
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'replace text',
              payload: update.content.toString()
            });
          }
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          if (process.env.NODE_ENV !== 'production') {
            ReactInstrumentation.debugTool.onHostOperation({
              instanceID: parentNodeDebugID,
              type: 'remove child',
              payload: { fromIndex: update.fromIndex }
            });
          }
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactErrorUtils = __webpack_require__(53);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.getNodeFromInstance && Injected.getInstanceFromNode, 'EventPluginUtils.injection.injectComponentTree(...): Injected ' + 'module is missing getNodeFromInstance or getInstanceFromNode.') : void 0;
    }
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(Injected && Injected.isAncestor && Injected.getLowestCommonAncestor, 'EventPluginUtils.injection.injectTreeTraversal(...): Injected ' + 'module is missing isAncestor or getLowestCommonAncestor.') : void 0;
    }
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;
if (process.env.NODE_ENV !== 'production') {
  validateEventDispatches = function (event) {
    var dispatchListeners = event._dispatchListeners;
    var dispatchInstances = event._dispatchInstances;

    var listenersIsArr = Array.isArray(dispatchListeners);
    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;

    var instancesIsArr = Array.isArray(dispatchInstances);
    var instancesLen = instancesIsArr ? dispatchInstances.length : dispatchInstances ? 1 : 0;

    process.env.NODE_ENV !== 'production' ? warning(instancesIsArr === listenersIsArr && instancesLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : void 0;
  };
}

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  if (process.env.NODE_ENV !== 'production') {
    validateEventDispatches(event);
  }
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var React = __webpack_require__(23);
var ReactPropTypesSecret = __webpack_require__(94);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use checkedLink, you probably don\'t want to use valueLink and vice versa.') : _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want to use value or onChange, you probably don\'t want to use valueLink.') : _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. If you want to use checked or onChange, you probably don\'t want to use checkedLink') : _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: React.PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

if (process.env.NODE_ENV !== 'production') {
  /**
   * To help development we can get better devtools integration by simulating a
   * real browser event.
   */
  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
    var fakeNode = document.createElement('react');
    ReactErrorUtils.invokeGuardedCallback = function (name, func, a) {
      var boundFunc = func.bind(null, a);
      var evtType = 'react-' + name;
      fakeNode.addEventListener(evtType, boundFunc, false);
      var evt = document.createEvent('Event');
      // $FlowFixMe https://github.com/facebook/flow/issues/2336
      evt.initEvent(evtType, false, false);
      fakeNode.dispatchEvent(evt);
      fakeNode.removeEventListener(evtType, boundFunc, false);
    };
  }
}

module.exports = ReactErrorUtils;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(12);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(9);
var ReactUpdates = __webpack_require__(11);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var ctor = publicInstance.constructor;
      // Only warn when we have a callerName. Otherwise we should be silent.
      // We're probably calling from enqueueCallback. We don't want to warn
      // there because we already warned for the corresponding lifecycle method.
      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, ctor && (ctor.displayName || ctor.name) || 'ReactClass') : void 0;
    }
    return null;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition (such as ' + 'within `render` or another component\'s constructor). Render methods ' + 'should be a pure function of props and state; constructor ' + 'side-effects are an anti-pattern, but can be moved to ' + '`componentWillMount`.', callerName) : void 0;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    if (process.env.NODE_ENV !== 'production') {
      var owner = ReactCurrentOwner.current;
      if (owner !== null) {
        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
        owner._warnedAboutRefsInRender = true;
      }
    }
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onSetState();
      process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : void 0;
    }

    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.', callerName, formatUnexpectedArgument(callback)) : _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

module.exports = ReactUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */



/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var emptyFunction = __webpack_require__(10);
var warning = __webpack_require__(2);

var validateDOMNesting = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  // This validation code was written based on the HTML5 parsing spec:
  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  //
  // Note: this does not catch all invalid nesting, nor does it try to (as it's
  // not clear what practical benefit doing so provides); instead, we warn only
  // for cases where the parser will give a parse tree differing from what React
  // intended. For example, <b><div></div></b> is invalid but we don't warn
  // because it still parses correctly; we do warn for other cases like nested
  // <p> tags where the beginning of the second element implicitly closes the
  // first, causing a confusing mess.

  // https://html.spec.whatwg.org/multipage/syntax.html#special
  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',

  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
  // TODO: Distinguish by namespace here -- for <title>, including it here
  // errs on the side of fewer warnings
  'foreignObject', 'desc', 'title'];

  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
  var buttonScopeTags = inScopeTags.concat(['button']);

  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];

  var emptyAncestorInfo = {
    current: null,

    formTag: null,
    aTagInScope: null,
    buttonTagInScope: null,
    nobrTagInScope: null,
    pTagInButtonScope: null,

    listItemTagAutoclosing: null,
    dlItemTagAutoclosing: null
  };

  var updatedAncestorInfo = function (oldInfo, tag, instance) {
    var ancestorInfo = _assign({}, oldInfo || emptyAncestorInfo);
    var info = { tag: tag, instance: instance };

    if (inScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.aTagInScope = null;
      ancestorInfo.buttonTagInScope = null;
      ancestorInfo.nobrTagInScope = null;
    }
    if (buttonScopeTags.indexOf(tag) !== -1) {
      ancestorInfo.pTagInButtonScope = null;
    }

    // See rules for 'li', 'dd', 'dt' start tags in
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
      ancestorInfo.listItemTagAutoclosing = null;
      ancestorInfo.dlItemTagAutoclosing = null;
    }

    ancestorInfo.current = info;

    if (tag === 'form') {
      ancestorInfo.formTag = info;
    }
    if (tag === 'a') {
      ancestorInfo.aTagInScope = info;
    }
    if (tag === 'button') {
      ancestorInfo.buttonTagInScope = info;
    }
    if (tag === 'nobr') {
      ancestorInfo.nobrTagInScope = info;
    }
    if (tag === 'p') {
      ancestorInfo.pTagInButtonScope = info;
    }
    if (tag === 'li') {
      ancestorInfo.listItemTagAutoclosing = info;
    }
    if (tag === 'dd' || tag === 'dt') {
      ancestorInfo.dlItemTagAutoclosing = info;
    }

    return ancestorInfo;
  };

  /**
   * Returns whether
   */
  var isTagValidWithParent = function (tag, parentTag) {
    // First, let's check if we're in an unusual parsing mode...
    switch (parentTag) {
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
      case 'select':
        return tag === 'option' || tag === 'optgroup' || tag === '#text';
      case 'optgroup':
        return tag === 'option' || tag === '#text';
      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
      // but
      case 'option':
        return tag === '#text';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
      // No special behavior since these rules fall back to "in body" mode for
      // all except special table nodes which cause bad parsing behavior anyway.

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
      case 'tr':
        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
      case 'tbody':
      case 'thead':
      case 'tfoot':
        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
      case 'colgroup':
        return tag === 'col' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
      case 'table':
        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
      case 'head':
        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';

      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
      case 'html':
        return tag === 'head' || tag === 'body';
      case '#document':
        return tag === 'html';
    }

    // Probably in the "in body" parsing mode, so we outlaw only tag combos
    // where the parsing rules cause implicit opens or closes to be added.
    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
    switch (tag) {
      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';

      case 'rp':
      case 'rt':
        return impliedEndTags.indexOf(parentTag) === -1;

      case 'body':
      case 'caption':
      case 'col':
      case 'colgroup':
      case 'frame':
      case 'head':
      case 'html':
      case 'tbody':
      case 'td':
      case 'tfoot':
      case 'th':
      case 'thead':
      case 'tr':
        // These tags are only valid with a few parents that have special child
        // parsing rules -- if we're down here, then none of those matched and
        // so we allow it only if we don't know what the parent is, as all other
        // cases are invalid.
        return parentTag == null;
    }

    return true;
  };

  /**
   * Returns whether
   */
  var findInvalidAncestorForTag = function (tag, ancestorInfo) {
    switch (tag) {
      case 'address':
      case 'article':
      case 'aside':
      case 'blockquote':
      case 'center':
      case 'details':
      case 'dialog':
      case 'dir':
      case 'div':
      case 'dl':
      case 'fieldset':
      case 'figcaption':
      case 'figure':
      case 'footer':
      case 'header':
      case 'hgroup':
      case 'main':
      case 'menu':
      case 'nav':
      case 'ol':
      case 'p':
      case 'section':
      case 'summary':
      case 'ul':

      case 'pre':
      case 'listing':

      case 'table':

      case 'hr':

      case 'xmp':

      case 'h1':
      case 'h2':
      case 'h3':
      case 'h4':
      case 'h5':
      case 'h6':
        return ancestorInfo.pTagInButtonScope;

      case 'form':
        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;

      case 'li':
        return ancestorInfo.listItemTagAutoclosing;

      case 'dd':
      case 'dt':
        return ancestorInfo.dlItemTagAutoclosing;

      case 'button':
        return ancestorInfo.buttonTagInScope;

      case 'a':
        // Spec says something about storing a list of markers, but it sounds
        // equivalent to this check.
        return ancestorInfo.aTagInScope;

      case 'nobr':
        return ancestorInfo.nobrTagInScope;
    }

    return null;
  };

  /**
   * Given a ReactCompositeComponent instance, return a list of its recursive
   * owners, starting at the root and ending with the instance itself.
   */
  var findOwnerStack = function (instance) {
    if (!instance) {
      return [];
    }

    var stack = [];
    do {
      stack.push(instance);
    } while (instance = instance._currentElement._owner);
    stack.reverse();
    return stack;
  };

  var didWarn = {};

  validateDOMNesting = function (childTag, childText, childInstance, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;

    if (childText != null) {
      process.env.NODE_ENV !== 'production' ? warning(childTag == null, 'validateDOMNesting: when childText is passed, childTag should be null') : void 0;
      childTag = '#text';
    }

    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
    var problematic = invalidParent || invalidAncestor;

    if (problematic) {
      var ancestorTag = problematic.tag;
      var ancestorInstance = problematic.instance;

      var childOwner = childInstance && childInstance._currentElement._owner;
      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;

      var childOwners = findOwnerStack(childOwner);
      var ancestorOwners = findOwnerStack(ancestorOwner);

      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
      var i;

      var deepestCommon = -1;
      for (i = 0; i < minStackLen; i++) {
        if (childOwners[i] === ancestorOwners[i]) {
          deepestCommon = i;
        } else {
          break;
        }
      }

      var UNKNOWN = '(unknown)';
      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
        return inst.getName() || UNKNOWN;
      });
      var ownerInfo = [].concat(
      // If the parent and child instances have a common owner ancestor, start
      // with that -- otherwise we just start with the parent's owners.
      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
      // If we're warning about an invalid (non-parent) ancestry, add '...'
      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');

      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
      if (didWarn[warnKey]) {
        return;
      }
      didWarn[warnKey] = true;

      var tagDisplayName = childTag;
      var whitespaceInfo = '';
      if (childTag === '#text') {
        if (/\S/.test(childText)) {
          tagDisplayName = 'Text nodes';
        } else {
          tagDisplayName = 'Whitespace text nodes';
          whitespaceInfo = ' Make sure you don\'t have any extra whitespace between tags on ' + 'each line of your source code.';
        }
      } else {
        tagDisplayName = '<' + childTag + '>';
      }

      if (invalidParent) {
        var info = '';
        if (ancestorTag === 'table' && childTag === 'tr') {
          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
        }
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s ' + 'See %s.%s', tagDisplayName, ancestorTag, whitespaceInfo, ownerInfo, info) : void 0;
      } else {
        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): %s cannot appear as a descendant of ' + '<%s>. See %s.', tagDisplayName, ancestorTag, ownerInfo) : void 0;
      }
    }
  };

  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;

  // For testing
  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
    ancestorInfo = ancestorInfo || emptyAncestorInfo;
    var parentInfo = ancestorInfo.current;
    var parentTag = parentInfo && parentInfo.tag;
    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
  };
}

module.exports = validateDOMNesting;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(19);

var ReactNoopUpdateQueue = __webpack_require__(63);

var canDefineProperty = __webpack_require__(65);
var emptyObject = __webpack_require__(24);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

/**
 * Deprecated APIs. These APIs used to exist on classic React classes but since
 * we would like to deprecate them, we're not going to move them over to this
 * modern base class. Instead, we define a getter that warns if it's accessed.
 */
if (process.env.NODE_ENV !== 'production') {
  var deprecatedAPIs = {
    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
  };
  var defineDeprecationWarning = function (methodName, info) {
    if (canDefineProperty) {
      Object.defineProperty(ReactComponent.prototype, methodName, {
        get: function () {
          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : void 0;
          return undefined;
        }
      });
    }
  };
  for (var fnName in deprecatedAPIs) {
    if (deprecatedAPIs.hasOwnProperty(fnName)) {
      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
    }
  }
}

module.exports = ReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var canDefineProperty = false;
if (process.env.NODE_ENV !== 'production') {
  try {
    // $FlowFixMe https://github.com/facebook/flow/issues/285
    Object.defineProperty({}, 'x', { get: function () {} });
    canDefineProperty = true;
  } catch (x) {
    // IE will fail on defineProperty
  }
}

module.exports = canDefineProperty;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var debug = __webpack_require__(249)('socket.io-parser');
var json = __webpack_require__(161);
var Emitter = __webpack_require__(134);
var binary = __webpack_require__(248);
var isBuf = __webpack_require__(111);

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 4;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'ACK',
  'ERROR',
  'BINARY_EVENT',
  'BINARY_ACK'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

/**
 * Encoder constructor.
 *
 * @api public
 */

exports.Encoder = Encoder;

/**
 * Decoder constructor.
 *
 * @api public
 */

exports.Decoder = Decoder;

/**
 * A socket.io Encoder instance
 *
 * @api public
 */

function Encoder() {}

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments === 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if (isBuf(obj) || obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
};

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    var buf = '';
    while (str.charAt(++i) != '-') {
      buf += str.charAt(i);
      if (i == str.length) break;
    }
    if (buf != Number(buf) || str.charAt(i) != '-') {
      throw new Error('Illegal attachments');
    }
    p.attachments = Number(buf);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' !== next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    p = tryParse(p, str.substr(i));
  }

  debug('decoded %s as %j', str, p);
  return p;
}

function tryParse(p, str) {
  try {
    p.data = json.parse(str);
  } catch(e){
    return error();
  }
  return p; 
};

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
};

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
};

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
};

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}


/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__reverse__ = __webpack_require__(263);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__transform__ = __webpack_require__(69);
/* unused harmony export feature */
/* harmony export (immutable) */ __webpack_exports__["b"] = object;



/* harmony default export */ __webpack_exports__["a"] = function(topology, o) {
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
};

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__transform__["a" /* default */])(topology),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k].slice(), k));
    }
    if (i < 0) __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__reverse__["a" /* default */])(points, n);
  }

  function point(p) {
    return transformPoint(p.slice());
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0].slice());
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0].slice());
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity__ = __webpack_require__(113);


/* harmony default export */ __webpack_exports__["a"] = function(topology) {
  if ((transform = topology.transform) == null) return __WEBPACK_IMPORTED_MODULE_0__identity__["a" /* default */];
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    point[0] = (x0 += point[0]) * kx + dx;
    point[1] = (y0 += point[1]) * ky + dy;
    return point;
  };
};


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tweets = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(82);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _scene = __webpack_require__(29);

var _setEvents = __webpack_require__(122);

var _geoHelpers = __webpack_require__(120);

var _mapTexture = __webpack_require__(121);

var _utils = __webpack_require__(41);

var _tweens = __webpack_require__(30);

var _createEarth = __webpack_require__(128);

var _createPoint = __webpack_require__(130);

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _d = __webpack_require__(32);

var _d2 = _interopRequireDefault(_d);

var _topojsonClient = __webpack_require__(257);

var topojson = _interopRequireWildcard(_topojsonClient);

var _CountryInformation = __webpack_require__(125);

var _CountryInformation2 = _interopRequireDefault(_CountryInformation);

var _CountryName = __webpack_require__(71);

var _CountryName2 = _interopRequireDefault(_CountryName);

var _BackButton = __webpack_require__(123);

var _BackButton2 = _interopRequireDefault(_BackButton);

var _TweetBox = __webpack_require__(126);

var _TweetBox2 = _interopRequireDefault(_TweetBox);

var _TweetCount = __webpack_require__(127);

var _TweetCount2 = _interopRequireDefault(_TweetCount);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OrbitControls = __webpack_require__(255)(_THREE2.default),
    io = __webpack_require__(245),
    TWEEN = __webpack_require__(265),
    geo = void 0,
    controls = void 0,
    countries = void 0,
    overlay = void 0,
    textureCache = void 0,
    earth = void 0,
    cloud = void 0,
    root = new _THREE2.default.Object3D(),
    points = new _THREE2.default.Object3D(),
    clock = new _THREE2.default.Clock();

var segments = 200,
    // number of vertices. Higher = better mouse accuracy
RADIUS = 400;

var tweets = exports.tweets = [];

var App = function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.state = {
      countryName: "",
      countryFlag: "us",
      countryCapital: "",
      countryPopulation: "",
      countrySize: "",
      countryLanguages: "",
      numTweets: 0,
      numCountryTweets: 0,
      isPointHovered: false,
      isCountryClicked: false,
      tweetImage: "src/images/clouds.png",
      tweetName: "",
      tweetText: ""
    };

    _this.timer = null;
    _this.socket = null;
    _this.globeMutex = true;
    _this.countryData = null;
    _this.sphere = new _THREE2.default.SphereGeometry(RADIUS, segments, segments);
    _this.mouseCoordinates = { x: 0, y: 0 };
    _this.lastPoint = {};
    _this.animate = _this.animate.bind(_this);
    _this.initFeed = _this.initFeed.bind(_this);
    _this.onGlobeClick = _this.onGlobeClick.bind(_this);
    _this.onGlobeMouseDown = _this.onGlobeMouseDown.bind(_this);
    _this.onGlobeMousemove = _this.onGlobeMousemove.bind(_this);
    return _this;
  }

  /**
   * Initializer function to set up our scene and all elements within it.
   */


  _createClass(App, [{
    key: 'init',
    value: function init() {
      this.animate();
      this.loadMap();
    }

    /**
     * Creates the socket connection with the server, and uses the data that
     * is sent over to create the map points, text display, etc..
     */

  }, {
    key: 'initFeed',
    value: function initFeed() {
      var self = this;

      this.socket = io.connect();

      // when a new tweet comes in, add it to our array
      this.socket.on('tweet', function (data) {

        if (!self.state.isCountryClicked) {
          tweets.push(data);
        } else {
          self.setState({ numCountryTweets: self.state.numCountryTweets + 1 });
        }
      });

      // add the group of points to the root object so it will rotate with the globe.
      root.add(points);

      // add the latest tweet to the globe every so often.
      this.timer = setInterval(self.addTweet.bind(self), 500);
    }

    /**
     * Adds the next tweet in line to the globe. Called on an interval
     * so that the globe isn't overloaded with tweets/points.
     */

  }, {
    key: 'addTweet',
    value: function addTweet() {
      // Make sure we have some tweets to work with, and a country isn't in view.
      if (tweets[this.state.numTweets] && !this.state.isCountryClicked) {
        var tweet = tweets[this.state.numTweets],
            tweetId = tweet['twid'],
            text = tweet['body'],
            coordinates = tweet['coordinates']['coordinates'],
            avatarURL = tweet['avatar'],
            screenName = tweet['screenName'],
            sentiment = tweet['sentiment'],
            color = (0, _utils.getColor)(sentiment.score);

        this.setState({ numTweets: this.state.numTweets + 1 });

        // create the point and add it to our list group of points
        (0, _createPoint.createPoint)(coordinates[1], coordinates[0], RADIUS, 10, 20, color, points, TWEEN);

        // if there are enough tweets, move the oldest one off
        if (this.state.numTweets > 50) points.children.shift();
      }
    }

    /**
     * Used to load in the data that generates the main map/globe.
     */

  }, {
    key: 'loadMap',
    value: function loadMap() {

      root.scale.set(0.1, 0.1, 0.1);

      var self = this,
          globe = (0, _createEarth.createEarth)(this.sphere, root, TWEEN, this.initFeed);

      _d2.default.json('src/json/world.json', function (err, data) {

        // Setup cache for country textures
        countries = topojson.feature(data, data.objects.countries);
        geo = (0, _geoHelpers.geodecoder)(countries.features);
        earth = globe.earth;
        cloud = globe.cloud;

        textureCache = (0, _utils.memoize)(function (cntryID, color) {
          var country = geo.find(cntryID);
          return (0, _mapTexture.mapTexture)(country, color);
        });

        var worldTexture = (0, _mapTexture.mapTexture)(countries, '#transparent', 'transparent'),
            worldTextureBack = (0, _mapTexture.mapTexture)(countries, '#000', 'transparent');

        var mapMaterialBack = new _THREE2.default.MeshPhongMaterial({
          depthWrite: false,
          map: worldTextureBack,
          side: _THREE2.default.BackSide,
          transparent: true
        });

        var mapMaterialFront = new _THREE2.default.MeshPhongMaterial({
          depthWrite: false,
          map: worldTexture,
          opacity: 0.6,
          transparent: true
        });

        var baseMapBack = new _THREE2.default.Mesh(self.sphere, mapMaterialBack),
            baseMapFront = new _THREE2.default.Mesh(self.sphere, mapMaterialFront);

        baseMapFront.addEventListener('mousedown', self.onGlobeMouseDown, false);
        baseMapFront.addEventListener('mouseup', self.onGlobeClick, false);
        baseMapFront.addEventListener('mousemove', self.onGlobeMousemove, false);
        baseMapFront.receiveShadow = true;
        baseMapFront.name = "front-map";
        baseMapBack.name = "back-map";
        // baseMapBack.rotation.y     = Math.PI;
        // baseMapFront.rotation.y    = Math.PI;

        // set the earth image to be above the colored globe
        earth.renderOrder = 1;

        root.rotation.y = Math.PI;

        // make sure the back is added to the root/scene first
        root.add(earth);
        root.add(cloud);
        root.add(baseMapBack);
        root.add(baseMapFront);

        _scene.scene.add(root);

        controls = new OrbitControls(_scene.camera, _scene.renderer.domElement);

        // Setup the event listeners for the events on the globe.
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mousedown', null);
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mouseup', null);
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mousemove', 10, null, null, self.onCountryHoverOff.bind(self));
        (0, _setEvents.setEvents)(_scene.camera, points.children, 'mousemove', 5, TWEEN, self.onPointHover.bind(self), self.onPointHoverOff.bind(self));
      });

      // Load in the country data for later..
      _d2.default.json('src/json/countries.json', function (err, data) {
        if (err) throw err;

        self.countryData = data;
      });
    }

    /**
     * Used to load in the country data (Name, Languages, Population, flag, etc);
     *
     * @param     country     :     String
     *
     */

  }, {
    key: 'setCountryData',
    value: function setCountryData(country) {
      var countryInfo = this.countryData[country];

      this.setCountryImage(countryInfo["countryCode"].toLowerCase());

      // Let the server know a country was clicked.
      this.socket.emit("countryChange", countryInfo);

      this.setState({
        countryFlag: countryInfo["countryCode"].toLowerCase(),
        countryCapital: countryInfo["capital"],
        countryPopulation: countryInfo["population"],
        countrySize: countryInfo["areaInSqKm"],
        countryLanguages: countryInfo["languages"]
      });
    }

    /**
     * Sets the globe material to the flag of the clicked country.
     *
     * @param     countryCode     :     String
     *
     */

  }, {
    key: 'setCountryImage',
    value: function setCountryImage(countryCode) {
      var loader = new _THREE2.default.TextureLoader();

      _scene.scene.getObjectByName("cloud").material.map = loader.load("src/images/flags/" + countryCode + ".png");

      _scene.scene.getObjectByName("cloud").rotation.y = -Math.PI / 2;
    }
  }, {
    key: 'setCountryImageBack',
    value: function setCountryImageBack() {
      var loader = new _THREE2.default.TextureLoader();

      _scene.scene.getObjectByName("cloud").material.map = loader.load("src/images/clouds.png");
    }

    /*
     * Used to compute which point was hovered over and extract
     * the information from the corresponding tweet.
     *
     * @param     obj    :    THREE.Mesh
     * @param     mouse  :    Object
     *
     */

  }, {
    key: 'onPointHover',
    value: function onPointHover(obj, mouse) {
      var index = _createPoint.pointList.indexOf(obj),
          tweet = tweets[index];

      this.mouseCoordinates = mouse;

      // Don't show the tweets when we're in the country view mode.
      if (!this.state.isCountryClicked) {
        this.setState({
          isPointHovered: true,
          tweetImage: tweet["avatar"],
          tweetName: tweet["author"],
          tweetText: tweet["body"]
        }, this.onCountryHoverOff());
      }
    }

    /**
     * Called once a point is hovered off of. Sets the state and the object's
     * material back to what it was before.
     */

  }, {
    key: 'onPointHoverOff',
    value: function onPointHoverOff() {
      this.setState({ isPointHovered: false });
    }

    /**
     * Called when a country is clicked on. Handles moving the globe,
     * removing the points, and setting the state.
     *
     * @param     country    :    String (name of the clicked country)
     *
     */

  }, {
    key: 'onCountryClick',
    value: function onCountryClick(country) {
      root.remove(points);

      // Set the styles back to the default state.
      document.getElementById("wrapper").classList = "active";
      document.body.style.cursor = "auto";

      this.setState({
        isPointHovered: false,
        isCountryClicked: true,
        countryName: country
      }, this.setCountryData(country));
    }

    /**
     * Handles the act of hovering on a country. Sets that country's name
     * and updates the material to show it.
     */

  }, {
    key: 'onCountryHover',
    value: function onCountryHover(country) {
      document.body.style.cursor = "pointer";

      this.setState({ countryName: country });

      if (_scene.scene.getObjectByName('earth').material.opacity > 0.6) {
        overlay.material.opacity = 1;
        (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('earth'), 0.6, 200);
        (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('back-map'), 0.4, 200);
      }
    }

    /**
     * Handles hovering off a country. Sets the materials back.
     */

  }, {
    key: 'onCountryHoverOff',
    value: function onCountryHoverOff() {
      if (!this.state.isCountryClicked) {
        console.log("hovered off country");
        document.body.style.cursor = "auto";

        this.setState({ countryName: "" });

        if (_scene.scene.getObjectByName('earth').material.opacity < 0.99) {
          overlay.material.opacity = 0;
          (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('earth'), 0.99, 200);
          (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('back-map'), 1, 200);
        }
      }
    }

    /**
     * Called when the back button is clicked in the country view. Used
     * to reset the state to its original settings.
     */

  }, {
    key: 'onBackButtonClick',
    value: function onBackButtonClick() {
      root.add(points);

      document.getElementById("wrapper").classList = "";

      // Set the cloud image back.
      this.setCountryImageBack();

      // Let the server know a country was clicked.
      this.socket.emit("countryChangeBack");

      this.setState({
        isCountryClicked: false,
        countryName: "",
        numCountryTweets: 0
      });
    }

    /**
     * Called when the mouse is pressed on the globe. Sets the values
     * used to determine if the user moved the globe. 
     *
     * @param    event    :    Object
     *
     */

  }, {
    key: 'onGlobeMouseDown',
    value: function onGlobeMouseDown(event) {
      this.lastPoint = parseInt(event.distance, 10);
    }

    /**
     * Checks to see if the mouse moved during a click. Compares the mouse down
     * location with the mouse up location to see.
     *
     * @param    event    :    Object
     *
     */

  }, {
    key: 'isStaticClick',
    value: function isStaticClick(event) {
      return parseInt(event.distance, 10) === this.lastPoint;
    }

    /**
     * Called when the globe is clicked on. Rotates the camera to face the
     * globe and moves its position.
     */

  }, {
    key: 'onGlobeClick',
    value: function onGlobeClick(event) {
      // Get point, convert to latitude/longitude
      var latlng = _geoHelpers.getEventCenter.call(this.sphere, event),
          country = geo.search(latlng[0], latlng[1]),
          isStatic = this.isStaticClick(event);

      // Don't do anything when a country or point is in view, or if a drag occurred.
      if (!this.state.isCountryClicked && !this.state.isPointHovered && isStatic) {
        // Make sure a country is clicked on
        if (country) {
          this.onCountryClick(country.code);
        }

        // Get new camera position
        var temp = new _THREE2.default.Mesh();
        temp.position.copy((0, _geoHelpers.convertToXYZ)(latlng, 900));
        temp.lookAt(root.position);
        temp.rotateY(Math.PI);

        // Computes the temporary rotation needed to get the country in view
        for (var key in temp.rotation) {
          if (temp.rotation[key] - _scene.camera.rotation[key] > Math.PI) {
            temp.rotation[key] -= Math.PI * 2;
          } else if (_scene.camera.rotation[key] - temp.rotation[key] > Math.PI) {
            temp.rotation[key] += Math.PI * 2;
          }
        }

        // Move the camera to the right location in front of the clicked country.
        var tweenPos = _utils.getTween.call(_scene.camera, 'position', temp.position);
        _d2.default.timer(tweenPos);

        // Rotate the camera after as it moves to face the globe.
        var tweenRot = _utils.getTween.call(_scene.camera, 'rotation', temp.rotation);
        _d2.default.timer(tweenRot);

        // Set the earth's rotation back to 0 so the correct country is in view.
        var tweenRootRot = _utils.getTween.call(root, 'rotation', new _THREE2.default.Euler(0, Math.PI, 0));
        _d2.default.timer(tweenRootRot);
      }
    }

    /**
     * Creates and overlays a map with the hovered country highlighted.
     * Called when the map/globe is hovered on.
     */

  }, {
    key: 'onGlobeMousemove',
    value: function onGlobeMousemove(event) {
      var map = void 0,
          material = void 0,
          latlng = _geoHelpers.getEventCenter.call(this.sphere, event),
          country = geo.search(latlng[0], latlng[1]);

      // Make sure a country, is hovered on and we are not in the country view.
      if (country && !this.state.isCountryClicked && !this.state.isPointHovered) {

        // Only run this if we have the mutex or we moved to a different country.
        if (country.code !== this.state.countryName || this.globeMutex) {

          this.globeMutex = false;

          // Overlay the selected country
          map = textureCache(country.code, 'rgba(0,0,0,0.9)');

          material = new _THREE2.default.MeshPhongMaterial({
            depthWrite: false,
            map: map,
            transparent: true
          });

          // Only add the overlay if it's not there already. Duh..
          if (!overlay) {
            overlay = new _THREE2.default.Mesh(this.sphere, material);
            overlay.renderOrder = 2;
            overlay.name = "overlay";
            root.add(overlay);
          } else {
            overlay.material = material;
          }

          this.onCountryHover(country.code);
        }
      } else {

        if (!this.globeMutex) {
          this.globeMutex = true;
          // Set the pointer back if we aren't on a country
          this.onCountryHoverOff();
        }
      }
    }

    /**
     * Loop used for rendering and updating values
     */

  }, {
    key: 'animate',
    value: function animate() {
      _scene.renderer.render(_scene.scene, _scene.camera);
      this.update();

      requestAnimationFrame(this.animate);
    }

    /**
     * Called by the animation function about 60 times per second. Updates any
     * values that are used for animation or control.
     */

  }, {
    key: 'update',
    value: function update() {
      if (controls && !this.state.isPointHovered) controls.update();

      if (cloud && !this.state.isPointHovered) cloud.rotation.y += 0.000625;

      if (root && !this.state.isPointHovered && !this.state.isCountryClicked) root.rotation.y += 0.0005;

      // update and transitions on existing tweens
      TWEEN.update();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.init();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      // remove the interval to avoid any leaks
      clearInterval(this.timer);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'main',
        { className: 'body' },
        _react2.default.createElement(_BackButton2.default, {
          isCountryClicked: this.state.isCountryClicked,
          onButtonClick: this.onBackButtonClick.bind(this) }),
        _react2.default.createElement(_CountryName2.default, { countryName: this.state.countryName }),
        _react2.default.createElement(_CountryInformation2.default, {
          countryName: this.state.countryName,
          countryFlag: this.state.countryFlag,
          countryCapital: this.state.countryCapital,
          countryPopulation: this.state.countryPopulation,
          countrySize: this.state.countrySize,
          countryLanguages: this.state.countryLanguages,
          numCountryTweets: this.state.numCountryTweets }),
        _react2.default.createElement(_TweetCount2.default, { numTweets: this.state.numTweets }),
        _react2.default.createElement(_TweetBox2.default, {
          isPointHovered: this.state.isPointHovered,
          mouseCoordinates: this.mouseCoordinates,
          image: this.state.tweetImage,
          name: this.state.tweetName,
          text: this.state.tweetText })
      );
    }
  }]);

  return App;
}(_react.Component);

exports.default = App;

/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CountryName = function (_Component) {
  _inherits(CountryName, _Component);

  function CountryName() {
    _classCallCheck(this, CountryName);

    return _possibleConstructorReturn(this, (CountryName.__proto__ || Object.getPrototypeOf(CountryName)).apply(this, arguments));
  }

  _createClass(CountryName, [{
    key: "render",
    value: function render() {
      return _react2.default.createElement(
        "aside",
        {
          className: "country--name" + (this.props.countryName ? " visible" : ""),
          "data-text": this.props.countryName ? this.props.countryName.toUpperCase() : "" },
        this.props.countryName
      );
    }
  }]);

  return CountryName;
}(_react.Component);

exports.default = CountryName;

/***/ }),
/* 72 */
/***/ (function(module, exports) {

/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};


/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies
 */

var XMLHttpRequest = __webpack_require__(43);
var XHR = __webpack_require__(141);
var JSONP = __webpack_require__(140);
var websocket = __webpack_require__(142);

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling (opts) {
  var xhr;
  var xd = false;
  var xs = false;
  var jsonp = false !== opts.jsonp;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname !== location.hostname || port !== opts.port;
    xs = opts.secure !== isSSL;
  }

  opts.xdomain = xd;
  opts.xscheme = xs;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    if (!jsonp) throw new Error('JSONP disabled');
    return new JSONP(opts);
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Module dependencies.
 */

var Transport = __webpack_require__(42);
var parseqs = __webpack_require__(46);
var parser = __webpack_require__(20);
var inherit = __webpack_require__(31);
var yeast = __webpack_require__(116);
var debug = __webpack_require__(33)('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function () {
  var XMLHttpRequest = __webpack_require__(43);
  var xhr = new XMLHttpRequest({ xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function () {
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function (onPause) {
  var self = this;

  this.readyState = 'pausing';

  function pause () {
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function () {
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function () {
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function () {
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function (data) {
  var self = this;
  debug('polling got data %s', data);
  var callback = function (packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' === self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' === packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' !== this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' === this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function () {
  var self = this;

  function close () {
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' === this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function (packets) {
  var self = this;
  this.writable = false;
  var callbackfn = function () {
    self.writable = true;
    self.emit('drain');
  };

  parser.encodePayload(packets, this.supportsBinary, function (data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' === schema && Number(this.port) !== 443) ||
     ('http' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};


/***/ }),
/* 75 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(10);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/*
 * Module requirements.
 */

var isArray = __webpack_require__(159);

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function _hasBinary(obj) {
    if (!obj) return false;

    if ( (global.Buffer && global.Buffer.isBuffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (_hasBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      // see: https://github.com/Automattic/has-binary/pull/4
      if (obj.toJSON && 'function' == typeof obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && _hasBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return _hasBinary(data);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 79 */
/***/ (function(module, exports) {


var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};

/***/ }),
/* 80 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}


/***/ }),
/* 81 */
/***/ (function(module, exports) {

/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
    var src = str,
        b = str.indexOf('['),
        e = str.indexOf(']');

    if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);
    }

    var m = re.exec(str || ''),
        uri = {},
        i = 14;

    while (i--) {
        uri[parts[i]] = m[i] || '';
    }

    if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');
        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');
        uri.ipv6uri = true;
    }

    return uri;
};


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(176);


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;

/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = __webpack_require__(17);

var invariant = __webpack_require__(1);

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(15);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstrumentation = __webpack_require__(9);

var quoteAttributeValueForBrowser = __webpack_require__(232);
var warning = __webpack_require__(2);

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }

    if (process.env.NODE_ENV !== 'production') {
      var payload = {};
      payload[name] = value;
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'update attribute',
        payload: payload
      });
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }

    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: ReactDOMComponentTree.getInstanceFromNode(node)._debugID,
        type: 'remove attribute',
        payload: name
      });
    }
  }

};

module.exports = DOMPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;

/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var LinkedValueUtils = __webpack_require__(51);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(11);

var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `select` is deprecated; set `value` and `onChange` instead.') : void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    } else if (!props.multiple && isArray) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      checkSelectPropTypes(inst, props);
    }

    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Select elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled select ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;

/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;

/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

var genericComponentClass = null;
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMSelection = __webpack_require__(186);

var containsNode = __webpack_require__(147);
var focusNode = __webpack_require__(76);
var getActiveElement = __webpack_require__(77);

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;

/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(21);
var DOMProperty = __webpack_require__(15);
var React = __webpack_require__(23);
var ReactBrowserEventEmitter = __webpack_require__(35);
var ReactCurrentOwner = __webpack_require__(12);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMContainerInfo = __webpack_require__(178);
var ReactDOMFeatureFlags = __webpack_require__(180);
var ReactFeatureFlags = __webpack_require__(89);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(9);
var ReactMarkupChecksum = __webpack_require__(200);
var ReactReconciler = __webpack_require__(22);
var ReactUpdateQueue = __webpack_require__(54);
var ReactUpdates = __webpack_require__(11);

var emptyObject = __webpack_require__(24);
var instantiateReactComponent = __webpack_require__(100);
var invariant = __webpack_require__(1);
var setInnerHTML = __webpack_require__(39);
var shouldUpdateReactComponent = __webpack_require__(60);
var warning = __webpack_require__(2);

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onBeginFlush();
  }
  ReactReconciler.unmountComponent(instance, safely);
  if (process.env.NODE_ENV !== 'production') {
    ReactInstrumentation.debugTool.onEndFlush();
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
if (process.env.NODE_ENV !== 'production') {
  TopLevelWrapper.displayName = 'TopLevelWrapper';
}
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' :
    // Check if it quacks like an element
    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : void 0;

      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
        var rootElementSibling = reactRootElement;
        while (rootElementSibling) {
          if (internalGetID(rootElementSibling)) {
            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : void 0;
            break;
          }
          rootElementSibling = rootElementSibling.nextSibling;
        }
      }
    }

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : void 0;

    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : _prodInvariant('40') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!nodeIsRenderedByOtherInstance(container), 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by another copy of React.') : void 0;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : void 0;
      }

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;
        if (process.env.NODE_ENV !== 'production') {
          // because rootMarkup is retrieved from the DOM, various normalizations
          // will have occurred which will not be present in `markup`. Here,
          // insert markup into a <div> or <iframe> depending on the container
          // type to perform the same normalizations before comparing.
          var normalizer;
          if (container.nodeType === ELEMENT_NODE_TYPE) {
            normalizer = document.createElement('div');
            normalizer.innerHTML = markup;
            normalizedMarkup = normalizer.innerHTML;
          } else {
            normalizer = document.createElement('iframe');
            document.body.appendChild(normalizer);
            normalizer.contentDocument.write(markup);
            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
            document.body.removeChild(normalizer);
          }
        }

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s', difference) : _prodInvariant('42', difference) : void 0;

        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : void 0;
        }
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but you didn\'t use server rendering. We can\'t do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }

    if (process.env.NODE_ENV !== 'production') {
      var hostNode = ReactDOMComponentTree.getInstanceFromNode(container.firstChild);
      if (hostNode._debugID !== 0) {
        ReactInstrumentation.debugTool.onHostOperation({
          instanceID: hostNode._debugID,
          type: 'mount',
          payload: markup.toString()
        });
      }
    }
  }
};

module.exports = ReactMount;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var React = __webpack_require__(23);

var invariant = __webpack_require__(1);

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Unexpected node: %s', node) : _prodInvariant('26', node) : void 0;
  }
};

module.exports = ReactNodeTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;

/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactNodeTypes = __webpack_require__(93);

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;

/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var ReactCompositeComponent = __webpack_require__(175);
var ReactEmptyComponent = __webpack_require__(88);
var ReactHostComponent = __webpack_require__(90);

var getNextDebugID = __webpack_require__(229);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    var type = element.type;
    if (typeof type !== 'function' && typeof type !== 'string') {
      var info = '';
      if (process.env.NODE_ENV !== 'production') {
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
      }
      info += getDeclarationErrorAddendum(element._owner);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s', type == null ? type : typeof type, info) : _prodInvariant('130', type == null ? type : typeof type, info) : void 0;
    }

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node) : _prodInvariant('131', typeof node) : void 0;
  }

  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.getHostNode === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : void 0;
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  if (process.env.NODE_ENV !== 'production') {
    instance._debugID = shouldHaveDebugID ? getNextDebugID() : 0;
  }

  // Internal instances should fully constructed at this point, so they should
  // not get any new fields added to them at this point.
  if (process.env.NODE_ENV !== 'production') {
    if (Object.preventExtensions) {
      Object.preventExtensions(instance);
    }
  }

  return instance;
}

module.exports = instantiateReactComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);
var escapeTextContentForBrowser = __webpack_require__(38);
var setInnerHTML = __webpack_require__(39);

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;

/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(12);
var REACT_ELEMENT_TYPE = __webpack_require__(194);

var getIteratorFn = __webpack_require__(228);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(50);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/**
 * ReactElementValidator provides a wrapper around a element factory
 * which validates the props passed to the element. This is intended to be
 * used only in DEV and could be replaced by a static type checker for languages
 * that support it.
 */



var ReactCurrentOwner = __webpack_require__(12);
var ReactComponentTreeHook = __webpack_require__(8);
var ReactElement = __webpack_require__(18);

var checkReactTypeSpec = __webpack_require__(242);

var canDefineProperty = __webpack_require__(65);
var getIteratorFn = __webpack_require__(66);
var warning = __webpack_require__(2);

function getDeclarationErrorAddendum() {
  if (ReactCurrentOwner.current) {
    var name = ReactCurrentOwner.current.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Warn if there's no key explicitly set on dynamic arrays of children or
 * object keys are not valid. This allows us to keep track of children between
 * updates.
 */
var ownerHasKeyUseWarning = {};

function getCurrentComponentErrorInfo(parentType) {
  var info = getDeclarationErrorAddendum();

  if (!info) {
    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
    if (parentName) {
      info = ' Check the top-level render call using <' + parentName + '>.';
    }
  }
  return info;
}

/**
 * Warn if the element doesn't have an explicit key assigned to it.
 * This element is in an array. The array could grow and shrink or be
 * reordered. All children that haven't already been validated are required to
 * have a "key" property assigned to it. Error statuses are cached so a warning
 * will only be shown once.
 *
 * @internal
 * @param {ReactElement} element Element that requires a key.
 * @param {*} parentType element's parent's type.
 */
function validateExplicitKey(element, parentType) {
  if (!element._store || element._store.validated || element.key != null) {
    return;
  }
  element._store.validated = true;

  var memoizer = ownerHasKeyUseWarning.uniqueKey || (ownerHasKeyUseWarning.uniqueKey = {});

  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
  if (memoizer[currentComponentErrorInfo]) {
    return;
  }
  memoizer[currentComponentErrorInfo] = true;

  // Usually the current owner is the offender, but if it accepts children as a
  // property, it may be the creator of the child that's responsible for
  // assigning it a key.
  var childOwner = '';
  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
    // Give the component that originally created this child.
    childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
  }

  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, ReactComponentTreeHook.getCurrentStackAddendum(element)) : void 0;
}

/**
 * Ensure that every element either is passed in a static location, in an
 * array with an explicit keys property defined, or in an object literal
 * with valid key property.
 *
 * @internal
 * @param {ReactNode} node Statically passed child of any type.
 * @param {*} parentType node's parent's type.
 */
function validateChildKeys(node, parentType) {
  if (typeof node !== 'object') {
    return;
  }
  if (Array.isArray(node)) {
    for (var i = 0; i < node.length; i++) {
      var child = node[i];
      if (ReactElement.isValidElement(child)) {
        validateExplicitKey(child, parentType);
      }
    }
  } else if (ReactElement.isValidElement(node)) {
    // This element was passed in a valid location.
    if (node._store) {
      node._store.validated = true;
    }
  } else if (node) {
    var iteratorFn = getIteratorFn(node);
    // Entry iterators provide implicit keys.
    if (iteratorFn) {
      if (iteratorFn !== node.entries) {
        var iterator = iteratorFn.call(node);
        var step;
        while (!(step = iterator.next()).done) {
          if (ReactElement.isValidElement(step.value)) {
            validateExplicitKey(step.value, parentType);
          }
        }
      }
    }
  }
}

/**
 * Given an element, validate that its props follow the propTypes definition,
 * provided by the type.
 *
 * @param {ReactElement} element
 */
function validatePropTypes(element) {
  var componentClass = element.type;
  if (typeof componentClass !== 'function') {
    return;
  }
  var name = componentClass.displayName || componentClass.name;
  if (componentClass.propTypes) {
    checkReactTypeSpec(componentClass.propTypes, element.props, 'prop', name, element, null);
  }
  if (typeof componentClass.getDefaultProps === 'function') {
    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : void 0;
  }
}

var ReactElementValidator = {

  createElement: function (type, props, children) {
    var validType = typeof type === 'string' || typeof type === 'function';
    // We warn in this case but don't throw. We expect the element creation to
    // succeed and there will likely be errors in render.
    if (!validType) {
      if (typeof type !== 'function' && typeof type !== 'string') {
        var info = '';
        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + 'it\'s defined in.';
        }
        info += getDeclarationErrorAddendum();
        process.env.NODE_ENV !== 'production' ? warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info) : void 0;
      }
    }

    var element = ReactElement.createElement.apply(this, arguments);

    // The result can be nullish if a mock or a custom function is used.
    // TODO: Drop this when these are no longer allowed as the type argument.
    if (element == null) {
      return element;
    }

    // Skip key warning if the type isn't valid since our key validation logic
    // doesn't expect a non-string/function type and can throw confusing errors.
    // We don't want exception behavior to differ between dev and prod.
    // (Rendering will throw with a helpful message and as soon as the type is
    // fixed, the key warnings will appear.)
    if (validType) {
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], type);
      }
    }

    validatePropTypes(element);

    return element;
  },

  createFactory: function (type) {
    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
    // Legacy hook TODO: Warn if this is accessed
    validatedFactory.type = type;

    if (process.env.NODE_ENV !== 'production') {
      if (canDefineProperty) {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : void 0;
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
    }

    return validatedFactory;
  },

  cloneElement: function (element, props, children) {
    var newElement = ReactElement.cloneElement.apply(this, arguments);
    for (var i = 2; i < arguments.length; i++) {
      validateChildKeys(arguments[i], newElement.type);
    }
    validatePropTypes(newElement);
    return newElement;
  }

};

module.exports = ReactElementValidator;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var eio = __webpack_require__(137);
var Socket = __webpack_require__(109);
var Emitter = __webpack_require__(110);
var parser = __webpack_require__(67);
var on = __webpack_require__(108);
var bind = __webpack_require__(72);
var debug = __webpack_require__(40)('socket.io-client:manager');
var indexOf = __webpack_require__(79);
var Backoff = __webpack_require__(131);

/**
 * IE6+ hasOwnProperty
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager (uri, opts) {
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' === typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.randomizationFactor(opts.randomizationFactor || 0.5);
  this.backoff = new Backoff({
    min: this.reconnectionDelay(),
    max: this.reconnectionDelayMax(),
    jitter: this.randomizationFactor()
  });
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connecting = [];
  this.lastPing = null;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.autoConnect = opts.autoConnect !== false;
  if (this.autoConnect) this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function () {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
    }
  }
};

/**
 * Update `socket.id` of all sockets
 *
 * @api private
 */

Manager.prototype.updateSocketIds = function () {
  for (var nsp in this.nsps) {
    if (has.call(this.nsps, nsp)) {
      this.nsps[nsp].id = this.engine.id;
    }
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function (v) {
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function (v) {
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function (v) {
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  this.backoff && this.backoff.setMin(v);
  return this;
};

Manager.prototype.randomizationFactor = function (v) {
  if (!arguments.length) return this._randomizationFactor;
  this._randomizationFactor = v;
  this.backoff && this.backoff.setJitter(v);
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function (v) {
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  this.backoff && this.backoff.setMax(v);
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function (v) {
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function () {
  // Only try to reconnect if it's the first time we're connecting
  if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.reconnect();
  }
};

/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function (fn, opts) {
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';
  this.skipReconnect = false;

  // emit `open`
  var openSub = on(socket, 'open', function () {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function (data) {
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    } else {
      // Only do this if there is no fn to handle the error
      self.maybeReconnectOnOpen();
    }
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function () {
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function () {
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(socket, 'ping', bind(this, 'onping')));
  this.subs.push(on(socket, 'pong', bind(this, 'onpong')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
};

/**
 * Called upon a ping.
 *
 * @api private
 */

Manager.prototype.onping = function () {
  this.lastPing = new Date();
  this.emitAll('ping');
};

/**
 * Called upon a packet.
 *
 * @api private
 */

Manager.prototype.onpong = function () {
  this.emitAll('pong', new Date() - this.lastPing);
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function (data) {
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function (err) {
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function (nsp, opts) {
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp, opts);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connecting', onConnecting);
    socket.on('connect', function () {
      socket.id = self.engine.id;
    });

    if (this.autoConnect) {
      // manually call here since connecting evnet is fired before listening
      onConnecting();
    }
  }

  function onConnecting () {
    if (!~indexOf(self.connecting, socket)) {
      self.connecting.push(socket);
    }
  }

  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function (socket) {
  var index = indexOf(this.connecting, socket);
  if (~index) this.connecting.splice(index, 1);
  if (this.connecting.length) return;

  this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function (packet) {
  debug('writing packet %j', packet);
  var self = this;
  if (packet.query && packet.type === 0) packet.nsp += '?' + packet.query;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function (encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i], packet.options);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function () {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function () {
  debug('cleanup');

  var subsLength = this.subs.length;
  for (var i = 0; i < subsLength; i++) {
    var sub = this.subs.shift();
    sub.destroy();
  }

  this.packetBuffer = [];
  this.encoding = false;
  this.lastPing = null;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function () {
  debug('disconnect');
  this.skipReconnect = true;
  this.reconnecting = false;
  if ('opening' === this.readyState) {
    // `onclose` will not fire because
    // an open event never happened
    this.cleanup();
  }
  this.backoff.reset();
  this.readyState = 'closed';
  if (this.engine) this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function (reason) {
  debug('onclose');

  this.cleanup();
  this.backoff.reset();
  this.readyState = 'closed';
  this.emit('close', reason);

  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function () {
  if (this.reconnecting || this.skipReconnect) return this;

  var self = this;

  if (this.backoff.attempts >= this._reconnectionAttempts) {
    debug('reconnect failed');
    this.backoff.reset();
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.backoff.duration();
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function () {
      if (self.skipReconnect) return;

      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.backoff.attempts);
      self.emitAll('reconnecting', self.backoff.attempts);

      // check again for the case socket closed in above events
      if (self.skipReconnect) return;

      self.open(function (err) {
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function () {
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function () {
  var attempt = this.backoff.attempts;
  this.reconnecting = false;
  this.backoff.reset();
  this.updateSocketIds();
  this.emitAll('reconnect', attempt);
};


/***/ }),
/* 108 */
/***/ (function(module, exports) {


/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on (obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function () {
      obj.removeListener(ev, fn);
    }
  };
}


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var parser = __webpack_require__(67);
var Emitter = __webpack_require__(110);
var toArray = __webpack_require__(256);
var on = __webpack_require__(108);
var bind = __webpack_require__(72);
var debug = __webpack_require__(40)('socket.io-client:socket');
var hasBin = __webpack_require__(78);

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  connecting: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1,
  ping: 1,
  pong: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket (io, nsp, opts) {
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  if (opts && opts.query) {
    this.query = opts.query;
  }
  if (this.io.autoConnect) this.open();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function () {
  if (this.subs) return;

  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * "Opens" the socket.
 *
 * @api public
 */

Socket.prototype.open =
Socket.prototype.connect = function () {
  if (this.connected) return this;

  this.subEvents();
  this.io.open(); // ensure open
  if ('open' === this.io.readyState) this.onopen();
  this.emit('connecting');
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function () {
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function (ev) {
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  packet.options = {};
  packet.options.compress = !this.flags || false !== this.flags.compress;

  // event ack callback
  if ('function' === typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  delete this.flags;

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function (packet) {
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.onopen = function () {
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' !== this.nsp) {
    if (this.query) {
      this.packet({type: parser.CONNECT, query: this.query});
    } else {
      this.packet({type: parser.CONNECT});
    }
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function (reason) {
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  delete this.id;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function (packet) {
  if (packet.nsp !== this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function (packet) {
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function (id) {
  var self = this;
  var sent = false;
  return function () {
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function (packet) {
  var ack = this.acks[packet.id];
  if ('function' === typeof ack) {
    debug('calling ack %s with %j', packet.id, packet.data);
    ack.apply(this, packet.data);
    delete this.acks[packet.id];
  } else {
    debug('bad ack %s', packet.id);
  }
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function () {
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function () {
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function () {
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function () {
  if (this.subs) {
    // clean subscriptions to avoid reconnections
    for (var i = 0; i < this.subs.length; i++) {
      this.subs[i].destroy();
    }
    this.subs = null;
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function () {
  if (this.connected) {
    debug('performing disconnect (%s)', this.nsp);
    this.packet({ type: parser.DISCONNECT });
  }

  // remove socket from pool
  this.destroy();

  if (this.connected) {
    // fire events
    this.onclose('io client disconnect');
  }
  return this;
};

/**
 * Sets the compress flag.
 *
 * @param {Boolean} if `true`, compresses the sending data
 * @return {Socket} self
 * @api public
 */

Socket.prototype.compress = function (compress) {
  this.flags = this.flags || {};
  this.flags.compress = compress;
  return this;
};


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
module.exports = isBuf;

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */

function isBuf(obj) {
  return (global.Buffer && global.Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 112 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__transform__ = __webpack_require__(69);


/* harmony default export */ __webpack_exports__["a"] = function(topology) {
  var bbox = topology.bbox;

  function bboxPoint(p0) {
    p1[0] = p0[0], p1[1] = p0[1], t(p1);
    if (p1[0] < x0) x0 = p1[0];
    if (p1[0] > x1) x1 = p1[0];
    if (p1[1] < y0) y0 = p1[1];
    if (p1[1] > y1) y1 = p1[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  if (!bbox) {
    var t = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__transform__["a" /* default */])(topology), p0, p1 = new Array(2), name,
        x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

    topology.arcs.forEach(function(arc) {
      var i = -1, n = arc.length;
      while (++i < n) {
        p0 = arc[i], p1[0] = p0[0], p1[1] = p0[1], t(p1, i);
        if (p1[0] < x0) x0 = p1[0];
        if (p1[0] > x1) x1 = p1[0];
        if (p1[1] < y0) y0 = p1[1];
        if (p1[1] > y1) y1 = p1[1];
      }
    });

    for (name in topology.objects) {
      bboxGeometry(topology.objects[name]);
    }

    bbox = topology.bbox = [x0, y0, x1, y1];
  }

  return bbox;
};


/***/ }),
/* 113 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function(x) {
  return x;
};


/***/ }),
/* 114 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
};


/***/ }),
/* 115 */
/***/ (function(module, exports) {

module.exports = function(module) {
	if(!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if(!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split('')
  , length = 64
  , map = {}
  , seed = 0
  , i = 0
  , prev;

/**
 * Return a string representing the specified number.
 *
 * @param {Number} num The number to convert.
 * @returns {String} The string representation of the number.
 * @api public
 */
function encode(num) {
  var encoded = '';

  do {
    encoded = alphabet[num % length] + encoded;
    num = Math.floor(num / length);
  } while (num > 0);

  return encoded;
}

/**
 * Return the integer value specified by the given string.
 *
 * @param {String} str The string to convert.
 * @returns {Number} The integer value represented by the string.
 * @api public
 */
function decode(str) {
  var decoded = 0;

  for (i = 0; i < str.length; i++) {
    decoded = decoded * length + map[str.charAt(i)];
  }

  return decoded;
}

/**
 * Yeast: A tiny growing id generator.
 *
 * @returns {String} A unique id.
 * @api public
 */
function yeast() {
  var now = encode(+new Date());

  if (now !== prev) return seed = 0, prev = now;
  return now +'.'+ encode(seed++);
}

//
// Map each character to its index.
//
for (; i < length; i++) map[alphabet[i]] = i;

//
// Expose the `yeast`, `encode` and `decode` functions.
//
yeast.encode = encode;
yeast.decode = decode;
module.exports = yeast;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(82);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _App = __webpack_require__(70);

var _App2 = _interopRequireDefault(_App);

__webpack_require__(254);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(_App2.default, null), document.getElementById('container'));
// import {Provider}    from 'react-redux'
// import {createStore} from 'redux'
// import allReducers   from './reducers'

/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}


/***/ }),
/* 119 */
/***/ (function(module, exports) {

/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPoint = getPoint;
exports.getEventCenter = getEventCenter;
exports.convertToXYZ = convertToXYZ;
function getPoint(event) {
  // Get the vertices
  var a = this.vertices[event.face.a];
  var b = this.vertices[event.face.b];
  var c = this.vertices[event.face.c];

  // Averge them together
  var point = {
    x: (a.x + b.x + c.x) / 3,
    y: (a.y + b.y + c.y) / 3,
    z: (a.z + b.z + c.z) / 3
  };

  return point;
}

function getEventCenter(event, radius) {
  radius = radius || 400;

  var point = getPoint.call(this, event);

  var latRads = Math.acos(point.y / radius);
  var lngRads = Math.atan2(point.z, point.x);
  var lat = (Math.PI / 2 - latRads) * (180 / Math.PI);
  var lng = (Math.PI - lngRads) * (180 / Math.PI);

  return [lat, lng - 180];
}

function convertToXYZ(point, radius) {
  radius = radius || 400;

  var latRads = (90 - point[0]) * Math.PI / 180;
  var lngRads = (180 - point[1]) * Math.PI / 180;

  var x = radius * Math.sin(latRads) * Math.cos(lngRads);
  var y = radius * Math.cos(latRads);
  var z = radius * Math.sin(latRads) * Math.sin(lngRads);

  return { x: x, y: y, z: z };
}

var geodecoder = exports.geodecoder = function geodecoder(features) {

  var store = {};

  for (var i = 0; i < features.length; i++) {
    store[features[i].id] = features[i];
  }

  return {
    find: function find(id) {
      return store[id];
    },
    search: function search(lat, lng) {

      var match = false;

      var country = void 0,
          coords = void 0;

      for (var _i = 0; _i < features.length; _i++) {
        country = features[_i];
        if (country.geometry.type === 'Polygon') {
          match = pointInPolygon(country.geometry.coordinates[0], [lng, lat]);
          if (match) {
            return {
              code: features[_i].id,
              name: features[_i].properties.name
            };
          }
        } else if (country.geometry.type === 'MultiPolygon') {
          coords = country.geometry.coordinates;
          for (var j = 0; j < coords.length; j++) {
            match = pointInPolygon(coords[j][0], [lng, lat]);
            if (match) {
              return {
                code: features[_i].id,
                name: features[_i].properties.name
              };
            }
          }
        }
      }

      return null;
    }
  };
};

// http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
var pointInPolygon = function pointInPolygon(poly, point) {

  var x = point[0];
  var y = point[1];

  var inside = false,
      xi = void 0,
      xj = void 0,
      yi = void 0,
      yj = void 0,
      xk = void 0;

  for (var i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    xi = poly[i][0];
    yi = poly[i][1];
    xj = poly[j][0];
    yj = poly[j][1];

    xk = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (xk) {
      inside = !inside;
    }
  }

  return inside;
};

/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapTexture = mapTexture;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _d = __webpack_require__(32);

var _d2 = _interopRequireDefault(_d);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var projection = _d2.default.geo.equirectangular().translate([1024, 512]).scale(325);

function mapTexture(geojson, fillColor, strokeColor) {
  var texture, context, canvas;

  canvas = _d2.default.select("body").append("canvas").style("display", "none").attr("width", "2048px").attr("height", "1024px");

  context = canvas.node().getContext("2d");

  var path = _d2.default.geo.path().projection(projection).context(context);

  context.strokeStyle = strokeColor || "transparent";
  context.lineWidth = 1;
  context.fillStyle = fillColor || "#CDB380";

  context.beginPath();

  path(geojson);

  if (fillColor) {
    context.fill();
  }

  context.stroke();

  // DEBUGGING - Really expensive, disable when done.
  // console.log(canvas.node().toDataURL());

  texture = new _THREE2.default.Texture(canvas.node());
  texture.needsUpdate = true;

  canvas.remove();

  return texture;
}

/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setEvents = setEvents;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _utils = __webpack_require__(41);

var _App = __webpack_require__(271);

var _tweens = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function setEvents(camera, items, type, wait, tween) {
  var onIntersection = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var onNoIntersection = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;


  var raycaster = new _THREE2.default.Raycaster(),
      intersected = false,
      globeIntersected = false,
      hoveredObject = null,
      hoveredMaterial = null;

  var listener = function listener(event) {

    var mouse = {
      x: (event.clientX - 1) / window.innerWidth * 2 - 1,
      y: -((event.clientY - 1) / window.innerHeight) * 2 + 1
    };

    var cursor = {
      x: event.clientX,
      y: event.clientY
    };

    var vector = new _THREE2.default.Vector3();
    vector.set(mouse.x, mouse.y, 0.5);
    vector.unproject(camera);

    raycaster.ray.set(camera.position, vector.sub(camera.position).normalize());

    var target = raycaster.intersectObjects(items);

    // Were there any intersections?
    if (target.length) {
      globeIntersected = true;
      target[0].type = type;
      target[0].object.dispatchEvent(target[0]);

      // Only run this function on the point objects.
      if (target[0].object.name === 'point') {

        // Make sure we only call this once, and the target has changed.
        if (target[0].object !== hoveredObject || !intersected) {

          // Change the previously hovered point's material back if it has one.
          if (hoveredObject && hoveredMaterial) {
            hoveredObject.material = hoveredMaterial;

            (0, _tweens.growObject)(tween, hoveredObject, 1, 500);
          }

          // Save the material of the object for when we need to set it back
          hoveredMaterial = target[0].object.material;
          hoveredObject = target[0].object;
          intersected = true;

          // Set the material of the hovered object so we can see it.
          target[0].object.material = new _THREE2.default.MeshPhongMaterial({
            color: 0xff0000,
            shading: _THREE2.default.FlatShading,
            shininess: 50
          });

          (0, _tweens.growObject)(tween, target[0].object, 1.4, 500);
          onIntersection(target[0].object, cursor);
        }
      } else {

        // Make sure we only call this once, and there is a callback.
        if (intersected && onNoIntersection) {
          intersected = false;
          hoveredObject.material = hoveredMaterial;

          (0, _tweens.growObject)(tween, hoveredObject, 1, 500);
          onNoIntersection();
        }
      }
    } else {

      // Make sure we only call this once, and there is a callback.
      if (intersected && onNoIntersection) {
        intersected = false;
        hoveredObject.material = hoveredMaterial;

        (0, _tweens.growObject)(tween, hoveredObject, 1, 500);
        onNoIntersection();
      }

      // Make sure we only call this once, and there is a callback.
      if (globeIntersected && onNoIntersection) {
        globeIntersected = false;

        onNoIntersection();
      }
    }
  };

  if (!wait) {
    document.addEventListener(type, listener, false);
  } else {
    document.addEventListener(type, (0, _utils.debounce)(listener, wait), false);
  }
}

/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BackButton = function (_Component) {
  _inherits(BackButton, _Component);

  function BackButton() {
    _classCallCheck(this, BackButton);

    return _possibleConstructorReturn(this, (BackButton.__proto__ || Object.getPrototypeOf(BackButton)).apply(this, arguments));
  }

  _createClass(BackButton, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement("div", {
        className: "back-btn" + (this.props.isCountryClicked ? " visible" : ""),
        onClick: function onClick() {
          return _this2.props.onButtonClick();
        } });
    }
  }]);

  return BackButton;
}(_react.Component);

exports.default = BackButton;

/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CountryDetails = function (_Component) {
  _inherits(CountryDetails, _Component);

  function CountryDetails() {
    _classCallCheck(this, CountryDetails);

    return _possibleConstructorReturn(this, (CountryDetails.__proto__ || Object.getPrototypeOf(CountryDetails)).apply(this, arguments));
  }

  _createClass(CountryDetails, [{
    key: "render",

    // <img className="country__details country_details--flag" 
    //      src      ={"src/svg/" + this.props.countryFlag + ".svg"} 
    //      alt      ="Country Flag" />
    value: function render() {
      return _react2.default.createElement(
        "div",
        { className: "country__details" },
        _react2.default.createElement(
          "div",
          { className: "country__detail country__detail--capital" },
          _react2.default.createElement(
            "label",
            null,
            "Capital:"
          ),
          this.props.countryCapital
        ),
        _react2.default.createElement(
          "div",
          { className: "country__detail country__detail--population" },
          _react2.default.createElement(
            "label",
            null,
            "Population:"
          ),
          this.props.countryPopulation
        ),
        _react2.default.createElement(
          "div",
          { className: "country__detail country__detail--size" },
          _react2.default.createElement(
            "label",
            null,
            "Size (Kilometers):"
          ),
          parseInt(this.props.countrySize, 10)
        ),
        _react2.default.createElement(
          "div",
          { className: "country__detail country__detail--languages" },
          _react2.default.createElement(
            "label",
            null,
            "Languages Used:"
          ),
          this.props.countryLanguages
        ),
        _react2.default.createElement(
          "div",
          { className: "country__detail country__detail--num-tweets" },
          _react2.default.createElement(
            "label",
            null,
            "Number of Recent Tweets:"
          ),
          this.props.numCountryTweets
        )
      );
    }
  }]);

  return CountryDetails;
}(_react.Component);

exports.default = CountryDetails;

/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _CountryName = __webpack_require__(71);

var _CountryName2 = _interopRequireDefault(_CountryName);

var _CountryDetails = __webpack_require__(124);

var _CountryDetails2 = _interopRequireDefault(_CountryDetails);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CountryInformation = function (_Component) {
  _inherits(CountryInformation, _Component);

  function CountryInformation() {
    _classCallCheck(this, CountryInformation);

    return _possibleConstructorReturn(this, (CountryInformation.__proto__ || Object.getPrototypeOf(CountryInformation)).apply(this, arguments));
  }

  _createClass(CountryInformation, [{
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'section',
        { className: 'country__information' },
        _react2.default.createElement(_CountryName2.default, { countryName: this.props.countryName }),
        _react2.default.createElement(_CountryDetails2.default, {
          countryFlag: this.props.countryFlag,
          countryCapital: this.props.countryCapital,
          countryPopulation: this.props.countryPopulation,
          countrySize: this.props.countrySize,
          countryLanguages: this.props.countryLanguages,
          numCountryTweets: this.props.numCountryTweets })
      );
    }
  }]);

  return CountryInformation;
}(_react.Component);

exports.default = CountryInformation;

/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TweetBox = function (_Component) {
  _inherits(TweetBox, _Component);

  function TweetBox() {
    _classCallCheck(this, TweetBox);

    return _possibleConstructorReturn(this, (TweetBox.__proto__ || Object.getPrototypeOf(TweetBox)).apply(this, arguments));
  }

  _createClass(TweetBox, [{
    key: "getClassName",


    /**
     * Uses the mouse coordinates to determine if the hovered point is
     * in the top-left, top-right, bottom-left, or bottom-right quadrant.
     * Returns classnames to determine the translate values.
     */
    value: function getClassName(coordinates) {
      var x = coordinates.x,
          y = coordinates.y,
          winHeight = window.innerHeight,
          winWidth = window.innerWidth,
          boxSize = 320;

      // Don't add any classes until a point is hovered on.
      if (!this.props.isPointHovered) return "";

      // left half 
      if (x < winWidth / 2) {
        // top half
        if (y < winHeight / 2) {
          return " top-left";
        } else {
          return " bottom-left";
        }
      } else {
        // top half
        if (y < winHeight / 2) {
          return " top-right";
        } else {
          return " bottom-right";
        }
      }
    }
  }, {
    key: "render",
    value: function render() {
      var posn = this.props.mouseCoordinates,
          name = this.getClassName(posn);

      return _react2.default.createElement(
        "aside",
        { id: "tweetBox",
          className: "tweet-box" + name + (this.props.isPointHovered ? " visible" : ""),
          style: {
            left: posn.x + 'px',
            top: posn.y + 'px'
          } },
        _react2.default.createElement("span", { className: "tweet-box--line top" }),
        _react2.default.createElement("span", { className: "tweet-box--line side" }),
        _react2.default.createElement("img", { id: "tweetAvatar",
          className: "tweet-box--avatar",
          src: this.props.image,
          alt: "twitter avatar image" }),
        _react2.default.createElement(
          "h2",
          { id: "tweetName", className: "tweet-box--user-name" },
          this.props.name
        ),
        _react2.default.createElement(
          "p",
          { id: "tweetText", className: "tweet-box--tweet-text" },
          this.props.text
        )
      );
    }
  }]);

  return TweetBox;
}(_react.Component);

exports.default = TweetBox;

/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var TweetCount = function (_Component) {
  _inherits(TweetCount, _Component);

  function TweetCount() {
    _classCallCheck(this, TweetCount);

    return _possibleConstructorReturn(this, (TweetCount.__proto__ || Object.getPrototypeOf(TweetCount)).apply(this, arguments));
  }

  _createClass(TweetCount, [{
    key: "render",
    value: function render() {
      return _react2.default.createElement(
        "div",
        { className: "tweet-count" },
        this.props.numTweets,
        " Tweets"
      );
    }
  }]);

  return TweetCount;
}(_react.Component);

exports.default = TweetCount;

/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEarth = undefined;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _tweens = __webpack_require__(30);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and adds the earth to the scene.
 *
 * @param     shape    : THREE.Geometry
 * @param     callback : function
 *
 */
var createEarth = exports.createEarth = function createEarth(shape, obj, tween, callback) {
  // loads the earth images and once it is done, expands it
  var loader = new _THREE2.default.TextureLoader(),
      texture = loader.load("src/images/earth.png"),
      bumpTexture = loader.load("src/images/earthbump.jpg"),
      specTexture = loader.load("src/images/earthspec.jpg"),
      cloudTexture = loader.load("src/images/clouds.png", (0, _tweens.growObject)(tween, obj, 1, 2000, 500, callback));

  texture.wrapS = texture.wrapT = _THREE2.default.RepeatWrapping;
  bumpTexture.wrapS = bumpTexture.wrapT = _THREE2.default.RepeatWrapping;
  specTexture.wrapS = specTexture.wrapT = _THREE2.default.RepeatWrapping;
  cloudTexture.wrapS = cloudTexture.wrapT = _THREE2.default.RepeatWrapping;

  var earthMaterial = new _THREE2.default.MeshPhongMaterial({
    bumpMap: bumpTexture,
    bumpScale: 0.005,
    depthWrite: false,
    map: texture,
    opacity: 0.99,
    shininess: 5,
    specular: 0xcccccc,
    specularMap: specTexture,
    transparent: true
  }),
      cloudMaterial = new _THREE2.default.MeshPhongMaterial({
    depthWrite: false,
    map: cloudTexture,
    opacity: 0.5,
    transparent: true
  });

  var earth = new _THREE2.default.Mesh(shape, earthMaterial),
      cloud = new _THREE2.default.Mesh(shape, cloudMaterial);

  earth.name = "earth";
  cloud.name = "cloud";
  cloud.scale.set(1.02, 1.02, 1.02);

  return {
    "earth": earth,
    "cloud": cloud
  };
};

/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createGlowMaterial = undefined;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _scene = __webpack_require__(29);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates and returns a material with a glowing effect.
 *
 * @param     color : hex
 *
 */
var createGlowMaterial = exports.createGlowMaterial = function createGlowMaterial(color) {
    return new _THREE2.default.ShaderMaterial({
        uniforms: {
            "c": { type: "f", value: 1.0 },
            "p": { type: "f", value: 1.0 },
            glowColor: { type: "c", value: new _THREE2.default.Color(color) },
            viewVector: { type: "v3", value: _scene.camera.position }
        },
        vertexShader: document.getElementById('vertexShader').textContent,
        fragmentShader: document.getElementById('fragmentShader').textContent,
        side: _THREE2.default.FrontSide,
        blending: _THREE2.default.AdditiveBlending
    });
    // return new THREE.ShaderMaterial( {
    //             uniforms:       {
    //                               amplitude: { value: 5.0 },
    //                               opacity:   { value: 0.3 },
    //                               color:     { value: new THREE.Color( 0xff0000 ) }
    //                             },
    //             vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    //             fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    //             blending:       THREE.AdditiveBlending,
    //             // depthTest:      false,
    //             // transparent:    true
    //           });
};

/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createPoint = exports.pointList = undefined;

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _scene = __webpack_require__(29);

var _utils = __webpack_require__(41);

var _tweens = __webpack_require__(30);

var _createGlowMaterial = __webpack_require__(129);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var pointList = exports.pointList = [];

/**
 * Creates and returns a triangular mesh to simulate a point on the map.
 * Sets the position based on the supplied longitude and latitude.
 *
 * @param     lat     : number  (2d longitude)
 * @param     lon     : number  (2d latitude)
 * @param     radius  : number  (radius of the globe)
 * @param     size    : number  (size of the point base)
 * @param     height  : number  (distance from the globe)
 * @param     color   : hex     (color of the point )
 * @param     points  : object  (contains all the points)
 * @param     tween   : object  (tween object)
 *
 */
var createPoint = exports.createPoint = function createPoint(lat, long, radius, size, height, color, points, tween) {
  var geometry = new _THREE2.default.CylinderGeometry(size, 0, size * 4, 8, 1),

  // let geometry = new THREE.SphereGeometry(size, 8, 8),
  // material = new THREE.MeshPhongMaterial({ 
  //   color:   color,
  //   shading: THREE.SmoothShading,
  //   shininess: 30,
  //   specular: 0x0000ff,
  //   wireframe: true
  //   // transparent: true
  // }),
  material = (0, _createGlowMaterial.createGlowMaterial)(color),
      mesh = new _THREE2.default.Mesh(geometry, material),
      vector = (0, _utils.latLongToVector3)(lat, long, radius, height);

  // Direct the point to face sideways
  geometry.rotateX(-Math.PI / 2);

  // Set the mesh position and shrink it so we can expand it.
  mesh.position.set(vector.x, vector.y, vector.z);
  mesh.scale.set(0.1, 0.1, 0.1);

  mesh.name = 'point';

  // Set the mesh to point towards the center of the scene
  mesh.lookAt(_scene.scene.position);

  points.add(mesh);
  pointList.push(mesh);

  // Animate the growth once it is added.
  (0, _tweens.growObject)(tween, mesh, 1, 500);
};

/***/ }),
/* 131 */
/***/ (function(module, exports) {


/**
 * Expose `Backoff`.
 */

module.exports = Backoff;

/**
 * Initialize backoff timer with `opts`.
 *
 * - `min` initial timeout in milliseconds [100]
 * - `max` max timeout [10000]
 * - `jitter` [0]
 * - `factor` [2]
 *
 * @param {Object} opts
 * @api public
 */

function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 10000;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}

/**
 * Return the backoff duration.
 *
 * @return {Number}
 * @api public
 */

Backoff.prototype.duration = function(){
  var ms = this.ms * Math.pow(this.factor, this.attempts++);
  if (this.jitter) {
    var rand =  Math.random();
    var deviation = Math.floor(rand * this.jitter * ms);
    ms = (Math.floor(rand * 10) & 1) == 0  ? ms - deviation : ms + deviation;
  }
  return Math.min(ms, this.max) | 0;
};

/**
 * Reset the number of attempts.
 *
 * @api public
 */

Backoff.prototype.reset = function(){
  this.attempts = 0;
};

/**
 * Set the minimum duration
 *
 * @api public
 */

Backoff.prototype.setMin = function(min){
  this.ms = min;
};

/**
 * Set the maximum duration
 *
 * @api public
 */

Backoff.prototype.setMax = function(max){
  this.max = max;
};

/**
 * Set the jitter
 *
 * @api public
 */

Backoff.prototype.setJitter = function(jitter){
  this.jitter = jitter;
};



/***/ }),
/* 132 */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var a = new Blob(['hi']);
    return a.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if Blob constructor supports ArrayBufferViews
 * Fails in Safari 6, so we need to map to ArrayBuffers there.
 */

var blobSupportsArrayBufferView = blobSupported && (function() {
  try {
    var b = new Blob([new Uint8Array([1,2])]);
    return b.size === 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

/**
 * Helper function that maps ArrayBufferViews to ArrayBuffers
 * Used by BlobBuilder constructor and old browsers that didn't
 * support it in the Blob constructor.
 */

function mapArrayBufferViews(ary) {
  for (var i = 0; i < ary.length; i++) {
    var chunk = ary[i];
    if (chunk.buffer instanceof ArrayBuffer) {
      var buf = chunk.buffer;

      // if this is a subarray, make a copy so we only
      // include the subarray region from the underlying buffer
      if (chunk.byteLength !== buf.byteLength) {
        var copy = new Uint8Array(chunk.byteLength);
        copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
        buf = copy.buffer;
      }

      ary[i] = buf;
    }
  }
}

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  mapArrayBufferViews(ary);

  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }

  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

function BlobConstructor(ary, options) {
  mapArrayBufferViews(ary);
  return new Blob(ary, options || {});
};

module.exports = (function() {
  if (blobSupported) {
    return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 134 */
/***/ (function(module, exports) {


/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(136)();
// imports


// module
exports.push([module.i, "html {\n  height: 100%;\n  width: 100%; }\n\nbody {\n  background-image: url(" + __webpack_require__(266) + ");\n  background-repeat: no-repeat;\n  background-size: cover;\n  color: #fff;\n  font-family: 'Press Start 2P', cursive;\n  margin: 0;\n  height: 100%;\n  width: 100%; }\n\n#wrapper {\n  position: absolute;\n  margin: 0;\n  height: 100%;\n  width: 100%;\n  transition: transform 500ms ease-in-out; }\n  #wrapper.active {\n    transform: translateX(20%); }\n    #wrapper.active .country__information {\n      opacity: 1; }\n      #wrapper.active .country__information .country--name {\n        opacity: 1; }\n      #wrapper.active .country__information .country__detail {\n        opacity: 1; }\n        #wrapper.active .country__information .country__detail:nth-of-type(1) {\n          transition: opacity 300ms ease-in-out 800ms; }\n        #wrapper.active .country__information .country__detail:nth-of-type(2) {\n          transition: opacity 300ms ease-in-out 1100ms; }\n        #wrapper.active .country__information .country__detail:nth-of-type(3) {\n          transition: opacity 300ms ease-in-out 1400ms; }\n        #wrapper.active .country__information .country__detail:nth-of-type(4) {\n          transition: opacity 300ms ease-in-out 1700ms; }\n        #wrapper.active .country__information .country__detail:nth-of-type(5) {\n          transition: opacity 300ms ease-in-out 2000ms; }\n    #wrapper.active .country--name {\n      opacity: 0; }\n\n#container {\n  position: absolute;\n  height: 100%;\n  width: 100%; }\n\n#three-container {\n  position: absolute;\n  margin: 0;\n  height: 100%;\n  width: 100%; }\n\n.glitch, .country__information .country--name {\n  overflow: hidden; }\n  .glitch::before, .country__information .country--name::before, .glitch::after, .country__information .country--name::after {\n    background: transparent;\n    color: white;\n    content: attr(data-text);\n    position: absolute;\n    top: 2px;\n    transform: translateX(-50%);\n    overflow: hidden;\n    clip: rect(0, 900px, 0, 0);\n    height: 100%;\n    width: 100%; }\n  .glitch::before, .country__information .country--name::before {\n    animation: noise-anim-2 5s infinite linear alternate-reverse;\n    left: calc(50%);\n    text-shadow: 1px 1px blue; }\n  .glitch::after, .country__information .country--name::after {\n    animation: noise-anim 4s infinite linear alternate-reverse;\n    left: calc(50%);\n    text-shadow: 1px 1px red; }\n\n@keyframes noise-anim {\n  0% {\n    clip: rect(43px, 9999px, 5px, 0); }\n  5% {\n    clip: rect(15px, 9999px, 114px, 0); }\n  10% {\n    clip: rect(46px, 9999px, 146px, 0); }\n  15% {\n    clip: rect(13px, 9999px, 13px, 0); }\n  20% {\n    clip: rect(1px, 9999px, 152px, 0); }\n  25% {\n    clip: rect(1px, 9999px, 21px, 0); }\n  30% {\n    clip: rect(48px, 9999px, 149px, 0); }\n  35% {\n    clip: rect(5px, 9999px, 50px, 0); }\n  40% {\n    clip: rect(10px, 9999px, 4px, 0); }\n  45% {\n    clip: rect(40px, 9999px, 45px, 0); }\n  50% {\n    clip: rect(14px, 9999px, 181px, 0); }\n  55% {\n    clip: rect(7px, 9999px, 12px, 0); }\n  60% {\n    clip: rect(17px, 9999px, 172px, 0); }\n  65% {\n    clip: rect(26px, 9999px, 149px, 0); }\n  70% {\n    clip: rect(41px, 9999px, 195px, 0); }\n  75% {\n    clip: rect(7px, 9999px, 16px, 0); }\n  80% {\n    clip: rect(15px, 9999px, 92px, 0); }\n  85% {\n    clip: rect(4px, 9999px, 45px, 0); }\n  90% {\n    clip: rect(11px, 9999px, 18px, 0); }\n  95% {\n    clip: rect(33px, 9999px, 38px, 0); }\n  100% {\n    clip: rect(9px, 9999px, 200px, 0); } }\n\n@keyframes noise-anim-2 {\n  0% {\n    clip: rect(31px, 9999px, 85px, 0); }\n  5% {\n    clip: rect(13px, 9999px, 138px, 0); }\n  10% {\n    clip: rect(35px, 9999px, 151px, 0); }\n  15% {\n    clip: rect(28px, 9999px, 109px, 0); }\n  20% {\n    clip: rect(44px, 9999px, 69px, 0); }\n  25% {\n    clip: rect(39px, 9999px, 118px, 0); }\n  30% {\n    clip: rect(9px, 9999px, 87px, 0); }\n  35% {\n    clip: rect(3px, 9999px, 137px, 0); }\n  40% {\n    clip: rect(24px, 9999px, 154px, 0); }\n  45% {\n    clip: rect(27px, 9999px, 36px, 0); }\n  50% {\n    clip: rect(44px, 9999px, 190px, 0); }\n  55% {\n    clip: rect(10px, 9999px, 104px, 0); }\n  60% {\n    clip: rect(22px, 9999px, 29px, 0); }\n  65% {\n    clip: rect(2px, 9999px, 195px, 0); }\n  70% {\n    clip: rect(31px, 9999px, 174px, 0); }\n  75% {\n    clip: rect(21px, 9999px, 94px, 0); }\n  80% {\n    clip: rect(47px, 9999px, 114px, 0); }\n  85% {\n    clip: rect(21px, 9999px, 103px, 0); }\n  90% {\n    clip: rect(5px, 9999px, 90px, 0); }\n  95% {\n    clip: rect(15px, 9999px, 169px, 0); }\n  100% {\n    clip: rect(42px, 9999px, 100px, 0); } }\n\n.country--name {\n  font-size: 86px;\n  letter-spacing: 3px;\n  line-height: 1.5;\n  opacity: 0;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  text-align: center;\n  text-transform: uppercase;\n  transform: translate(-50%, -50%);\n  transition: opacity 300ms ease-in-out;\n  width: 80%; }\n  .country--name.visible {\n    opacity: 1; }\n\n.country__information {\n  opacity: 0;\n  position: absolute;\n  left: -20%;\n  height: 100%;\n  width: 400px;\n  transition: opacity 500ms ease-in-out; }\n  .country__information .country--name {\n    font-size: 20px;\n    margin: 50px auto;\n    min-height: 30px;\n    position: relative;\n    left: auto;\n    top: auto;\n    transform: none;\n    width: 100%;\n    white-space: inherit;\n    transition: all 300ms ease-in-out 500ms; }\n\n.country__details {\n  padding: 20px; }\n\n.country__detail {\n  line-height: 1.5;\n  margin-bottom: 30px;\n  opacity: 0;\n  transition: opacity 300ms ease-in-out; }\n\n.country__detail--languages {\n  word-break: break-all; }\n\n.tweet-count {\n  position: absolute;\n  right: 40px;\n  top: 10px; }\n\n.tweet-box {\n  position: absolute;\n  min-height: 100px;\n  width: 200px;\n  z-index: -1; }\n  .tweet-box.visible {\n    z-index: 1; }\n    .tweet-box.visible .tweet-box--avatar,\n    .tweet-box.visible .tweet-box--user-name,\n    .tweet-box.visible .tweet-box--tweet-text {\n      transition: opacity 500ms ease-in-out 400ms;\n      opacity: 1; }\n  .tweet-box.top-left {\n    transform: translate(-131%, -75px); }\n    .tweet-box.top-left .tweet-box--line.top {\n      transform: rotate(180deg); }\n      .tweet-box.top-left .tweet-box--line.top::before {\n        transition: width 200ms linear 200ms;\n        width: 100%; }\n    .tweet-box.top-left .tweet-box--line.side {\n      left: calc(100% - 28px);\n      top: 61px;\n      transform: rotate(50deg); }\n      .tweet-box.top-left .tweet-box--line.side::before {\n        right: 0;\n        transition: width 200ms linear;\n        width: 100%; }\n  .tweet-box.top-right {\n    transform: translate(31%, -75px); }\n    .tweet-box.top-right .tweet-box--line.top::before {\n      transition: width 200ms linear 200ms;\n      width: 100%; }\n    .tweet-box.top-right .tweet-box--line.side {\n      left: -40%;\n      transform: rotate(-50deg); }\n      .tweet-box.top-right .tweet-box--line.side::before {\n        transition: width 200ms linear;\n        width: 100%; }\n  .tweet-box.bottom-left {\n    transform: translate(-130%, calc(-100% + 75px)); }\n    .tweet-box.bottom-left .tweet-box--line.top {\n      transform: rotate(180deg);\n      top: 100%; }\n      .tweet-box.bottom-left .tweet-box--line.top::before {\n        transition: width 200ms linear 200ms;\n        width: 100%; }\n    .tweet-box.bottom-left .tweet-box--line.side {\n      left: calc(100% - 28px);\n      top: calc(100% - 61px);\n      transform: rotate(-50deg); }\n      .tweet-box.bottom-left .tweet-box--line.side::before {\n        right: 0;\n        transition: width 200ms linear;\n        width: 100%; }\n  .tweet-box.bottom-right {\n    transform: translate(30%, calc(-100% + 75px)); }\n    .tweet-box.bottom-right .tweet-box--line.top {\n      top: 100%; }\n      .tweet-box.bottom-right .tweet-box--line.top::before {\n        transition: width 200ms linear 200ms;\n        width: 100%; }\n    .tweet-box.bottom-right .tweet-box--line.side {\n      left: -40%;\n      top: 100%;\n      transform: rotate(50deg); }\n      .tweet-box.bottom-right .tweet-box--line.side::before {\n        transition: width 200ms linear;\n        width: 100%; }\n  .tweet-box .tweet-box--avatar,\n  .tweet-box .tweet-box--user-name,\n  .tweet-box .tweet-box--tweet-text {\n    opacity: 0; }\n\n.tweet-box--line {\n  background: transparent;\n  height: 1px;\n  position: absolute; }\n  .tweet-box--line::before {\n    background: #fff;\n    content: \"\";\n    position: absolute;\n    height: 1px;\n    width: 0; }\n  .tweet-box--line.top {\n    left: 0;\n    top: 0;\n    width: 100%; }\n  .tweet-box--line.side {\n    transform-origin: right center;\n    transition: width 200ms linear;\n    width: 40%; }\n\n.tweet-box--avatar {\n  width: 75px; }\n\n.tweet-box--tweet-text {\n  font-family: 'Roboto',arial,sans-serif; }\n\n.back-btn {\n  opacity: 0;\n  position: absolute;\n  right: calc(20% - 35px);\n  top: 30px;\n  height: 15px;\n  width: 35px;\n  transition: all 100ms ease;\n  z-index: -1; }\n  .back-btn:before {\n    border-left: 2px solid #fff;\n    border-bottom: 2px solid #fff;\n    content: \"\";\n    height: 15px;\n    width: 15px;\n    left: 2px;\n    position: absolute;\n    transform: rotate(45deg); }\n  .back-btn::after {\n    background: #fff;\n    content: \"\";\n    height: 2px;\n    width: 100%;\n    position: absolute;\n    top: 50%;\n    transform: translateY(-50%); }\n  .back-btn:hover {\n    cursor: pointer; }\n  .back-btn.visible {\n    opacity: 1;\n    transform: translateX(-65px);\n    transition: opacity 325ms ease-in-out 500ms, transform 500ms ease-in-out 500ms;\n    z-index: 1; }\n", ""]);

// exports


/***/ }),
/* 136 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function() {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		var result = [];
		for(var i = 0; i < this.length; i++) {
			var item = this[i];
			if(item[2]) {
				result.push("@media " + item[2] + "{" + item[1] + "}");
			} else {
				result.push(item[1]);
			}
		}
		return result.join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(138);


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {


module.exports = __webpack_require__(139);

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = __webpack_require__(20);


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var transports = __webpack_require__(73);
var Emitter = __webpack_require__(44);
var debug = __webpack_require__(33)('engine.io-client:socket');
var index = __webpack_require__(79);
var parser = __webpack_require__(20);
var parseuri = __webpack_require__(81);
var parsejson = __webpack_require__(162);
var parseqs = __webpack_require__(46);

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket (uri, opts) {
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' === typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.hostname = uri.host;
    opts.secure = uri.protocol === 'https' || uri.protocol === 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  } else if (opts.host) {
    opts.hostname = parseuri(opts.host).host;
  }

  this.secure = null != opts.secure ? opts.secure
    : (global.location && 'https:' === location.protocol);

  if (opts.hostname && !opts.port) {
    // if no port is specified manually, use the protocol default
    opts.port = this.secure ? '443' : '80';
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port
      ? location.port
      : (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' === typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.jsonp = false !== opts.jsonp;
  this.forceBase64 = !!opts.forceBase64;
  this.enablesXDR = !!opts.enablesXDR;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.prevBufferLen = 0;
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
  this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

  if (true === this.perMessageDeflate) this.perMessageDeflate = {};
  if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
    this.perMessageDeflate.threshold = 1024;
  }

  // SSL options for Node.js client
  this.pfx = opts.pfx || null;
  this.key = opts.key || null;
  this.passphrase = opts.passphrase || null;
  this.cert = opts.cert || null;
  this.ca = opts.ca || null;
  this.ciphers = opts.ciphers || null;
  this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? null : opts.rejectUnauthorized;
  this.forceNode = !!opts.forceNode;

  // other options for Node.js client
  var freeGlobal = typeof global === 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
      this.extraHeaders = opts.extraHeaders;
    }

    if (opts.localAddress) {
      this.localAddress = opts.localAddress;
    }
  }

  // set on handshake
  this.id = null;
  this.upgrades = null;
  this.pingInterval = null;
  this.pingTimeout = null;

  // set on heartbeat
  this.pingIntervalTimer = null;
  this.pingTimeoutTimer = null;

  this.open();
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = __webpack_require__(42);
Socket.transports = __webpack_require__(73);
Socket.parser = __webpack_require__(20);

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    jsonp: this.jsonp,
    forceBase64: this.forceBase64,
    enablesXDR: this.enablesXDR,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this,
    pfx: this.pfx,
    key: this.key,
    passphrase: this.passphrase,
    cert: this.cert,
    ca: this.ca,
    ciphers: this.ciphers,
    rejectUnauthorized: this.rejectUnauthorized,
    perMessageDeflate: this.perMessageDeflate,
    extraHeaders: this.extraHeaders,
    forceNode: this.forceNode,
    localAddress: this.localAddress
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') !== -1) {
    transport = 'websocket';
  } else if (0 === this.transports.length) {
    // Emit error on next tick so it can be listened to
    var self = this;
    setTimeout(function () {
      self.emit('error', 'No transports available');
    }, 0);
    return;
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';

  // Retry with the next transport if the transport is disabled (jsonp: false)
  try {
    transport = this.createTransport(transport);
  } catch (e) {
    this.transports.shift();
    this.open();
    return;
  }

  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function (transport) {
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function () {
    self.onDrain();
  })
  .on('packet', function (packet) {
    self.onPacket(packet);
  })
  .on('error', function (e) {
    self.onError(e);
  })
  .on('close', function () {
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 });
  var failed = false;
  var self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen () {
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' === msg.type && 'probe' === msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        if (!transport) return;
        Socket.priorWebsocketSuccess = 'websocket' === transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' === self.readyState) return;
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport () {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  // Handle any error that happens while probing
  function onerror (err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose () {
    onerror('transport closed');
  }

  // When the socket is closed while we're probing
  function onclose () {
    onerror('socket closed');
  }

  // When the socket is upgraded while we're probing
  function onupgrade (to) {
    if (transport && to.name !== transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  // Remove all listeners on the transport and on self
  function cleanup () {
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();
};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' === this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' === this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' === this.readyState || 'open' === this.readyState ||
      'closing' === this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        this.emit('pong');
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.onError(err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if ('closed' === this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' === self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api private
*/

Socket.prototype.ping = function () {
  var self = this;
  this.sendPacket('ping', function () {
    self.emit('ping');
  });
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function () {
  this.writeBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (0 === this.writeBuffer.length) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' !== this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @param {Object} options.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, options, fn) {
  this.sendPacket('message', msg, options, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Object} options.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, options, fn) {
  if ('function' === typeof data) {
    fn = data;
    data = undefined;
  }

  if ('function' === typeof options) {
    fn = options;
    options = null;
  }

  if ('closing' === this.readyState || 'closed' === this.readyState) {
    return;
  }

  options = options || {};
  options.compress = false !== options.compress;

  var packet = {
    type: type,
    data: data,
    options: options
  };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  if (fn) this.once('flush', fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' === this.readyState || 'open' === this.readyState) {
    this.readyState = 'closing';

    var self = this;

    if (this.writeBuffer.length) {
      this.once('drain', function () {
        if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      });
    } else if (this.upgrading) {
      waitForUpgrade();
    } else {
      close();
    }
  }

  function close () {
    self.onClose('forced close');
    debug('socket closing - telling transport to close');
    self.transport.close();
  }

  function cleanupAndClose () {
    self.removeListener('upgrade', cleanupAndClose);
    self.removeListener('upgradeError', cleanupAndClose);
    close();
  }

  function waitForUpgrade () {
    // wait for upgrade to finish since we can't send packets while pausing a transport
    self.once('upgrade', cleanupAndClose);
    self.once('upgradeError', cleanupAndClose);
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' === this.readyState || 'open' === this.readyState || 'closing' === this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);

    // clean buffers after, so users can still
    // grab the buffers on `close` event
    self.writeBuffer = [];
    self.prevBufferLen = 0;
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i < j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module requirements.
 */

var Polling = __webpack_require__(74);
var inherit = __webpack_require__(31);

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    }, false);
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
    this.iframe = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function (e) {
    self.onError('jsonp poll error', e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  if (insertAt) {
    insertAt.parentNode.insertBefore(script, insertAt);
  } else {
    (document.head || document.body).appendChild(script);
  }
  this.script = script;

  var isUAgecko = 'undefined' !== typeof navigator && /gecko/i.test(navigator.userAgent);

  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="' + self.iframeId + '">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch (e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function () {
      if (self.iframe.readyState === 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module requirements.
 */

var XMLHttpRequest = __webpack_require__(43);
var Polling = __webpack_require__(74);
var Emitter = __webpack_require__(44);
var inherit = __webpack_require__(31);
var debug = __webpack_require__(33)('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty () {}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR (opts) {
  Polling.call(this, opts);
  this.requestTimeout = opts.requestTimeout;

  if (global.location) {
    var isSSL = 'https:' === location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname !== global.location.hostname ||
      port !== opts.port;
    this.xs = opts.secure !== isSSL;
  } else {
    this.extraHeaders = opts.extraHeaders;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function (opts) {
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.xs = this.xs;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  opts.enablesXDR = this.enablesXDR;

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  opts.requestTimeout = this.requestTimeout;

  // other options for Node.js client
  opts.extraHeaders = this.extraHeaders;

  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function (data, fn) {
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function (err) {
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function () {
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function (data) {
    self.onData(data);
  });
  req.on('error', function (err) {
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request (opts) {
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.xs = !!opts.xs;
  this.async = false !== opts.async;
  this.data = undefined !== opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.isBinary = opts.isBinary;
  this.supportsBinary = opts.supportsBinary;
  this.enablesXDR = opts.enablesXDR;
  this.requestTimeout = opts.requestTimeout;

  // SSL options for Node.js client
  this.pfx = opts.pfx;
  this.key = opts.key;
  this.passphrase = opts.passphrase;
  this.cert = opts.cert;
  this.ca = opts.ca;
  this.ciphers = opts.ciphers;
  this.rejectUnauthorized = opts.rejectUnauthorized;

  // other options for Node.js client
  this.extraHeaders = opts.extraHeaders;

  this.create();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function () {
  var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;

  var xhr = this.xhr = new XMLHttpRequest(opts);
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    try {
      if (this.extraHeaders) {
        xhr.setDisableHeaderCheck(true);
        for (var i in this.extraHeaders) {
          if (this.extraHeaders.hasOwnProperty(i)) {
            xhr.setRequestHeader(i, this.extraHeaders[i]);
          }
        }
      }
    } catch (e) {}
    if (this.supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' === this.method) {
      try {
        if (this.isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    try {
      xhr.setRequestHeader('Accept', '*/*');
    } catch (e) {}

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    if (this.requestTimeout) {
      xhr.timeout = this.requestTimeout;
    }

    if (this.hasXDR()) {
      xhr.onload = function () {
        self.onLoad();
      };
      xhr.onerror = function () {
        self.onError(xhr.responseText);
      };
    } else {
      xhr.onreadystatechange = function () {
        if (4 !== xhr.readyState) return;
        if (200 === xhr.status || 1223 === xhr.status) {
          self.onLoad();
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function () {
            self.onError(xhr.status);
          }, 0);
        }
      };
    }

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function () {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function () {
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function (data) {
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function (err) {
  this.emit('error', err);
  this.cleanup(true);
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function (fromError) {
  if ('undefined' === typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  if (this.hasXDR()) {
    this.xhr.onload = this.xhr.onerror = empty;
  } else {
    this.xhr.onreadystatechange = empty;
  }

  if (fromError) {
    try {
      this.xhr.abort();
    } catch (e) {}
  }

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Called upon load.
 *
 * @api private
 */

Request.prototype.onLoad = function () {
  var data;
  try {
    var contentType;
    try {
      contentType = this.xhr.getResponseHeader('Content-Type').split(';')[0];
    } catch (e) {}
    if (contentType === 'application/octet-stream') {
      data = this.xhr.response || this.xhr.responseText;
    } else {
      if (!this.supportsBinary) {
        data = this.xhr.responseText;
      } else {
        try {
          data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
        } catch (e) {
          var ui8Arr = new Uint8Array(this.xhr.response);
          var dataArray = [];
          for (var idx = 0, length = ui8Arr.length; idx < length; idx++) {
            dataArray.push(ui8Arr[idx]);
          }

          data = String.fromCharCode.apply(null, dataArray);
        }
      }
    }
  } catch (e) {
    this.onError(e);
  }
  if (null != data) {
    this.onData(data);
  }
};

/**
 * Check if it has XDomainRequest.
 *
 * @api private
 */

Request.prototype.hasXDR = function () {
  return 'undefined' !== typeof global.XDomainRequest && !this.xs && this.enablesXDR;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function () {
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

Request.requestsCount = 0;
Request.requests = {};

if (global.document) {
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler, false);
  }
}

function unloadHandler () {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * Module dependencies.
 */

var Transport = __webpack_require__(42);
var parser = __webpack_require__(20);
var parseqs = __webpack_require__(46);
var inherit = __webpack_require__(31);
var yeast = __webpack_require__(116);
var debug = __webpack_require__(33)('engine.io-client:websocket');
var BrowserWebSocket = global.WebSocket || global.MozWebSocket;
var NodeWebSocket;
if (typeof window === 'undefined') {
  try {
    NodeWebSocket = __webpack_require__(269);
  } catch (e) { }
}

/**
 * Get either the `WebSocket` or `MozWebSocket` globals
 * in the browser or try to resolve WebSocket-compatible
 * interface exposed by `ws` for Node-like environment.
 */

var WebSocket = BrowserWebSocket;
if (!WebSocket && typeof window === 'undefined') {
  WebSocket = NodeWebSocket;
}

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS (opts) {
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  this.perMessageDeflate = opts.perMessageDeflate;
  this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
  if (!this.usingBrowserWebSocket) {
    WebSocket = NodeWebSocket;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function () {
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var uri = this.uri();
  var protocols = void (0);
  var opts = {
    agent: this.agent,
    perMessageDeflate: this.perMessageDeflate
  };

  // SSL options for Node.js client
  opts.pfx = this.pfx;
  opts.key = this.key;
  opts.passphrase = this.passphrase;
  opts.cert = this.cert;
  opts.ca = this.ca;
  opts.ciphers = this.ciphers;
  opts.rejectUnauthorized = this.rejectUnauthorized;
  if (this.extraHeaders) {
    opts.headers = this.extraHeaders;
  }
  if (this.localAddress) {
    opts.localAddress = this.localAddress;
  }

  try {
    this.ws = this.usingBrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);
  } catch (err) {
    return this.emit('error', err);
  }

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  if (this.ws.supports && this.ws.supports.binary) {
    this.supportsBinary = true;
    this.ws.binaryType = 'nodebuffer';
  } else {
    this.ws.binaryType = 'arraybuffer';
  }

  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function () {
  var self = this;

  this.ws.onopen = function () {
    self.onOpen();
  };
  this.ws.onclose = function () {
    self.onClose();
  };
  this.ws.onmessage = function (ev) {
    self.onData(ev.data);
  };
  this.ws.onerror = function (e) {
    self.onError('websocket error', e);
  };
};

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function (packets) {
  var self = this;
  this.writable = false;

  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  var total = packets.length;
  for (var i = 0, l = total; i < l; i++) {
    (function (packet) {
      parser.encodePacket(packet, self.supportsBinary, function (data) {
        if (!self.usingBrowserWebSocket) {
          // always create a new object (GH-437)
          var opts = {};
          if (packet.options) {
            opts.compress = packet.options.compress;
          }

          if (self.perMessageDeflate) {
            var len = 'string' === typeof data ? global.Buffer.byteLength(data) : data.length;
            if (len < self.perMessageDeflate.threshold) {
              opts.compress = false;
            }
          }
        }

        // Sometimes the websocket has already been closed but the browser didn't
        // have a chance of informing us about it yet, in that case send will
        // throw an error
        try {
          if (self.usingBrowserWebSocket) {
            // TypeError is thrown when passing the second argument on Safari
            self.ws.send(data);
          } else {
            self.ws.send(data, opts);
          }
        } catch (e) {
          debug('websocket closed before onclose event');
        }

        --total || done();
      });
    })(packets[i]);
  }

  function done () {
    self.emit('flush');

    // fake drain
    // defer to next tick to allow Socket to clear writeBuffer
    setTimeout(function () {
      self.writable = true;
      self.emit('drain');
    }, 0);
  }
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function () {
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function () {
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function () {
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' === schema && Number(this.port) !== 443) ||
    ('ws' === schema && Number(this.port) !== 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = yeast();
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  var ipv6 = this.hostname.indexOf(':') !== -1;
  return schema + '://' + (ipv6 ? '[' + this.hostname + ']' : this.hostname) + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function () {
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug.debug = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(80);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting
    args = exports.formatArgs.apply(self, args);

    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 144 */
/***/ (function(module, exports) {


/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var camelize = __webpack_require__(145);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = __webpack_require__(155);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = __webpack_require__(1);

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : void 0;

  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object can\'t be `arguments`. Use rest params ' + '(function(...args) {}) or Array.from() instead.') : invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    typeof obj == 'object' || typeof obj == 'function') &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    Array.isArray(obj) ||
    // arguments
    'callee' in obj ||
    // HTMLCollection/NodeList
    'item' in obj)
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = __webpack_require__(6);

var createArrayFromMixed = __webpack_require__(148);
var getMarkupWrap = __webpack_require__(150);
var invariant = __webpack_require__(1);

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = __webpack_require__(6);

var invariant = __webpack_require__(1);

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;

/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(152);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = __webpack_require__(154);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */



/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;

/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */



var ExecutionEnvironment = __webpack_require__(6);

var performance;

if (ExecutionEnvironment.canUseDOM) {
  performance = window.performance || window.msPerformance || window.webkitPerformance;
}

module.exports = performance || {};

/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var performance = __webpack_require__(157);

var performanceNow;

/**
 * Detect if we can use `window.performance.now()` and gracefully fallback to
 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
 * because of Facebook's testing infrastructure.
 */
if (performance.now) {
  performanceNow = function performanceNow() {
    return performance.now();
  };
} else {
  performanceNow = function performanceNow() {
    return Date.now();
  };
}

module.exports = performanceNow;

/***/ }),
/* 159 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 160 */
/***/ (function(module, exports) {


/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = typeof XMLHttpRequest !== 'undefined' &&
    'withCredentials' in new XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = "function" === "function" && __webpack_require__(267);

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
      return JSON3;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).call(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(115)(module), __webpack_require__(7)))

/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;

/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMComponentTree = __webpack_require__(5);

var focusNode = __webpack_require__(76);

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;

/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(26);
var ExecutionEnvironment = __webpack_require__(6);
var FallbackCompositionState = __webpack_require__(171);
var SyntheticCompositionEvent = __webpack_require__(214);
var SyntheticInputEvent = __webpack_require__(217);

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;

/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(83);
var ExecutionEnvironment = __webpack_require__(6);
var ReactInstrumentation = __webpack_require__(9);

var camelizeStyleName = __webpack_require__(146);
var dangerousStyleValue = __webpack_require__(224);
var hyphenateStyleName = __webpack_require__(153);
var memoizeStringOnly = __webpack_require__(156);
var warning = __webpack_require__(2);

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

if (process.env.NODE_ENV !== 'production') {
  // 'msTransform' is correct, but the other prefixes should be capitalized
  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;

  // style values shouldn't contain a semicolon
  var badStyleValueWithSemicolonPattern = /;\s*$/;

  var warnedStyleNames = {};
  var warnedStyleValues = {};
  var warnedForNaNValue = false;

  var warnHyphenatedStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?%s', name, camelizeStyleName(name), checkRenderMessage(owner)) : void 0;
  };

  var warnBadVendoredStyleName = function (name, owner) {
    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
      return;
    }

    warnedStyleNames[name] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?%s', name, name.charAt(0).toUpperCase() + name.slice(1), checkRenderMessage(owner)) : void 0;
  };

  var warnStyleValueWithSemicolon = function (name, value, owner) {
    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
      return;
    }

    warnedStyleValues[value] = true;
    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon.%s ' + 'Try "%s: %s" instead.', checkRenderMessage(owner), name, value.replace(badStyleValueWithSemicolonPattern, '')) : void 0;
  };

  var warnStyleValueIsNaN = function (name, value, owner) {
    if (warnedForNaNValue) {
      return;
    }

    warnedForNaNValue = true;
    process.env.NODE_ENV !== 'production' ? warning(false, '`NaN` is an invalid value for the `%s` css style property.%s', name, checkRenderMessage(owner)) : void 0;
  };

  var checkRenderMessage = function (owner) {
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' Check the render method of `' + name + '`.';
      }
    }
    return '';
  };

  /**
   * @param {string} name
   * @param {*} value
   * @param {ReactDOMComponent} component
   */
  var warnValidStyle = function (name, value, component) {
    var owner;
    if (component) {
      owner = component._currentElement._owner;
    }
    if (name.indexOf('-') > -1) {
      warnHyphenatedStyleName(name, owner);
    } else if (badVendoredStyleNamePattern.test(name)) {
      warnBadVendoredStyleName(name, owner);
    } else if (badStyleValueWithSemicolonPattern.test(value)) {
      warnStyleValueWithSemicolon(name, value, owner);
    }

    if (typeof value === 'number' && isNaN(value)) {
      warnStyleValueIsNaN(name, value, owner);
    }
  };
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styleValue, component);
      }
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    if (process.env.NODE_ENV !== 'production') {
      ReactInstrumentation.debugTool.onHostOperation({
        instanceID: component._debugID,
        type: 'update styles',
        payload: styles
      });
    }

    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      if (process.env.NODE_ENV !== 'production') {
        warnValidStyle(styleName, styles[styleName], component);
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);
var EventPropagators = __webpack_require__(26);
var ExecutionEnvironment = __webpack_require__(6);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(11);
var SyntheticEvent = __webpack_require__(13);

var getEventTarget = __webpack_require__(58);
var isEventSupported = __webpack_require__(59);
var isTextInputElement = __webpack_require__(101);

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

module.exports = ChangeEventPlugin;

/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var DOMLazyTree = __webpack_require__(21);
var ExecutionEnvironment = __webpack_require__(6);

var createNodesFromMarkup = __webpack_require__(149);
var emptyFunction = __webpack_require__(10);
var invariant = __webpack_require__(1);

var Danger = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a worker thread. Make sure `window` and `document` are available globally before requiring React when unit testing or use ReactDOMServer.renderToString() for server rendering.') : _prodInvariant('56') : void 0;
    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the <html> node. This is because browser quirks make this unreliable and/or slow. If you want to render to the root you must use server rendering. See ReactDOMServer.renderToString().') : _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;

/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(26);
var ReactDOMComponentTree = __webpack_require__(5);
var SyntheticMouseEvent = __webpack_require__(36);

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;

/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(17);

var getTextContentAccessor = __webpack_require__(99);

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;

/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(15);

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

module.exports = HTMLDOMPropertyConfig;

/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactReconciler = __webpack_require__(22);

var instantiateReactComponent = __webpack_require__(100);
var KeyEscapeUtils = __webpack_require__(50);
var shouldUpdateReactComponent = __webpack_require__(60);
var traverseAllChildren = __webpack_require__(103);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(8);
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (process.env.NODE_ENV !== 'production') {
    if (!ReactComponentTreeHook) {
      ReactComponentTreeHook = __webpack_require__(8);
    }
    if (!keyUnique) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
    }
  }
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    if (process.env.NODE_ENV !== 'production') {
      traverseAllChildren(nestedChildNodes, function (childInsts, child, name) {
        return instantiateChild(childInsts, child, name, selfDebugID);
      }, childInstances);
    } else {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(47);
var ReactDOMIDOperations = __webpack_require__(181);

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

module.exports = ReactComponentBrowserEnvironment;

/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var React = __webpack_require__(23);
var ReactComponentEnvironment = __webpack_require__(52);
var ReactCurrentOwner = __webpack_require__(12);
var ReactErrorUtils = __webpack_require__(53);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(9);
var ReactNodeTypes = __webpack_require__(93);
var ReactReconciler = __webpack_require__(22);

if (process.env.NODE_ENV !== 'production') {
  var checkReactTypeSpec = __webpack_require__(223);
}

var emptyObject = __webpack_require__(24);
var invariant = __webpack_require__(1);
var shallowEqual = __webpack_require__(45);
var shouldUpdateReactComponent = __webpack_require__(60);
var warning = __webpack_require__(2);

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(element === null || element === false || React.isValidElement(element), '%s(...): A valid React element (or null) must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(!Component.childContextTypes, '%s(...): childContextTypes cannot be defined on a functional component.', Component.displayName || Component.name || 'Component') : void 0;
  }
}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;

    if (process.env.NODE_ENV !== 'production') {
      this._warnedAboutRefsInRender = false;
    }
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s(...): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', Component.displayName || Component.name || 'Component') : _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      // This will throw later in _renderValidatedComponent, but add an early
      // warning now to help debugging
      if (inst.render == null) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`.', Component.displayName || Component.name || 'Component') : void 0;
      }

      var propsMutated = inst.props !== publicProps;
      var componentName = Component.displayName || Component.name || 'Component';

      process.env.NODE_ENV !== 'production' ? warning(inst.props === undefined || !propsMutated, '%s(...): When calling super() in `%s`, make sure to pass ' + 'up the same props that your component\'s constructor was passed.', componentName, componentName) : void 0;
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    if (process.env.NODE_ENV !== 'production') {
      // Since plain JS classes are defined without any special initialization
      // logic, we can not catch common errors early. Therefore, we have to
      // catch them here, at initialization time, instead.
      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved || inst.state, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : void 0;
    }

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(function () {
            return inst.componentDidMount();
          }, _this._debugID, 'componentDidMount');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    if (process.env.NODE_ENV !== 'production') {
      ReactCurrentOwner.current = this;
      try {
        return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      if (process.env.NODE_ENV !== 'production') {
        return measureLifeCyclePerf(function () {
          return new Component(publicProps, publicContext, updateQueue);
        }, this._debugID, 'ctor');
      } else {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    // This can still be an instance in case of factory components
    // but we'll count this as time spent rendering as the more common case.
    if (process.env.NODE_ENV !== 'production') {
      return measureLifeCyclePerf(function () {
        return Component(publicProps, publicContext, updateQueue);
      }, this._debugID, 'render');
    } else {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (inst.componentWillMount) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillMount();
        }, debugID, 'componentWillMount');
      } else {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    if (process.env.NODE_ENV !== 'production') {
      if (debugID !== 0) {
        var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
        ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
      }
    }

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        if (process.env.NODE_ENV !== 'production') {
          measureLifeCyclePerf(function () {
            return inst.componentWillUnmount();
          }, this._debugID, 'componentWillUnmount');
        } else {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    if (process.env.NODE_ENV !== 'production') {
      var Component = this._currentElement.type;
      if (Component.contextTypes) {
        this._checkContextTypes(Component.contextTypes, maskedContext, 'context');
      }
    }
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onBeginProcessingChildContext();
        try {
          childContext = inst.getChildContext();
        } finally {
          ReactInstrumentation.debugTool.onEndProcessingChildContext();
        }
      } else {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().', this.getName() || 'ReactCompositeComponent') : _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      if (process.env.NODE_ENV !== 'production') {
        this._checkContextTypes(Component.childContextTypes, childContext, 'childContext');
      }
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {
    if (process.env.NODE_ENV !== 'production') {
      checkReactTypeSpec(typeSpecs, values, location, this.getName(), null, this._debugID);
    }
  },

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Attempted to update component `%s` that has already been unmounted (or failed to mount).', this.getName() || 'ReactCompositeComponent') : _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillReceiveProps(nextProps, nextContext);
        }, this._debugID, 'componentWillReceiveProps');
      } else {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        if (process.env.NODE_ENV !== 'production') {
          shouldUpdate = measureLifeCyclePerf(function () {
            return inst.shouldComponentUpdate(nextProps, nextState, nextContext);
          }, this._debugID, 'shouldComponentUpdate');
        } else {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(shouldUpdate !== undefined, '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : void 0;
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        measureLifeCyclePerf(function () {
          return inst.componentWillUpdate(nextProps, nextState, nextContext);
        }, this._debugID, 'componentWillUpdate');
      } else {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      if (process.env.NODE_ENV !== 'production') {
        transaction.getReactMountReady().enqueue(function () {
          measureLifeCyclePerf(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), _this2._debugID, 'componentDidUpdate');
        });
      } else {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;
    if (process.env.NODE_ENV !== 'production') {
      debugID = this._debugID;
    }

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      if (process.env.NODE_ENV !== 'production') {
        if (debugID !== 0) {
          var childDebugIDs = child._debugID !== 0 ? [child._debugID] : [];
          ReactInstrumentation.debugTool.onSetChildren(debugID, childDebugIDs);
        }
      }

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    if (process.env.NODE_ENV !== 'production') {
      renderedElement = measureLifeCyclePerf(function () {
        return inst.render();
      }, this._debugID, 'render');
    } else {
      renderedElement = inst.render();
    }

    if (process.env.NODE_ENV !== 'production') {
      // We allow auto-mocks to proceed as if they're returning null.
      if (renderedElement === undefined && inst.render._isMockFunction) {
        // This is probably bad practice. Consider warning here and
        // deprecating this convenience.
        renderedElement = null;
      }
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if (process.env.NODE_ENV !== 'production' || this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    renderedElement === null || renderedElement === false || React.isValidElement(renderedElement)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid React element (or null) must be returned. You may have returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    if (process.env.NODE_ENV !== 'production') {
      var componentName = component && component.getName ? component.getName() : 'a component';
      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null || component._compositeType !== CompositeTypes.StatelessFunctional, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : void 0;
    }
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

module.exports = ReactCompositeComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/



var ReactDOMComponentTree = __webpack_require__(5);
var ReactDefaultInjection = __webpack_require__(193);
var ReactMount = __webpack_require__(92);
var ReactReconciler = __webpack_require__(22);
var ReactUpdates = __webpack_require__(11);
var ReactVersion = __webpack_require__(208);

var findDOMNode = __webpack_require__(225);
var getHostComponentFromComposite = __webpack_require__(98);
var renderSubtreeIntoContainer = __webpack_require__(233);
var warning = __webpack_require__(2);

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

if (process.env.NODE_ENV !== 'production') {
  var ExecutionEnvironment = __webpack_require__(6);
  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {

    // First check if devtools is not installed
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
      // If we're in Chrome or Firefox, provide a download link if not installed.
      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
        // Firefox does not have the issue with devtools loaded over file://
        var showFileUrlMessage = window.location.protocol.indexOf('http') === -1 && navigator.userAgent.indexOf('Firefox') === -1;
        console.debug('Download the React DevTools ' + (showFileUrlMessage ? 'and use an HTTP server (instead of a file: URL) ' : '') + 'for a better development experience: ' + 'https://fb.me/react-devtools');
      }
    }

    var testFunc = function testFn() {};
    process.env.NODE_ENV !== 'production' ? warning((testFunc.name || testFunc.toString()).indexOf('testFn') !== -1, 'It looks like you\'re using a minified copy of the development build ' + 'of React. When deploying React apps to production, make sure to use ' + 'the production build which skips development warnings and is faster. ' + 'See https://fb.me/react-minification for more details.') : void 0;

    // If we're in IE8, check to see if we are in compatibility mode and provide
    // information on preventing compatibility mode
    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;

    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : void 0;

    var expectedFeatures = [
    // shims
    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.trim];

    for (var i = 0; i < expectedFeatures.length; i++) {
      if (!expectedFeatures[i]) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'One or more ES5 shims expected by React are not available: ' + 'https://fb.me/react-warning-polyfills') : void 0;
        break;
      }
    }
  }
}

if (process.env.NODE_ENV !== 'production') {
  var ReactInstrumentation = __webpack_require__(9);
  var ReactDOMUnknownPropertyHook = __webpack_require__(190);
  var ReactDOMNullInputValuePropHook = __webpack_require__(184);
  var ReactDOMInvalidARIAHook = __webpack_require__(183);

  ReactInstrumentation.debugTool.addHook(ReactDOMUnknownPropertyHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMNullInputValuePropHook);
  ReactInstrumentation.debugTool.addHook(ReactDOMInvalidARIAHook);
}

module.exports = ReactDOM;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var AutoFocusUtils = __webpack_require__(164);
var CSSPropertyOperations = __webpack_require__(166);
var DOMLazyTree = __webpack_require__(21);
var DOMNamespaces = __webpack_require__(48);
var DOMProperty = __webpack_require__(15);
var DOMPropertyOperations = __webpack_require__(85);
var EventPluginHub = __webpack_require__(25);
var EventPluginRegistry = __webpack_require__(34);
var ReactBrowserEventEmitter = __webpack_require__(35);
var ReactDOMComponentFlags = __webpack_require__(86);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMInput = __webpack_require__(182);
var ReactDOMOption = __webpack_require__(185);
var ReactDOMSelect = __webpack_require__(87);
var ReactDOMTextarea = __webpack_require__(188);
var ReactInstrumentation = __webpack_require__(9);
var ReactMultiChild = __webpack_require__(201);
var ReactServerRenderingTransaction = __webpack_require__(206);

var emptyFunction = __webpack_require__(10);
var escapeTextContentForBrowser = __webpack_require__(38);
var invariant = __webpack_require__(1);
var isEventSupported = __webpack_require__(59);
var shallowEqual = __webpack_require__(45);
var validateDOMNesting = __webpack_require__(61);
var warning = __webpack_require__(2);

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.') : _prodInvariant('61') : void 0;
  }
  if (process.env.NODE_ENV !== 'production') {
    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.suppressContentEditableWarning || !props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : void 0;
    process.env.NODE_ENV !== 'production' ? warning(props.onFocusIn == null && props.onFocusOut == null, 'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. ' + 'All React events are normalized to bubble, so onFocusIn and onFocusOut ' + 'are not needed/supported by React.') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s', getDeclarationErrorAddendum(component)) : _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // IE8 has no API for event capturing and the `onScroll` event doesn't
    // bubble.
    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : void 0;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  setAndValidateContentChildDev = function (content) {
    var hasExistingContent = this._contentDebugID != null;
    var debugID = this._debugID;
    // This ID represents the inlined child that has no backing instance:
    var contentDebugID = -debugID;

    if (content == null) {
      if (hasExistingContent) {
        ReactInstrumentation.debugTool.onUnmountComponent(this._contentDebugID);
      }
      this._contentDebugID = null;
      return;
    }

    validateDOMNesting(null, String(content), this, this._ancestorInfo);
    this._contentDebugID = contentDebugID;
    if (hasExistingContent) {
      ReactInstrumentation.debugTool.onBeforeUpdateComponent(contentDebugID, content);
      ReactInstrumentation.debugTool.onUpdateComponent(contentDebugID);
    } else {
      ReactInstrumentation.debugTool.onBeforeMountComponent(contentDebugID, content, debugID);
      ReactInstrumentation.debugTool.onMountComponent(contentDebugID);
      ReactInstrumentation.debugTool.onSetChildren(debugID, [contentDebugID]);
    }
  };
}

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
  if (process.env.NODE_ENV !== 'production') {
    this._ancestorInfo = null;
    setAndValidateContentChildDev.call(this, null);
  }
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo._tag) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(this._tag, null, this, parentInfo);
      }
      this._ancestorInfo = validateDOMNesting.updatedAncestorInfo(parentInfo, this._tag, this);
    }

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            if (process.env.NODE_ENV !== 'production') {
              // See `_updateDOMProperties`. style block
              this._previousStyle = propValue;
            }
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      // TODO: Validate that text is allowed as a child of this node
      if (contentToUse != null) {
        // Avoid setting textContent when the text is empty. In IE11 setting
        // textContent on a text area will cause the placeholder to not
        // show within the textarea until it has been focused and blurred again.
        // https://github.com/facebook/react/issues/6731#issuecomment-254874553
        if (contentToUse !== '') {
          if (process.env.NODE_ENV !== 'production') {
            setAndValidateContentChildDev.call(this, contentToUse);
          }
          DOMLazyTree.queueText(lazyTree, contentToUse);
        }
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          if (process.env.NODE_ENV !== 'production') {
            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
            this._previousStyle = nextProp;
          }
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
        if (process.env.NODE_ENV !== 'production') {
          setAndValidateContentChildDev.call(this, nextContent);
        }
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
      if (process.env.NODE_ENV !== 'production') {
        ReactInstrumentation.debugTool.onSetChildren(this._debugID, []);
      }
    } else if (nextChildren != null) {
      if (process.env.NODE_ENV !== 'production') {
        setAndValidateContentChildDev.call(this, null);
      }

      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is impossible to unmount some top-level components (eg <html>, <head>, and <body>) reliably and efficiently. To fix this, have a single top-level component that never unmounts render these elements.', this._tag) : _prodInvariant('66', this._tag) : void 0;
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;

    if (process.env.NODE_ENV !== 'production') {
      setAndValidateContentChildDev.call(this, null);
    }
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var validateDOMNesting = __webpack_require__(61);

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  if (process.env.NODE_ENV !== 'production') {
    info._ancestorInfo = node ? validateDOMNesting.updatedAncestorInfo(null, info._tag, null) : null;
  }
  return info;
}

module.exports = ReactDOMContainerInfo;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var DOMLazyTree = __webpack_require__(21);
var ReactDOMComponentTree = __webpack_require__(5);

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;

/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;

/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMChildrenOperations = __webpack_require__(47);
var ReactDOMComponentTree = __webpack_require__(5);

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var DOMPropertyOperations = __webpack_require__(85);
var LinkedValueUtils = __webpack_require__(51);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(11);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);

      var owner = inst._currentElement._owner;

      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.checkedLink !== undefined && !didWarnCheckedLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`checkedLink` prop on `input` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnCheckedLink = true;
      }
      if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both checked and defaultChecked props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the checked prop, or the defaultChecked prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnCheckedDefaultChecked = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s contains an input of type %s with both value and defaultValue props. ' + 'Input elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled input ' + 'element and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnValueDefaultValue = true;
      }
    }

    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };

    if (process.env.NODE_ENV !== 'production') {
      inst._wrapperState.controlled = isControlled(props);
    }
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    if (process.env.NODE_ENV !== 'production') {
      var controlled = isControlled(props);
      var owner = inst._currentElement._owner;

      if (!inst._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing an uncontrolled input of type %s to be controlled. ' + 'Input elements should not switch from uncontrolled to controlled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnUncontrolledToControlled = true;
      }
      if (inst._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
        process.env.NODE_ENV !== 'production' ? warning(false, '%s is changing a controlled input of type %s to be uncontrolled. ' + 'Input elements should not switch from controlled to uncontrolled (or vice versa). ' + 'Decide between using a controlled or uncontrolled input ' + 'element for the lifetime of the component. More info: https://fb.me/react-controlled-components', owner && owner.getName() || 'A component', props.type) : void 0;
        didWarnControlledToUncontrolled = true;
      }
    }

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {

      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        // In Chrome, assigning defaultValue to certain input types triggers input validation.
        // For number inputs, the display value loses trailing decimal points. For email inputs,
        // Chrome raises "The specified value <x> is not a valid email address".
        //
        // Here we check to see if the defaultValue has actually changed, avoiding these problems
        // when the user is inputting text
        //
        // https://github.com/facebook/react/issues/7253
        if (node.defaultValue !== '' + props.defaultValue) {
          node.defaultValue = '' + props.defaultValue;
        }
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.') : _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(15);
var ReactComponentTreeHook = __webpack_require__(8);

var warning = __webpack_require__(2);

var warnedProperties = {};
var rARIA = new RegExp('^(aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');

function validateProperty(tagName, name, debugID) {
  if (warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
    return true;
  }

  if (rARIA.test(name)) {
    var lowerCasedName = name.toLowerCase();
    var standardName = DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    // If this is an aria-* attribute, but is not listed in the known DOM
    // DOM properties, then it is an invalid aria-* attribute.
    if (standardName == null) {
      warnedProperties[name] = true;
      return false;
    }
    // aria-* attributes should be lowercase; suggest the lowercase version.
    if (name !== standardName) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown ARIA attribute %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      warnedProperties[name] = true;
      return true;
    }
  }

  return true;
}

function warnInvalidARIAProps(debugID, element) {
  var invalidProps = [];

  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      invalidProps.push(key);
    }
  }

  var unknownPropString = invalidProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (invalidProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria prop %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (invalidProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid aria props %s on <%s> tag. ' + 'For details, see https://fb.me/invalid-aria-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
}

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }

  warnInvalidARIAProps(debugID, element);
}

var ReactDOMInvalidARIAHook = {
  onBeforeMountComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  },
  onBeforeUpdateComponent: function (debugID, element) {
    if (process.env.NODE_ENV !== 'production') {
      handleElement(debugID, element);
    }
  }
};

module.exports = ReactDOMInvalidARIAHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactComponentTreeHook = __webpack_require__(8);

var warning = __webpack_require__(2);

var didWarnValueNull = false;

function handleElement(debugID, element) {
  if (element == null) {
    return;
  }
  if (element.type !== 'input' && element.type !== 'textarea' && element.type !== 'select') {
    return;
  }
  if (element.props != null && element.props.value === null && !didWarnValueNull) {
    process.env.NODE_ENV !== 'production' ? warning(false, '`value` prop on `%s` should not be null. ' + 'Consider using the empty string to clear the component or `undefined` ' + 'for uncontrolled components.%s', element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;

    didWarnValueNull = true;
  }
}

var ReactDOMNullInputValuePropHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMNullInputValuePropHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var React = __webpack_require__(23);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMSelect = __webpack_require__(87);

var warning = __webpack_require__(2);
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // TODO (yungsters): Remove support for `selected` in <option>.
    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : void 0;
    }

    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

module.exports = ReactDOMOption;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

var getNodeForCharacterOffset = __webpack_require__(230);
var getTextContentAccessor = __webpack_require__(99);

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var DOMChildrenOperations = __webpack_require__(47);
var DOMLazyTree = __webpack_require__(21);
var ReactDOMComponentTree = __webpack_require__(5);

var escapeTextContentForBrowser = __webpack_require__(38);
var invariant = __webpack_require__(1);
var validateDOMNesting = __webpack_require__(61);

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    if (process.env.NODE_ENV !== 'production') {
      var parentInfo;
      if (hostParent != null) {
        parentInfo = hostParent._ancestorInfo;
      } else if (hostContainerInfo != null) {
        parentInfo = hostContainerInfo._ancestorInfo;
      }
      if (parentInfo) {
        // parentInfo should always be present except for the top-level
        // component when server rendering
        validateDOMNesting(null, this._stringText, this, parentInfo);
      }
    }

    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Missing closing comment for text component %s', this._domID) : _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3),
    _assign = __webpack_require__(4);

var LinkedValueUtils = __webpack_require__(51);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(11);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    if (process.env.NODE_ENV !== 'production') {
      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
      if (props.valueLink !== undefined && !didWarnValueLink) {
        process.env.NODE_ENV !== 'production' ? warning(false, '`valueLink` prop on `textarea` is deprecated; set `value` and `onChange` instead.') : void 0;
        didWarnValueLink = true;
      }
      if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'Textarea elements must be either controlled or uncontrolled ' + '(specify either the value prop, or the defaultValue prop, but not ' + 'both). Decide between using a controlled or uncontrolled textarea ' + 'and remove one of these props. More info: ' + 'https://fb.me/react-controlled-components') : void 0;
        didWarnValDefaultVal = true;
      }
    }

    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        if (process.env.NODE_ENV !== 'production') {
          process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : void 0;
        }
        !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var textContent = node.textContent;

    // Only set node.value if textContent is equal to the expected
    // initial value. In IE10/IE11 there is a bug where the placeholder attribute
    // will populate textContent as well.
    // https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
    if (textContent === inst._wrapperState.initialValue) {
      node.value = textContent;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNodeFromInstance: Invalid argument.') : _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'isAncestor: Invalid argument.') : _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getParentInstance: Invalid argument.') : _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(15);
var EventPluginRegistry = __webpack_require__(34);
var ReactComponentTreeHook = __webpack_require__(8);

var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var reactProps = {
    children: true,
    dangerouslySetInnerHTML: true,
    key: true,
    ref: true,

    autoFocus: true,
    defaultValue: true,
    valueLink: true,
    defaultChecked: true,
    checkedLink: true,
    innerHTML: true,
    suppressContentEditableWarning: true,
    onFocusIn: true,
    onFocusOut: true
  };
  var warnedProperties = {};

  var validateProperty = function (tagName, name, debugID) {
    if (DOMProperty.properties.hasOwnProperty(name) || DOMProperty.isCustomAttribute(name)) {
      return true;
    }
    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
      return true;
    }
    if (EventPluginRegistry.registrationNameModules.hasOwnProperty(name)) {
      return true;
    }
    warnedProperties[name] = true;
    var lowerCasedName = name.toLowerCase();

    // data-* attributes should be lowercase; suggest the lowercase version
    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;

    var registrationName = EventPluginRegistry.possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? EventPluginRegistry.possibleRegistrationNames[lowerCasedName] : null;

    if (standardName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown DOM property %s. Did you mean %s?%s', name, standardName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else if (registrationName != null) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown event handler property %s. Did you mean `%s`?%s', name, registrationName, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
      return true;
    } else {
      // We were unable to guess which prop the user intended.
      // It is likely that the user was just blindly spreading/forwarding props
      // Components should be careful to only render valid props/attributes.
      // Warning will be invoked in warnUnknownProperties to allow grouping.
      return false;
    }
  };
}

var warnUnknownProperties = function (debugID, element) {
  var unknownProps = [];
  for (var key in element.props) {
    var isValid = validateProperty(element.type, key, debugID);
    if (!isValid) {
      unknownProps.push(key);
    }
  }

  var unknownPropString = unknownProps.map(function (prop) {
    return '`' + prop + '`';
  }).join(', ');

  if (unknownProps.length === 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown prop %s on <%s> tag. Remove this prop from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  } else if (unknownProps.length > 1) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Unknown props %s on <%s> tag. Remove these props from the element. ' + 'For details, see https://fb.me/react-unknown-prop%s', unknownPropString, element.type, ReactComponentTreeHook.getStackAddendumByID(debugID)) : void 0;
  }
};

function handleElement(debugID, element) {
  if (element == null || typeof element.type !== 'string') {
    return;
  }
  if (element.type.indexOf('-') >= 0 || element.props.is) {
    return;
  }
  warnUnknownProperties(debugID, element);
}

var ReactDOMUnknownPropertyHook = {
  onBeforeMountComponent: function (debugID, element) {
    handleElement(debugID, element);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    handleElement(debugID, element);
  }
};

module.exports = ReactDOMUnknownPropertyHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactInvalidSetStateWarningHook = __webpack_require__(199);
var ReactHostOperationHistoryHook = __webpack_require__(197);
var ReactComponentTreeHook = __webpack_require__(8);
var ExecutionEnvironment = __webpack_require__(6);

var performanceNow = __webpack_require__(158);
var warning = __webpack_require__(2);

var hooks = [];
var didHookThrowForEvent = {};

function callHook(event, fn, context, arg1, arg2, arg3, arg4, arg5) {
  try {
    fn.call(context, arg1, arg2, arg3, arg4, arg5);
  } catch (e) {
    process.env.NODE_ENV !== 'production' ? warning(didHookThrowForEvent[event], 'Exception thrown by hook while handling %s: %s', event, e + '\n' + e.stack) : void 0;
    didHookThrowForEvent[event] = true;
  }
}

function emitEvent(event, arg1, arg2, arg3, arg4, arg5) {
  for (var i = 0; i < hooks.length; i++) {
    var hook = hooks[i];
    var fn = hook[event];
    if (fn) {
      callHook(event, fn, hook, arg1, arg2, arg3, arg4, arg5);
    }
  }
}

var isProfiling = false;
var flushHistory = [];
var lifeCycleTimerStack = [];
var currentFlushNesting = 0;
var currentFlushMeasurements = [];
var currentFlushStartTime = 0;
var currentTimerDebugID = null;
var currentTimerStartTime = 0;
var currentTimerNestedFlushDuration = 0;
var currentTimerType = null;

var lifeCycleTimerHasWarned = false;

function clearHistory() {
  ReactComponentTreeHook.purgeUnmountedComponents();
  ReactHostOperationHistoryHook.clearHistory();
}

function getTreeSnapshot(registeredIDs) {
  return registeredIDs.reduce(function (tree, id) {
    var ownerID = ReactComponentTreeHook.getOwnerID(id);
    var parentID = ReactComponentTreeHook.getParentID(id);
    tree[id] = {
      displayName: ReactComponentTreeHook.getDisplayName(id),
      text: ReactComponentTreeHook.getText(id),
      updateCount: ReactComponentTreeHook.getUpdateCount(id),
      childIDs: ReactComponentTreeHook.getChildIDs(id),
      // Text nodes don't have owners but this is close enough.
      ownerID: ownerID || parentID && ReactComponentTreeHook.getOwnerID(parentID) || 0,
      parentID: parentID
    };
    return tree;
  }, {});
}

function resetMeasurements() {
  var previousStartTime = currentFlushStartTime;
  var previousMeasurements = currentFlushMeasurements;
  var previousOperations = ReactHostOperationHistoryHook.getHistory();

  if (currentFlushNesting === 0) {
    currentFlushStartTime = 0;
    currentFlushMeasurements = [];
    clearHistory();
    return;
  }

  if (previousMeasurements.length || previousOperations.length) {
    var registeredIDs = ReactComponentTreeHook.getRegisteredIDs();
    flushHistory.push({
      duration: performanceNow() - previousStartTime,
      measurements: previousMeasurements || [],
      operations: previousOperations || [],
      treeSnapshot: getTreeSnapshot(registeredIDs)
    });
  }

  clearHistory();
  currentFlushStartTime = performanceNow();
  currentFlushMeasurements = [];
}

function checkDebugID(debugID) {
  var allowRoot = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  if (allowRoot && debugID === 0) {
    return;
  }
  if (!debugID) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDebugTool: debugID may not be empty.') : void 0;
  }
}

function beginLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'Did not expect %s timer to start while %s timer is still in ' + 'progress for %s instance.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  currentTimerStartTime = performanceNow();
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

function endLifeCycleTimer(debugID, timerType) {
  if (currentFlushNesting === 0) {
    return;
  }
  if (currentTimerType !== timerType && !lifeCycleTimerHasWarned) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'There is an internal error in the React performance measurement code. ' + 'We did not expect %s timer to stop while %s timer is still in ' + 'progress for %s instance. Please report this as a bug in React.', timerType, currentTimerType || 'no', debugID === currentTimerDebugID ? 'the same' : 'another') : void 0;
    lifeCycleTimerHasWarned = true;
  }
  if (isProfiling) {
    currentFlushMeasurements.push({
      timerType: timerType,
      instanceID: debugID,
      duration: performanceNow() - currentTimerStartTime - currentTimerNestedFlushDuration
    });
  }
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function pauseCurrentLifeCycleTimer() {
  var currentTimer = {
    startTime: currentTimerStartTime,
    nestedFlushStartTime: performanceNow(),
    debugID: currentTimerDebugID,
    timerType: currentTimerType
  };
  lifeCycleTimerStack.push(currentTimer);
  currentTimerStartTime = 0;
  currentTimerNestedFlushDuration = 0;
  currentTimerDebugID = null;
  currentTimerType = null;
}

function resumeCurrentLifeCycleTimer() {
  var _lifeCycleTimerStack$ = lifeCycleTimerStack.pop(),
      startTime = _lifeCycleTimerStack$.startTime,
      nestedFlushStartTime = _lifeCycleTimerStack$.nestedFlushStartTime,
      debugID = _lifeCycleTimerStack$.debugID,
      timerType = _lifeCycleTimerStack$.timerType;

  var nestedFlushDuration = performanceNow() - nestedFlushStartTime;
  currentTimerStartTime = startTime;
  currentTimerNestedFlushDuration += nestedFlushDuration;
  currentTimerDebugID = debugID;
  currentTimerType = timerType;
}

var lastMarkTimeStamp = 0;
var canUsePerformanceMeasure =
// $FlowFixMe https://github.com/facebook/flow/issues/2345
typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';

function shouldMark(debugID) {
  if (!isProfiling || !canUsePerformanceMeasure) {
    return false;
  }
  var element = ReactComponentTreeHook.getElement(debugID);
  if (element == null || typeof element !== 'object') {
    return false;
  }
  var isHostElement = typeof element.type === 'string';
  if (isHostElement) {
    return false;
  }
  return true;
}

function markBegin(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  lastMarkTimeStamp = performanceNow();
  performance.mark(markName);
}

function markEnd(debugID, markType) {
  if (!shouldMark(debugID)) {
    return;
  }

  var markName = debugID + '::' + markType;
  var displayName = ReactComponentTreeHook.getDisplayName(debugID) || 'Unknown';

  // Chrome has an issue of dropping markers recorded too fast:
  // https://bugs.chromium.org/p/chromium/issues/detail?id=640652
  // To work around this, we will not report very small measurements.
  // I determined the magic number by tweaking it back and forth.
  // 0.05ms was enough to prevent the issue, but I set it to 0.1ms to be safe.
  // When the bug is fixed, we can `measure()` unconditionally if we want to.
  var timeStamp = performanceNow();
  if (timeStamp - lastMarkTimeStamp > 0.1) {
    var measurementName = displayName + ' [' + markType + ']';
    performance.measure(measurementName, markName);
  }

  performance.clearMarks(markName);
  performance.clearMeasures(measurementName);
}

var ReactDebugTool = {
  addHook: function (hook) {
    hooks.push(hook);
  },
  removeHook: function (hook) {
    for (var i = 0; i < hooks.length; i++) {
      if (hooks[i] === hook) {
        hooks.splice(i, 1);
        i--;
      }
    }
  },
  isProfiling: function () {
    return isProfiling;
  },
  beginProfiling: function () {
    if (isProfiling) {
      return;
    }

    isProfiling = true;
    flushHistory.length = 0;
    resetMeasurements();
    ReactDebugTool.addHook(ReactHostOperationHistoryHook);
  },
  endProfiling: function () {
    if (!isProfiling) {
      return;
    }

    isProfiling = false;
    resetMeasurements();
    ReactDebugTool.removeHook(ReactHostOperationHistoryHook);
  },
  getFlushHistory: function () {
    return flushHistory;
  },
  onBeginFlush: function () {
    currentFlushNesting++;
    resetMeasurements();
    pauseCurrentLifeCycleTimer();
    emitEvent('onBeginFlush');
  },
  onEndFlush: function () {
    resetMeasurements();
    currentFlushNesting--;
    resumeCurrentLifeCycleTimer();
    emitEvent('onEndFlush');
  },
  onBeginLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    emitEvent('onBeginLifeCycleTimer', debugID, timerType);
    markBegin(debugID, timerType);
    beginLifeCycleTimer(debugID, timerType);
  },
  onEndLifeCycleTimer: function (debugID, timerType) {
    checkDebugID(debugID);
    endLifeCycleTimer(debugID, timerType);
    markEnd(debugID, timerType);
    emitEvent('onEndLifeCycleTimer', debugID, timerType);
  },
  onBeginProcessingChildContext: function () {
    emitEvent('onBeginProcessingChildContext');
  },
  onEndProcessingChildContext: function () {
    emitEvent('onEndProcessingChildContext');
  },
  onHostOperation: function (operation) {
    checkDebugID(operation.instanceID);
    emitEvent('onHostOperation', operation);
  },
  onSetState: function () {
    emitEvent('onSetState');
  },
  onSetChildren: function (debugID, childDebugIDs) {
    checkDebugID(debugID);
    childDebugIDs.forEach(checkDebugID);
    emitEvent('onSetChildren', debugID, childDebugIDs);
  },
  onBeforeMountComponent: function (debugID, element, parentDebugID) {
    checkDebugID(debugID);
    checkDebugID(parentDebugID, true);
    emitEvent('onBeforeMountComponent', debugID, element, parentDebugID);
    markBegin(debugID, 'mount');
  },
  onMountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'mount');
    emitEvent('onMountComponent', debugID);
  },
  onBeforeUpdateComponent: function (debugID, element) {
    checkDebugID(debugID);
    emitEvent('onBeforeUpdateComponent', debugID, element);
    markBegin(debugID, 'update');
  },
  onUpdateComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'update');
    emitEvent('onUpdateComponent', debugID);
  },
  onBeforeUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    emitEvent('onBeforeUnmountComponent', debugID);
    markBegin(debugID, 'unmount');
  },
  onUnmountComponent: function (debugID) {
    checkDebugID(debugID);
    markEnd(debugID, 'unmount');
    emitEvent('onUnmountComponent', debugID);
  },
  onTestEvent: function () {
    emitEvent('onTestEvent');
  }
};

// TODO remove these when RN/www gets updated
ReactDebugTool.addDevtool = ReactDebugTool.addHook;
ReactDebugTool.removeDevtool = ReactDebugTool.removeHook;

ReactDebugTool.addHook(ReactInvalidSetStateWarningHook);
ReactDebugTool.addHook(ReactComponentTreeHook);
var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
if (/[?&]react_perf\b/.test(url)) {
  ReactDebugTool.beginProfiling();
}

module.exports = ReactDebugTool;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactUpdates = __webpack_require__(11);
var Transaction = __webpack_require__(37);

var emptyFunction = __webpack_require__(10);

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;

/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ARIADOMPropertyConfig = __webpack_require__(163);
var BeforeInputEventPlugin = __webpack_require__(165);
var ChangeEventPlugin = __webpack_require__(167);
var DefaultEventPluginOrder = __webpack_require__(169);
var EnterLeaveEventPlugin = __webpack_require__(170);
var HTMLDOMPropertyConfig = __webpack_require__(172);
var ReactComponentBrowserEnvironment = __webpack_require__(174);
var ReactDOMComponent = __webpack_require__(177);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactDOMEmptyComponent = __webpack_require__(179);
var ReactDOMTreeTraversal = __webpack_require__(189);
var ReactDOMTextComponent = __webpack_require__(187);
var ReactDefaultBatchingStrategy = __webpack_require__(192);
var ReactEventListener = __webpack_require__(196);
var ReactInjection = __webpack_require__(198);
var ReactReconcileTransaction = __webpack_require__(204);
var SVGDOMPropertyConfig = __webpack_require__(209);
var SelectEventPlugin = __webpack_require__(210);
var SimpleEventPlugin = __webpack_require__(211);

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};

/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPluginHub = __webpack_require__(25);

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var EventListener = __webpack_require__(75);
var ExecutionEnvironment = __webpack_require__(6);
var PooledClass = __webpack_require__(17);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactUpdates = __webpack_require__(11);

var getEventTarget = __webpack_require__(58);
var getUnboundedScrollPosition = __webpack_require__(151);

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var history = [];

var ReactHostOperationHistoryHook = {
  onHostOperation: function (operation) {
    history.push(operation);
  },
  clearHistory: function () {
    if (ReactHostOperationHistoryHook._preventClearing) {
      // Should only be used for tests.
      return;
    }

    history = [];
  },
  getHistory: function () {
    return history;
  }
};

module.exports = ReactHostOperationHistoryHook;

/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var DOMProperty = __webpack_require__(15);
var EventPluginHub = __webpack_require__(25);
var EventPluginUtils = __webpack_require__(49);
var ReactComponentEnvironment = __webpack_require__(52);
var ReactEmptyComponent = __webpack_require__(88);
var ReactBrowserEventEmitter = __webpack_require__(35);
var ReactHostComponent = __webpack_require__(90);
var ReactUpdates = __webpack_require__(11);

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;

/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var warning = __webpack_require__(2);

if (process.env.NODE_ENV !== 'production') {
  var processingChildContext = false;

  var warnInvalidSetState = function () {
    process.env.NODE_ENV !== 'production' ? warning(!processingChildContext, 'setState(...): Cannot call setState() inside getChildContext()') : void 0;
  };
}

var ReactInvalidSetStateWarningHook = {
  onBeginProcessingChildContext: function () {
    processingChildContext = true;
  },
  onEndProcessingChildContext: function () {
    processingChildContext = false;
  },
  onSetState: function () {
    warnInvalidSetState();
  }
};

module.exports = ReactInvalidSetStateWarningHook;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var adler32 = __webpack_require__(222);

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactComponentEnvironment = __webpack_require__(52);
var ReactInstanceMap = __webpack_require__(27);
var ReactInstrumentation = __webpack_require__(9);

var ReactCurrentOwner = __webpack_require__(12);
var ReactReconciler = __webpack_require__(22);
var ReactChildReconciler = __webpack_require__(173);

var emptyFunction = __webpack_require__(10);
var flattenChildren = __webpack_require__(226);
var invariant = __webpack_require__(1);

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;
if (process.env.NODE_ENV !== 'production') {
  var getDebugID = function (inst) {
    if (!inst._debugID) {
      // Check for ART-like instances. TODO: This is silly/gross.
      var internal;
      if (internal = ReactInstanceMap.get(inst)) {
        inst = internal;
      }
    }
    return inst._debugID;
  };
  setChildrenForInstrumentation = function (children) {
    var debugID = getDebugID(this);
    // TODO: React Native empty components are also multichild.
    // This means they still get into this method but don't have _debugID.
    if (debugID !== 0) {
      ReactInstrumentation.debugTool.onSetChildren(debugID, children ? Object.keys(children).map(function (key) {
        return children[key]._debugID;
      }) : []);
    }
  };
}

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      if (process.env.NODE_ENV !== 'production') {
        var selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
        }
      }
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      if (process.env.NODE_ENV !== 'production') {
        selfDebugID = getDebugID(this);
        if (this._currentElement) {
          try {
            ReactCurrentOwner.current = this._currentElement._owner;
            nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
          } finally {
            ReactCurrentOwner.current = null;
          }
          ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
          return nextChildren;
        }
      }
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          if (process.env.NODE_ENV !== 'production') {
            selfDebugID = getDebugID(this);
          }
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, children);
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
           true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updateTextContent called on non-empty component.') : _prodInvariant('118') : void 0;
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;

      if (process.env.NODE_ENV !== 'production') {
        setChildrenForInstrumentation.call(this, nextChildren);
      }
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var invariant = __webpack_require__(1);

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might be adding a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might be removing a ref to a component that was not created inside a component\'s `render` method, or you have multiple copies of React loaded (details: https://fb.me/react-refs-must-have-owner).') : _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactPropTypeLocationNames = {};

if (process.env.NODE_ENV !== 'production') {
  ReactPropTypeLocationNames = {
    prop: 'prop',
    context: 'context',
    childContext: 'child context'
  };
}

module.exports = ReactPropTypeLocationNames;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var CallbackQueue = __webpack_require__(84);
var PooledClass = __webpack_require__(17);
var ReactBrowserEventEmitter = __webpack_require__(35);
var ReactInputSelection = __webpack_require__(91);
var ReactInstrumentation = __webpack_require__(9);
var Transaction = __webpack_require__(37);
var ReactUpdateQueue = __webpack_require__(54);

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var ReactOwner = __webpack_require__(202);

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var PooledClass = __webpack_require__(17);
var Transaction = __webpack_require__(37);
var ReactInstrumentation = __webpack_require__(9);
var ReactServerUpdateQueue = __webpack_require__(207);

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

if (process.env.NODE_ENV !== 'production') {
  TRANSACTION_WRAPPERS.push({
    initialize: ReactInstrumentation.debugTool.onBeginFlush,
    close: ReactInstrumentation.debugTool.onEndFlush
  });
}

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = __webpack_require__(54);

var warning = __webpack_require__(2);

function warnNoop(publicInstance, callerName) {
  if (process.env.NODE_ENV !== 'production') {
    var constructor = publicInstance.constructor;
    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounting component. ' + 'This usually means you called %s() outside componentWillMount() on the server. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, constructor && (constructor.displayName || constructor.name) || 'ReactClass') : void 0;
  }
}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.4.2';

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var EventPropagators = __webpack_require__(26);
var ExecutionEnvironment = __webpack_require__(6);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInputSelection = __webpack_require__(91);
var SyntheticEvent = __webpack_require__(13);

var getActiveElement = __webpack_require__(77);
var isTextInputElement = __webpack_require__(101);
var shallowEqual = __webpack_require__(45);

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(3);

var EventListener = __webpack_require__(75);
var EventPropagators = __webpack_require__(26);
var ReactDOMComponentTree = __webpack_require__(5);
var SyntheticAnimationEvent = __webpack_require__(212);
var SyntheticClipboardEvent = __webpack_require__(213);
var SyntheticEvent = __webpack_require__(13);
var SyntheticFocusEvent = __webpack_require__(216);
var SyntheticKeyboardEvent = __webpack_require__(218);
var SyntheticMouseEvent = __webpack_require__(36);
var SyntheticDragEvent = __webpack_require__(215);
var SyntheticTouchEvent = __webpack_require__(219);
var SyntheticTransitionEvent = __webpack_require__(220);
var SyntheticUIEvent = __webpack_require__(28);
var SyntheticWheelEvent = __webpack_require__(221);

var emptyFunction = __webpack_require__(10);
var getEventCharCode = __webpack_require__(56);
var invariant = __webpack_require__(1);

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

module.exports = SimpleEventPlugin;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(36);

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(28);

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(28);

var getEventCharCode = __webpack_require__(56);
var getEventKey = __webpack_require__(227);
var getEventModifierState = __webpack_require__(57);

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticUIEvent = __webpack_require__(28);

var getEventModifierState = __webpack_require__(57);

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticEvent = __webpack_require__(13);

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var SyntheticMouseEvent = __webpack_require__(36);

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactPropTypeLocationNames = __webpack_require__(203);
var ReactPropTypesSecret = __webpack_require__(94);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(8);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(8);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var CSSProperty = __webpack_require__(83);
var warning = __webpack_require__(2);

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    if (process.env.NODE_ENV !== 'production') {
      // Allow '0' to pass through without warning. 0 is already special and
      // doesn't require units, so we don't need to warn about it.
      if (component && value !== '0') {
        var owner = component._currentElement._owner;
        var ownerName = owner ? owner.getName() : null;
        if (ownerName && !styleWarnings[ownerName]) {
          styleWarnings[ownerName] = {};
        }
        var warned = false;
        if (ownerName) {
          var warnings = styleWarnings[ownerName];
          warned = warnings[name];
          if (!warned) {
            warnings[name] = true;
          }
        }
        if (!warned) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'a `%s` tag (owner: `%s`) was passed a numeric string value ' + 'for CSS property `%s` (value: `%s`) which will be treated ' + 'as a unitless number in a future version of React.', component._currentElement.type, ownerName || 'unknown', name, value) : void 0;
        }
      }
    }
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(3);

var ReactCurrentOwner = __webpack_require__(12);
var ReactDOMComponentTree = __webpack_require__(5);
var ReactInstanceMap = __webpack_require__(27);

var getHostComponentFromComposite = __webpack_require__(98);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (process.env.NODE_ENV !== 'production') {
    var owner = ReactCurrentOwner.current;
    if (owner !== null) {
      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : void 0;
      owner._warnedAboutRefsInRender = true;
    }
  }
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : _prodInvariant('44') : void 0;
  } else {
     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : _prodInvariant('45', Object.keys(componentOrElement)) : void 0;
  }
}

module.exports = findDOMNode;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var KeyEscapeUtils = __webpack_require__(50);
var traverseAllChildren = __webpack_require__(103);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(8);
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (process.env.NODE_ENV !== 'production') {
      if (!ReactComponentTreeHook) {
        ReactComponentTreeHook = __webpack_require__(8);
      }
      if (!keyUnique) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.%s', KeyEscapeUtils.unescape(name), ReactComponentTreeHook.getStackAddendumByID(selfDebugID)) : void 0;
      }
    }
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  if (process.env.NODE_ENV !== 'production') {
    traverseAllChildren(children, function (traverseContext, child, name) {
      return flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID);
    }, result);
  } else {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var getEventCharCode = __webpack_require__(56);

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;

/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ExecutionEnvironment = __webpack_require__(6);

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;

/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var escapeTextContentForBrowser = __webpack_require__(38);

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;

/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactMount = __webpack_require__(92);

module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */



var _prodInvariant = __webpack_require__(19);

var invariant = __webpack_require__(1);

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler
};

module.exports = PooledClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var PooledClass = __webpack_require__(235);
var ReactElement = __webpack_require__(18);

var emptyFunction = __webpack_require__(10);
var traverseAllChildren = __webpack_require__(244);

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(19),
    _assign = __webpack_require__(4);

var ReactComponent = __webpack_require__(62);
var ReactElement = __webpack_require__(18);
var ReactPropTypeLocationNames = __webpack_require__(64);
var ReactNoopUpdateQueue = __webpack_require__(63);

var emptyObject = __webpack_require__(24);
var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, childContextTypes, 'childContext');
    }
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, contextTypes, 'context');
    }
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    if (process.env.NODE_ENV !== 'production') {
      validateTypeDef(Constructor, propTypes, 'prop');
    }
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.', name) : _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    if (process.env.NODE_ENV !== 'production') {
      var typeofSpec = typeof spec;
      var isMixinValid = typeofSpec === 'object' && spec !== null;

      process.env.NODE_ENV !== 'production' ? warning(isMixinValid, '%s: You\'re attempting to include a mixin that is either null ' + 'or not an object. Check the mixins included by the component, ' + 'as well as any mixins they include themselves. ' + 'Expected object but got %s.', Constructor.displayName || 'ReactClass', spec === null ? null : typeofSpec) : void 0;
    }

    return;
  }

  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component class or function as a mixin. Instead, just use a regular object.') : _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to use a component as a mixin. Instead, just use a regular object.') : _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.', specPolicy, name) : _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
          if (process.env.NODE_ENV !== 'production') {
            // Add verbose displayName to the function, which helps when looking
            // at profiling tools.
            if (typeof property === 'function' && spec.displayName) {
              proto[name].displayName = spec.displayName + '_' + name;
            }
          }
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.', name) : _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.', name) : _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.', key) : _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  if (process.env.NODE_ENV !== 'production') {
    boundMethod.__reactBoundContext = component;
    boundMethod.__reactBoundMethod = method;
    boundMethod.__reactBoundArguments = null;
    var componentName = component.constructor.displayName;
    var _bind = boundMethod.bind;
    boundMethod.bind = function (newThis) {
      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      // User is trying to bind() an autobound method; we effectively will
      // ignore the value of "this" that the user is trying to use, so
      // let's warn.
      if (newThis !== component && newThis !== null) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : void 0;
      } else if (!args.length) {
        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : void 0;
        return boundMethod;
      }
      var reboundMethod = _bind.apply(boundMethod, arguments);
      reboundMethod.__reactBoundContext = component;
      reboundMethod.__reactBoundMethod = method;
      reboundMethod.__reactBoundArguments = args;
      return reboundMethod;
    };
  }
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // This constructor gets overridden by mocks. The argument is used
      // by mocks to assert on what gets mounted.

      if (process.env.NODE_ENV !== 'production') {
        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : void 0;
      }

      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      if (process.env.NODE_ENV !== 'production') {
        // We allow auto-mocks to proceed as if they're returning null.
        if (initialState === undefined && this.getInitialState._isMockFunction) {
          // This is probably bad practice. Consider warning here and
          // deprecating this convenience.
          initialState = null;
        }
      }
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    if (process.env.NODE_ENV !== 'production') {
      // This is a tag to indicate that the use of these method names is ok,
      // since it's used with createClass. If it's not, then it's likely a
      // mistake so we'll warn you to use the static property, property
      // initializer or constructor respectively.
      if (Constructor.getDefaultProps) {
        Constructor.getDefaultProps.isReactClassApproved = {};
      }
      if (Constructor.prototype.getInitialState) {
        Constructor.prototype.getInitialState.isReactClassApproved = {};
      }
    }

    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : _prodInvariant('83') : void 0;

    if (process.env.NODE_ENV !== 'production') {
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : void 0;
      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : void 0;
    }

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(18);

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;
if (process.env.NODE_ENV !== 'production') {
  var ReactElementValidator = __webpack_require__(105);
  createDOMFactory = ReactElementValidator.createFactory;
}

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var ReactElement = __webpack_require__(18);
var ReactPropTypeLocationNames = __webpack_require__(64);
var ReactPropTypesSecret = __webpack_require__(106);

var emptyFunction = __webpack_require__(10);
var getIteratorFn = __webpack_require__(66);
var warning = __webpack_require__(2);

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  if (process.env.NODE_ENV !== 'production') {
    var manualPropTypeCallCache = {};
  }
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (process.env.NODE_ENV !== 'production') {
      if (secret !== ReactPropTypesSecret && typeof console !== 'undefined') {
        var cacheKey = componentName + ':' + propName;
        if (!manualPropTypeCallCache[cacheKey]) {
          process.env.NODE_ENV !== 'production' ? warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will not work in production with the next major version. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName) : void 0;
          manualPropTypeCallCache[cacheKey] = true;
        }
      }
    }
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _assign = __webpack_require__(4);

var ReactComponent = __webpack_require__(62);
var ReactNoopUpdateQueue = __webpack_require__(63);

var emptyObject = __webpack_require__(24);

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



module.exports = '15.4.2';

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(19);

var ReactPropTypeLocationNames = __webpack_require__(64);
var ReactPropTypesSecret = __webpack_require__(106);

var invariant = __webpack_require__(1);
var warning = __webpack_require__(2);

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = __webpack_require__(8);
}

var loggedTypeFailures = {};

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?object} element The React element that is being type-checked
 * @param {?number} debugID The React component instance that is being type-checked
 * @private
 */
function checkReactTypeSpec(typeSpecs, values, location, componentName, element, debugID) {
  for (var typeSpecName in typeSpecs) {
    if (typeSpecs.hasOwnProperty(typeSpecName)) {
      var error;
      // Prop type validation may throw. In case they do, we don't want to
      // fail the render phase where it didn't fail before. So we log it.
      // After these have been cleaned up, we'll let them throw.
      try {
        // This is intentionally an invariant that gets caught. It's the same
        // behavior as without this statement except with a better message.
        !(typeof typeSpecs[typeSpecName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : _prodInvariant('84', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName) : void 0;
        error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
      } catch (ex) {
        error = ex;
      }
      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], typeSpecName, typeof error) : void 0;
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var componentStackInfo = '';

        if (process.env.NODE_ENV !== 'production') {
          if (!ReactComponentTreeHook) {
            ReactComponentTreeHook = __webpack_require__(8);
          }
          if (debugID !== null) {
            componentStackInfo = ReactComponentTreeHook.getStackAddendumByID(debugID);
          } else if (element !== null) {
            componentStackInfo = ReactComponentTreeHook.getCurrentStackAddendum(element);
          }
        }

        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed %s type: %s%s', location, error.message, componentStackInfo) : void 0;
      }
    }
  }
}

module.exports = checkReactTypeSpec;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */


var _prodInvariant = __webpack_require__(19);

var ReactElement = __webpack_require__(18);

var invariant = __webpack_require__(1);

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'React.Children.only expected to receive a single React element child.') : _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */



var _prodInvariant = __webpack_require__(19);

var ReactCurrentOwner = __webpack_require__(12);
var REACT_ELEMENT_TYPE = __webpack_require__(104);

var getIteratorFn = __webpack_require__(66);
var invariant = __webpack_require__(1);
var KeyEscapeUtils = __webpack_require__(234);
var warning = __webpack_require__(2);

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        if (process.env.NODE_ENV !== 'production') {
          var mapsAsChildrenAddendum = '';
          if (ReactCurrentOwner.current) {
            var mapsAsChildrenOwnerName = ReactCurrentOwner.current.getName();
            if (mapsAsChildrenOwnerName) {
              mapsAsChildrenAddendum = ' Check the render method of `' + mapsAsChildrenOwnerName + '`.';
            }
          }
          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.%s', mapsAsChildrenAddendum) : void 0;
          didWarnAboutMaps = true;
        }
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      if (process.env.NODE_ENV !== 'production') {
        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
        if (children._isReactElement) {
          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
        }
        if (ReactCurrentOwner.current) {
          var name = ReactCurrentOwner.current.getName();
          if (name) {
            addendum += ' Check the render method of `' + name + '`.';
          }
        }
      }
      var childrenString = String(children);
       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : void 0;
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Module dependencies.
 */

var url = __webpack_require__(246);
var parser = __webpack_require__(67);
var Manager = __webpack_require__(107);
var debug = __webpack_require__(40)('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup (uri, opts) {
  if (typeof uri === 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var path = parsed.path;
  var sameNamespace = cache[id] && path in cache[id].nsps;
  var newConnection = opts.forceNew || opts['force new connection'] ||
                      false === opts.multiplex || sameNamespace;

  var io;

  if (newConnection) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.query;
  } else if (opts && 'object' === typeof opts.query) {
    opts.query = encodeQueryString(opts.query);
  }
  return io.socket(parsed.path, opts);
}
/**
 *  Helper method to parse query objects to string.
 * @param {object} query
 * @returns {string}
 */
function encodeQueryString (obj) {
  var str = [];
  for (var p in obj) {
    if (obj.hasOwnProperty(p)) {
      str.push(encodeURIComponent(p) + '=' + encodeURIComponent(obj[p]));
    }
  }
  return str.join('&');
}
/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = __webpack_require__(107);
exports.Socket = __webpack_require__(109);


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module dependencies.
 */

var parseuri = __webpack_require__(81);
var debug = __webpack_require__(40)('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url (uri, loc) {
  var obj = uri;

  // default to window.location
  loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.host;

  // relative path support
  if ('string' === typeof uri) {
    if ('/' === uri.charAt(0)) {
      if ('/' === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' !== typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  var ipv6 = obj.host.indexOf(':') !== -1;
  var host = ipv6 ? '[' + obj.host + ']' : obj.host;

  // define unique id
  obj.id = obj.protocol + '://' + host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + host + (loc && loc.port === obj.port ? '' : (':' + obj.port));

  return obj;
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug.debug = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(80);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    // apply env-specific formatting
    args = exports.formatArgs.apply(self, args);

    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/*global Blob,File*/

/**
 * Module requirements
 */

var isArray = __webpack_require__(251);
var isBuf = __webpack_require__(111);

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet){
  var buffers = [];
  var packetData = packet.data;

  function _deconstructPacket(data) {
    if (!data) return data;

    if (isBuf(data)) {
      var placeholder = { _placeholder: true, num: buffers.length };
      buffers.push(data);
      return placeholder;
    } else if (isArray(data)) {
      var newData = new Array(data.length);
      for (var i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i]);
      }
      return newData;
    } else if ('object' == typeof data && !(data instanceof Date)) {
      var newData = {};
      for (var key in data) {
        newData[key] = _deconstructPacket(data[key]);
      }
      return newData;
    }
    return data;
  }

  var pack = packet;
  pack.data = _deconstructPacket(packetData);
  pack.attachments = buffers.length; // number of binary 'attachments'
  return {packet: pack, buffers: buffers};
};

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

exports.reconstructPacket = function(packet, buffers) {
  var curPlaceHolder = 0;

  function _reconstructPacket(data) {
    if (data && data._placeholder) {
      var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
      return buf;
    } else if (isArray(data)) {
      for (var i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i]);
      }
      return data;
    } else if (data && 'object' == typeof data) {
      for (var key in data) {
        data[key] = _reconstructPacket(data[key]);
      }
      return data;
    }
    return data;
  }

  packet.data = _reconstructPacket(packet.data);
  packet.attachments = undefined; // no longer useful
  return packet;
};

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {
  function _removeBlobs(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    } else if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        _removeBlobs(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        _removeBlobs(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  _removeBlobs(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = __webpack_require__(250);
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = __webpack_require__(252);

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}


/***/ }),
/* 251 */
/***/ (function(module, exports) {

module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};


/***/ }),
/* 252 */
/***/ (function(module, exports) {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}


/***/ }),
/* 253 */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
var stylesInDom = {},
	memoize = function(fn) {
		var memo;
		return function () {
			if (typeof memo === "undefined") memo = fn.apply(this, arguments);
			return memo;
		};
	},
	isOldIE = memoize(function() {
		return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
	}),
	getHeadElement = memoize(function () {
		return document.head || document.getElementsByTagName("head")[0];
	}),
	singletonElement = null,
	singletonCounter = 0,
	styleElementsInsertedAtTop = [];

module.exports = function(list, options) {
	if(typeof DEBUG !== "undefined" && DEBUG) {
		if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};
	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (typeof options.singleton === "undefined") options.singleton = isOldIE();

	// By default, add <style> tags to the bottom of <head>.
	if (typeof options.insertAt === "undefined") options.insertAt = "bottom";

	var styles = listToStyles(list);
	addStylesToDom(styles, options);

	return function update(newList) {
		var mayRemove = [];
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			domStyle.refs--;
			mayRemove.push(domStyle);
		}
		if(newList) {
			var newStyles = listToStyles(newList);
			addStylesToDom(newStyles, options);
		}
		for(var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];
			if(domStyle.refs === 0) {
				for(var j = 0; j < domStyle.parts.length; j++)
					domStyle.parts[j]();
				delete stylesInDom[domStyle.id];
			}
		}
	};
}

function addStylesToDom(styles, options) {
	for(var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];
		if(domStyle) {
			domStyle.refs++;
			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}
			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];
			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}
			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles(list) {
	var styles = [];
	var newStyles = {};
	for(var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};
		if(!newStyles[id])
			styles.push(newStyles[id] = {id: id, parts: [part]});
		else
			newStyles[id].parts.push(part);
	}
	return styles;
}

function insertStyleElement(options, styleElement) {
	var head = getHeadElement();
	var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
	if (options.insertAt === "top") {
		if(!lastStyleElementInsertedAtTop) {
			head.insertBefore(styleElement, head.firstChild);
		} else if(lastStyleElementInsertedAtTop.nextSibling) {
			head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			head.appendChild(styleElement);
		}
		styleElementsInsertedAtTop.push(styleElement);
	} else if (options.insertAt === "bottom") {
		head.appendChild(styleElement);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement(styleElement) {
	styleElement.parentNode.removeChild(styleElement);
	var idx = styleElementsInsertedAtTop.indexOf(styleElement);
	if(idx >= 0) {
		styleElementsInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement(options) {
	var styleElement = document.createElement("style");
	styleElement.type = "text/css";
	insertStyleElement(options, styleElement);
	return styleElement;
}

function createLinkElement(options) {
	var linkElement = document.createElement("link");
	linkElement.rel = "stylesheet";
	insertStyleElement(options, linkElement);
	return linkElement;
}

function addStyle(obj, options) {
	var styleElement, update, remove;

	if (options.singleton) {
		var styleIndex = singletonCounter++;
		styleElement = singletonElement || (singletonElement = createStyleElement(options));
		update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
		remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
	} else if(obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function") {
		styleElement = createLinkElement(options);
		update = updateLink.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
			if(styleElement.href)
				URL.revokeObjectURL(styleElement.href);
		};
	} else {
		styleElement = createStyleElement(options);
		update = applyToTag.bind(null, styleElement);
		remove = function() {
			removeStyleElement(styleElement);
		};
	}

	update(obj);

	return function updateStyle(newObj) {
		if(newObj) {
			if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
				return;
			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;
		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag(styleElement, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (styleElement.styleSheet) {
		styleElement.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = styleElement.childNodes;
		if (childNodes[index]) styleElement.removeChild(childNodes[index]);
		if (childNodes.length) {
			styleElement.insertBefore(cssNode, childNodes[index]);
		} else {
			styleElement.appendChild(cssNode);
		}
	}
}

function applyToTag(styleElement, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		styleElement.setAttribute("media", media)
	}

	if(styleElement.styleSheet) {
		styleElement.styleSheet.cssText = css;
	} else {
		while(styleElement.firstChild) {
			styleElement.removeChild(styleElement.firstChild);
		}
		styleElement.appendChild(document.createTextNode(css));
	}
}

function updateLink(linkElement, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	if(sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = linkElement.href;

	linkElement.href = URL.createObjectURL(blob);

	if(oldSrc)
		URL.revokeObjectURL(oldSrc);
}


/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(135);
if(typeof content === 'string') content = [[module.i, content, '']];
// add the styles to the DOM
var update = __webpack_require__(253)(content, {});
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/lib/loader.js!./app.scss", function() {
			var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/lib/loader.js!./app.scss");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),
/* 255 */
/***/ (function(module, exports) {

module.exports = function( THREE ) {
	/**
	 * @author qiao / https://github.com/qiao
	 * @author mrdoob / http://mrdoob.com
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author erich666 / http://erichaines.com
	 */

// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe

	function OrbitControls( object, domElement ) {

		this.object = object;

		this.domElement = ( domElement !== undefined ) ? domElement : document;

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new THREE.Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0; // radians
		this.maxPolarAngle = Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = false;
		this.dampingFactor = 0.25;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 1.0;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.keyPanSpeed = 7.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

		// The four arrow keys
		this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 };

		// Mouse buttons
		this.mouseButtons = { ORBIT: THREE.MOUSE.LEFT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.RIGHT };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function() {

			var offset = new THREE.Vector3();

			// so camera.up is the orbit axis
			var quat = new THREE.Quaternion().setFromUnitVectors( object.up, new THREE.Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().inverse();

			var lastPosition = new THREE.Vector3();
			var lastQuaternion = new THREE.Quaternion();

			return function update () {

				var position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

				spherical.theta += sphericalDelta.theta;
				spherical.phi += sphericalDelta.phi;

				// restrict theta to be between desired limits
				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

				// restrict phi to be between desired limits
				spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );

				spherical.makeSafe();


				spherical.radius *= scale;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location
				scope.target.add( panOffset );

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

				}

				scale = 1;
				panOffset.set( 0, 0, 0 );

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( changeEvent );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function() {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
			scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel, false );

			scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			window.removeEventListener( 'keydown', onKeyDown, false );

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		var scope = this;

		var changeEvent = { type: 'change' };
		var startEvent = { type: 'start' };
		var endEvent = { type: 'end' };

		var STATE = { NONE : - 1, ROTATE : 0, DOLLY : 1, PAN : 2, TOUCH_ROTATE : 3, TOUCH_DOLLY : 4, TOUCH_PAN : 5 };

		var state = STATE.NONE;

		var EPS = 0.000001;

		// current position in spherical coordinates
		var spherical = new THREE.Spherical();
		var sphericalDelta = new THREE.Spherical();

		var scale = 1;
		var panOffset = new THREE.Vector3();
		var zoomChanged = false;

		var rotateStart = new THREE.Vector2();
		var rotateEnd = new THREE.Vector2();
		var rotateDelta = new THREE.Vector2();

		var panStart = new THREE.Vector2();
		var panEnd = new THREE.Vector2();
		var panDelta = new THREE.Vector2();

		var dollyStart = new THREE.Vector2();
		var dollyEnd = new THREE.Vector2();
		var dollyDelta = new THREE.Vector2();

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale() {

			return Math.pow( 0.95, scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		var panLeft = function() {

			var v = new THREE.Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		var panUp = function() {

			var v = new THREE.Vector3();

			return function panUp( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 1 ); // get Y column of objectMatrix
				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		var pan = function() {

			var offset = new THREE.Vector3();

			return function pan ( deltaX, deltaY ) {

				var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

				if ( scope.object instanceof THREE.PerspectiveCamera ) {

					// perspective
					var position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					var targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we actually don't use screenWidth, since perspective camera is fixed to screen height
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object instanceof THREE.OrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyIn( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyOut( dollyScale ) {

			if ( scope.object instanceof THREE.PerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object instanceof THREE.OrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			//console.log( 'handleMouseDownRotate' );

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			//console.log( 'handleMouseDownDolly' );

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			//console.log( 'handleMouseDownPan' );

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			//console.log( 'handleMouseMoveRotate' );

			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			//console.log( 'handleMouseMoveDolly' );

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyIn( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyOut( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			//console.log( 'handleMouseMovePan' );

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleMouseUp( event ) {

			//console.log( 'handleMouseUp' );

		}

		function handleMouseWheel( event ) {

			//console.log( 'handleMouseWheel' );

			if ( event.deltaY < 0 ) {

				dollyOut( getZoomScale() );

			} else if ( event.deltaY > 0 ) {

				dollyIn( getZoomScale() );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			//console.log( 'handleKeyDown' );

			switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					scope.update();
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					scope.update();
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					scope.update();
					break;

			}

		}

		function handleTouchStartRotate( event ) {

			//console.log( 'handleTouchStartRotate' );

			rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchStartDolly( event ) {

			//console.log( 'handleTouchStartDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartPan( event ) {

			//console.log( 'handleTouchStartPan' );

			panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

		}

		function handleTouchMoveRotate( event ) {

			//console.log( 'handleTouchMoveRotate' );

			rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

			// rotating across whole screen goes 360 degrees around
			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed );

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleTouchMoveDolly( event ) {

			//console.log( 'handleTouchMoveDolly' );

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleTouchMovePan( event ) {

			//console.log( 'handleTouchMovePan' );

			panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			panDelta.subVectors( panEnd, panStart );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

		function handleTouchEnd( event ) {

			//console.log( 'handleTouchEnd' );

		}

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( event.button === scope.mouseButtons.ORBIT ) {

				if ( scope.enableRotate === false ) return;

				handleMouseDownRotate( event );

				state = STATE.ROTATE;

			} else if ( event.button === scope.mouseButtons.ZOOM ) {

				if ( scope.enableZoom === false ) return;

				handleMouseDownDolly( event );

				state = STATE.DOLLY;

			} else if ( event.button === scope.mouseButtons.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseDownPan( event );

				state = STATE.PAN;

			}

			if ( state !== STATE.NONE ) {

				document.addEventListener( 'mousemove', onMouseMove, false );
				document.addEventListener( 'mouseup', onMouseUp, false );

				scope.dispatchEvent( startEvent );

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			if ( state === STATE.ROTATE ) {

				if ( scope.enableRotate === false ) return;

				handleMouseMoveRotate( event );

			} else if ( state === STATE.DOLLY ) {

				if ( scope.enableZoom === false ) return;

				handleMouseMoveDolly( event );

			} else if ( state === STATE.PAN ) {

				if ( scope.enablePan === false ) return;

				handleMouseMovePan( event );

			}

		}

		function onMouseUp( event ) {

			if ( scope.enabled === false ) return;

			handleMouseUp( event );

			document.removeEventListener( 'mousemove', onMouseMove, false );
			document.removeEventListener( 'mouseup', onMouseUp, false );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();
			event.stopPropagation();

			handleMouseWheel( event );

			scope.dispatchEvent( startEvent ); // not sure why these are here...
			scope.dispatchEvent( endEvent );

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			if ( scope.enabled === false ) return;

			switch ( event.touches.length ) {

				case 1:	// one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;

					handleTouchStartRotate( event );

					state = STATE.TOUCH_ROTATE;

					break;

				case 2:	// two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;

					handleTouchStartDolly( event );

					state = STATE.TOUCH_DOLLY;

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;

					handleTouchStartPan( event );

					state = STATE.TOUCH_PAN;

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.dispatchEvent( startEvent );

			}

		}

		function onTouchMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();
			event.stopPropagation();

			switch ( event.touches.length ) {

				case 1: // one-fingered touch: rotate

					if ( scope.enableRotate === false ) return;
					if ( state !== STATE.TOUCH_ROTATE ) return; // is this needed?...

					handleTouchMoveRotate( event );

					break;

				case 2: // two-fingered touch: dolly

					if ( scope.enableZoom === false ) return;
					if ( state !== STATE.TOUCH_DOLLY ) return; // is this needed?...

					handleTouchMoveDolly( event );

					break;

				case 3: // three-fingered touch: pan

					if ( scope.enablePan === false ) return;
					if ( state !== STATE.TOUCH_PAN ) return; // is this needed?...

					handleTouchMovePan( event );

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchEnd( event ) {

			if ( scope.enabled === false ) return;

			handleTouchEnd( event );

			scope.dispatchEvent( endEvent );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			event.preventDefault();

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

		window.addEventListener( 'keydown', onKeyDown, false );

		// force an update at start

		this.update();

	};

	OrbitControls.prototype = Object.create( THREE.EventDispatcher.prototype );
	OrbitControls.prototype.constructor = OrbitControls;

	Object.defineProperties( OrbitControls.prototype, {

		center: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .center has been renamed to .target' );
				return this.target;

			}

		},

		// backward compatibility

		noZoom: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				return ! this.enableZoom;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.' );
				this.enableZoom = ! value;

			}

		},

		noRotate: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				return ! this.enableRotate;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.' );
				this.enableRotate = ! value;

			}

		},

		noPan: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				return ! this.enablePan;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead.' );
				this.enablePan = ! value;

			}

		},

		noKeys: {

			get: function () {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				return ! this.enableKeys;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.' );
				this.enableKeys = ! value;

			}

		},

		staticMoving : {

			get: function () {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				return ! this.enableDamping;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.' );
				this.enableDamping = ! value;

			}

		},

		dynamicDampingFactor : {

			get: function () {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				return this.dampingFactor;

			},

			set: function ( value ) {

				console.warn( 'THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.' );
				this.dampingFactor = value;

			}

		}

	} );

	return OrbitControls;
};


/***/ }),
/* 256 */
/***/ (function(module, exports) {

module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}


/***/ }),
/* 257 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_bbox__ = __webpack_require__(112);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "bbox", function() { return __WEBPACK_IMPORTED_MODULE_0__src_bbox__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_feature__ = __webpack_require__(68);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "feature", function() { return __WEBPACK_IMPORTED_MODULE_1__src_feature__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_mesh__ = __webpack_require__(260);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mesh", function() { return __WEBPACK_IMPORTED_MODULE_2__src_mesh__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "meshArcs", function() { return __WEBPACK_IMPORTED_MODULE_2__src_mesh__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_merge__ = __webpack_require__(259);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "merge", function() { return __WEBPACK_IMPORTED_MODULE_3__src_merge__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "mergeArcs", function() { return __WEBPACK_IMPORTED_MODULE_3__src_merge__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_neighbors__ = __webpack_require__(261);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "neighbors", function() { return __WEBPACK_IMPORTED_MODULE_4__src_neighbors__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_quantize__ = __webpack_require__(262);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "quantize", function() { return __WEBPACK_IMPORTED_MODULE_5__src_quantize__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_transform__ = __webpack_require__(69);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "transform", function() { return __WEBPACK_IMPORTED_MODULE_6__src_transform__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_untransform__ = __webpack_require__(264);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "untransform", function() { return __WEBPACK_IMPORTED_MODULE_7__src_untransform__["a"]; });










/***/ }),
/* 258 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
};


/***/ }),
/* 259 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__feature__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stitch__ = __webpack_require__(114);
/* harmony export (immutable) */ __webpack_exports__["b"] = mergeArcs;



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ __webpack_exports__["a"] = function(topology) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__feature__["b" /* object */])(topology, mergeArcs.apply(this, arguments));
};

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__feature__["b" /* object */])(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__stitch__["a" /* default */])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    })
  };
}


/***/ }),
/* 260 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__feature__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__stitch__ = __webpack_require__(114);
/* harmony export (immutable) */ __webpack_exports__["b"] = meshArcs;



/* harmony default export */ __webpack_exports__["a"] = function(topology) {
  return __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__feature__["b" /* object */])(topology, meshArcs.apply(this, arguments));
};

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__stitch__["a" /* default */])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),
/* 261 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bisect__ = __webpack_require__(258);


/* harmony default export */ __webpack_exports__["a"] = function(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__bisect__["a" /* default */])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__bisect__["a" /* default */])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
};


/***/ }),
/* 262 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__bbox__ = __webpack_require__(112);


/* harmony default export */ __webpack_exports__["a"] = function(topology, n) {
  if (!((n = Math.floor(n)) >= 2)) throw new Error("n must be ≥2");
  if (topology.transform) throw new Error("already quantized");
  var bb = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__bbox__["a" /* default */])(topology), name,
      dx = bb[0], kx = (bb[2] - dx) / (n - 1) || 1,
      dy = bb[1], ky = (bb[3] - dy) / (n - 1) || 1;

  function quantizePoint(p) {
    p[0] = Math.round((p[0] - dx) / kx);
    p[1] = Math.round((p[1] - dy) / ky);
  }

  function quantizeGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(quantizeGeometry); break;
      case "Point": quantizePoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(quantizePoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = 1,
        j = 1,
        n = arc.length,
        pi = arc[0],
        x0 = pi[0] = Math.round((pi[0] - dx) / kx),
        y0 = pi[1] = Math.round((pi[1] - dy) / ky),
        pj,
        x1,
        y1;

    for (; i < n; ++i) {
      pi = arc[i];
      x1 = Math.round((pi[0] - dx) / kx);
      y1 = Math.round((pi[1] - dy) / ky);
      if (x1 !== x0 || y1 !== y0) {
        pj = arc[j++];
        pj[0] = x1 - x0, x0 = x1;
        pj[1] = y1 - y0, y0 = y1;
      }
    }

    if (j < 2) {
      pj = arc[j++];
      pj[0] = 0;
      pj[1] = 0;
    }

    arc.length = j;
  });

  for (name in topology.objects) {
    quantizeGeometry(topology.objects[name]);
  }

  topology.transform = {
    scale: [kx, ky],
    translate: [dx, dy]
  };

  return topology;
};


/***/ }),
/* 263 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = function(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
};


/***/ }),
/* 264 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__identity__ = __webpack_require__(113);


/* harmony default export */ __webpack_exports__["a"] = function(topology) {
  if ((transform = topology.transform) == null) return __WEBPACK_IMPORTED_MODULE_0__identity__["a" /* default */];
  var transform,
      x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(point, i) {
    if (!i) x0 = y0 = 0;
    var x1 = Math.round((point[0] - dx) / kx),
        y1 = Math.round((point[1] - dy) / ky);
    point[0] = x1 - x0, x0 = x1;
    point[1] = y1 - y0, y0 = y1;
    return point;
  };
};


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */

var TWEEN = TWEEN || (function () {

	var _tweens = [];

	return {

		getAll: function () {

			return _tweens;

		},

		removeAll: function () {

			_tweens = [];

		},

		add: function (tween) {

			_tweens.push(tween);

		},

		remove: function (tween) {

			var i = _tweens.indexOf(tween);

			if (i !== -1) {
				_tweens.splice(i, 1);
			}

		},

		update: function (time, preserve) {

			if (_tweens.length === 0) {
				return false;
			}

			var i = 0;

			time = time !== undefined ? time : TWEEN.now();

			while (i < _tweens.length) {

				if (_tweens[i].update(time) || preserve) {
					i++;
				} else {
					_tweens.splice(i, 1);
				}

			}

			return true;

		}
	};

})();


// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (window) === 'undefined' && typeof (process) !== 'undefined') {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use window.performance.now if it is available.
else if (typeof (window) !== 'undefined' &&
         window.performance !== undefined &&
		 window.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	TWEEN.now = window.performance.now.bind(window.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	TWEEN.now = function () {
		return new Date().getTime();
	};
}


TWEEN.Tween = function (object) {

	var _object = object;
	var _valuesStart = {};
	var _valuesEnd = {};
	var _valuesStartRepeat = {};
	var _duration = 1000;
	var _repeat = 0;
	var _repeatDelayTime;
	var _yoyo = false;
	var _isPlaying = false;
	var _reversed = false;
	var _delayTime = 0;
	var _startTime = null;
	var _easingFunction = TWEEN.Easing.Linear.None;
	var _interpolationFunction = TWEEN.Interpolation.Linear;
	var _chainedTweens = [];
	var _onStartCallback = null;
	var _onStartCallbackFired = false;
	var _onUpdateCallback = null;
	var _onCompleteCallback = null;
	var _onStopCallback = null;

	this.to = function (properties, duration) {

		_valuesEnd = properties;

		if (duration !== undefined) {
			_duration = duration;
		}

		return this;

	};

	this.start = function (time) {

		TWEEN.add(this);

		_isPlaying = true;

		_onStartCallbackFired = false;

		_startTime = time !== undefined ? time : TWEEN.now();
		_startTime += _delayTime;

		for (var property in _valuesEnd) {

			// Check if an Array was provided as property value
			if (_valuesEnd[property] instanceof Array) {

				if (_valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				_valuesEnd[property] = [_object[property]].concat(_valuesEnd[property]);

			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (_object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			_valuesStart[property] = _object[property];

			if ((_valuesStart[property] instanceof Array) === false) {
				_valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			_valuesStartRepeat[property] = _valuesStart[property] || 0;

		}

		return this;

	};

	this.stop = function () {

		if (!_isPlaying) {
			return this;
		}

		TWEEN.remove(this);
		_isPlaying = false;

		if (_onStopCallback !== null) {
			_onStopCallback.call(_object, _object);
		}

		this.stopChainedTweens();
		return this;

	};

	this.end = function () {

		this.update(_startTime + _duration);
		return this;

	};

	this.stopChainedTweens = function () {

		for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
			_chainedTweens[i].stop();
		}

	};

	this.delay = function (amount) {

		_delayTime = amount;
		return this;

	};

	this.repeat = function (times) {

		_repeat = times;
		return this;

	};

	this.repeatDelay = function (amount) {

		_repeatDelayTime = amount;
		return this;

	};

	this.yoyo = function (yoyo) {

		_yoyo = yoyo;
		return this;

	};


	this.easing = function (easing) {

		_easingFunction = easing;
		return this;

	};

	this.interpolation = function (interpolation) {

		_interpolationFunction = interpolation;
		return this;

	};

	this.chain = function () {

		_chainedTweens = arguments;
		return this;

	};

	this.onStart = function (callback) {

		_onStartCallback = callback;
		return this;

	};

	this.onUpdate = function (callback) {

		_onUpdateCallback = callback;
		return this;

	};

	this.onComplete = function (callback) {

		_onCompleteCallback = callback;
		return this;

	};

	this.onStop = function (callback) {

		_onStopCallback = callback;
		return this;

	};

	this.update = function (time) {

		var property;
		var elapsed;
		var value;

		if (time < _startTime) {
			return true;
		}

		if (_onStartCallbackFired === false) {

			if (_onStartCallback !== null) {
				_onStartCallback.call(_object, _object);
			}

			_onStartCallbackFired = true;
		}

		elapsed = (time - _startTime) / _duration;
		elapsed = elapsed > 1 ? 1 : elapsed;

		value = _easingFunction(elapsed);

		for (property in _valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (_valuesStart[property] === undefined) {
				continue;
			}

			var start = _valuesStart[property] || 0;
			var end = _valuesEnd[property];

			if (end instanceof Array) {

				_object[property] = _interpolationFunction(end, value);

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof (end) === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof (end) === 'number') {
					_object[property] = start + (end - start) * value;
				}

			}

		}

		if (_onUpdateCallback !== null) {
			_onUpdateCallback.call(_object, value);
		}

		if (elapsed === 1) {

			if (_repeat > 0) {

				if (isFinite(_repeat)) {
					_repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in _valuesStartRepeat) {

					if (typeof (_valuesEnd[property]) === 'string') {
						_valuesStartRepeat[property] = _valuesStartRepeat[property] + parseFloat(_valuesEnd[property]);
					}

					if (_yoyo) {
						var tmp = _valuesStartRepeat[property];

						_valuesStartRepeat[property] = _valuesEnd[property];
						_valuesEnd[property] = tmp;
					}

					_valuesStart[property] = _valuesStartRepeat[property];

				}

				if (_yoyo) {
					_reversed = !_reversed;
				}

				if (_repeatDelayTime !== undefined) {
					_startTime = time + _repeatDelayTime;
				} else {
					_startTime = time + _delayTime;
				}

				return true;

			} else {

				if (_onCompleteCallback !== null) {

					_onCompleteCallback.call(_object, _object);
				}

				for (var i = 0, numChainedTweens = _chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					_chainedTweens[i].start(_startTime + _duration);
				}

				return false;

			}

		}

		return true;

	};

};


TWEEN.Easing = {

	Linear: {

		None: function (k) {

			return k;

		}

	},

	Quadratic: {

		In: function (k) {

			return k * k;

		},

		Out: function (k) {

			return k * (2 - k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return - 0.5 * (--k * (k - 2) - 1);

		}

	},

	Cubic: {

		In: function (k) {

			return k * k * k;

		},

		Out: function (k) {

			return --k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);

		}

	},

	Quartic: {

		In: function (k) {

			return k * k * k * k;

		},

		Out: function (k) {

			return 1 - (--k * k * k * k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return - 0.5 * ((k -= 2) * k * k * k - 2);

		}

	},

	Quintic: {

		In: function (k) {

			return k * k * k * k * k;

		},

		Out: function (k) {

			return --k * k * k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);

		}

	},

	Sinusoidal: {

		In: function (k) {

			return 1 - Math.cos(k * Math.PI / 2);

		},

		Out: function (k) {

			return Math.sin(k * Math.PI / 2);

		},

		InOut: function (k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));

		}

	},

	Exponential: {

		In: function (k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);

		},

		Out: function (k) {

			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

		}

	},

	Circular: {

		In: function (k) {

			return 1 - Math.sqrt(1 - k * k);

		},

		Out: function (k) {

			return Math.sqrt(1 - (--k * k));

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

		},

		Out: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

		}

	},

	Back: {

		In: function (k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);

		},

		Out: function (k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;

		},

		InOut: function (k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

		}

	},

	Bounce: {

		In: function (k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

		},

		Out: function (k) {

			if (k < (1 / 2.75)) {
				return 7.5625 * k * k;
			} else if (k < (2 / 2.75)) {
				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
			} else if (k < (2.5 / 2.75)) {
				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
			} else {
				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
			}

		},

		InOut: function (k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

	},

	Bezier: function (v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;

	},

	CatmullRom: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

		}

	},

	Utils: {

		Linear: function (p0, p1, t) {

			return (p1 - p0) * t + p0;

		},

		Bernstein: function (n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);

		},

		Factorial: (function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;

			};

		})(),

		CatmullRom: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
(function (root) {

	if (true) {

		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function () {
			return TWEEN;
		}.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else if (typeof module !== 'undefined' && typeof exports === 'object') {

		// Node.js
		module.exports = TWEEN;

	} else if (root !== undefined) {

		// Global variable
		root.TWEEN = TWEEN;

	}

})(this);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(0)))

/***/ }),
/* 266 */
/***/ (function(module, exports) {

module.exports = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEASABIAAD/4ge4SUNDX1BST0ZJTEUAAQEAAAeoYXBwbAIgAABtbnRyUkdCIFhZWiAH2QACABkACwAaAAthY3NwQVBQTAAAAABhcHBsAAAAAAAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLWFwcGwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAtkZXNjAAABCAAAAG9kc2NtAAABeAAABWxjcHJ0AAAG5AAAADh3dHB0AAAHHAAAABRyWFlaAAAHMAAAABRnWFlaAAAHRAAAABRiWFlaAAAHWAAAABRyVFJDAAAHbAAAAA5jaGFkAAAHfAAAACxiVFJDAAAHbAAAAA5nVFJDAAAHbAAAAA5kZXNjAAAAAAAAABRHZW5lcmljIFJHQiBQcm9maWxlAAAAAAAAAAAAAAAUR2VuZXJpYyBSR0IgUHJvZmlsZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbWx1YwAAAAAAAAAeAAAADHNrU0sAAAAoAAABeGhySFIAAAAoAAABoGNhRVMAAAAkAAAByHB0QlIAAAAmAAAB7HVrVUEAAAAqAAACEmZyRlUAAAAoAAACPHpoVFcAAAAWAAACZGl0SVQAAAAoAAACem5iTk8AAAAmAAAComtvS1IAAAAWAAACyGNzQ1oAAAAiAAAC3mhlSUwAAAAeAAADAGRlREUAAAAsAAADHmh1SFUAAAAoAAADSnN2U0UAAAAmAAAConpoQ04AAAAWAAADcmphSlAAAAAaAAADiHJvUk8AAAAkAAADomVsR1IAAAAiAAADxnB0UE8AAAAmAAAD6G5sTkwAAAAoAAAEDmVzRVMAAAAmAAAD6HRoVEgAAAAkAAAENnRyVFIAAAAiAAAEWmZpRkkAAAAoAAAEfHBsUEwAAAAsAAAEpHJ1UlUAAAAiAAAE0GFyRUcAAAAmAAAE8mVuVVMAAAAmAAAFGGRhREsAAAAuAAAFPgBWAWEAZQBvAGIAZQBjAG4A/QAgAFIARwBCACAAcAByAG8AZgBpAGwARwBlAG4AZQByAGkBDQBrAGkAIABSAEcAQgAgAHAAcgBvAGYAaQBsAFAAZQByAGYAaQBsACAAUgBHAEIAIABnAGUAbgDoAHIAaQBjAFAAZQByAGYAaQBsACAAUgBHAEIAIABHAGUAbgDpAHIAaQBjAG8EFwQwBDMEMAQ7BEwEPQQ4BDkAIAQ/BEAEPgREBDAEOQQ7ACAAUgBHAEIAUAByAG8AZgBpAGwAIABnAOkAbgDpAHIAaQBxAHUAZQAgAFIAVgBCkBp1KAAgAFIARwBCACCCcl9pY8+P8ABQAHIAbwBmAGkAbABvACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjAG8ARwBlAG4AZQByAGkAcwBrACAAUgBHAEIALQBwAHIAbwBmAGkAbMd8vBgAIABSAEcAQgAg1QS4XNMMx3wATwBiAGUAYwBuAP0AIABSAEcAQgAgAHAAcgBvAGYAaQBsBeQF6AXVBeQF2QXcACAAUgBHAEIAIAXbBdwF3AXZAEEAbABsAGcAZQBtAGUAaQBuAGUAcwAgAFIARwBCAC0AUAByAG8AZgBpAGwAwQBsAHQAYQBsAOEAbgBvAHMAIABSAEcAQgAgAHAAcgBvAGYAaQBsZm6QGgAgAFIARwBCACBjz4/wZYdO9k4AgiwAIABSAEcAQgAgMNcw7TDVMKEwpDDrAFAAcgBvAGYAaQBsACAAUgBHAEIAIABnAGUAbgBlAHIAaQBjA5MDtQO9A7kDugPMACADwAPBA78DxgOvA7sAIABSAEcAQgBQAGUAcgBmAGkAbAAgAFIARwBCACAAZwBlAG4A6QByAGkAYwBvAEEAbABnAGUAbQBlAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGUAbA5CDhsOIw5EDh8OJQ5MACAAUgBHAEIAIA4XDjEOSA4nDkQOGwBHAGUAbgBlAGwAIABSAEcAQgAgAFAAcgBvAGYAaQBsAGkAWQBsAGUAaQBuAGUAbgAgAFIARwBCAC0AcAByAG8AZgBpAGkAbABpAFUAbgBpAHcAZQByAHMAYQBsAG4AeQAgAHAAcgBvAGYAaQBsACAAUgBHAEIEHgQxBEkEOAQ5ACAEPwRABD4ERAQ4BDsETAAgAFIARwBCBkUGRAZBACAGKgY5BjEGSgZBACAAUgBHAEIAIAYnBkQGOQYnBkUARwBlAG4AZQByAGkAYwAgAFIARwBCACAAUAByAG8AZgBpAGwAZQBHAGUAbgBlAHIAZQBsACAAUgBHAEIALQBiAGUAcwBrAHIAaQB2AGUAbABz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"

/***/ }),
/* 267 */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/wtf8 v1.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function wtf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte.
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read the first byte.
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid WTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function wtf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var wtf8 = {
		'version': '1.0.0',
		'encode': wtf8encode,
		'decode': wtf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
			return wtf8;
		}.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = wtf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in wtf8) {
				hasOwnProperty.call(wtf8, key) && (freeExports[key] = wtf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.wtf8 = wtf8;
	}

}(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(115)(module), __webpack_require__(7)))

/***/ }),
/* 269 */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),
/* 270 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(117);


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tweets = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(16);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(82);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _scene = __webpack_require__(29);

var _setEvents = __webpack_require__(122);

var _geoHelpers = __webpack_require__(120);

var _mapTexture = __webpack_require__(121);

var _utils = __webpack_require__(41);

var _tweens = __webpack_require__(30);

var _createEarth = __webpack_require__(128);

var _createPoint = __webpack_require__(130);

var _THREE = __webpack_require__(14);

var _THREE2 = _interopRequireDefault(_THREE);

var _d = __webpack_require__(32);

var _d2 = _interopRequireDefault(_d);

var _topojsonClient = __webpack_require__(257);

var topojson = _interopRequireWildcard(_topojsonClient);

var _CountryInformation = __webpack_require__(125);

var _CountryInformation2 = _interopRequireDefault(_CountryInformation);

var _CountryName = __webpack_require__(71);

var _CountryName2 = _interopRequireDefault(_CountryName);

var _BackButton = __webpack_require__(123);

var _BackButton2 = _interopRequireDefault(_BackButton);

var _TweetBox = __webpack_require__(126);

var _TweetBox2 = _interopRequireDefault(_TweetBox);

var _TweetCount = __webpack_require__(127);

var _TweetCount2 = _interopRequireDefault(_TweetCount);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OrbitControls = __webpack_require__(255)(_THREE2.default),
    io = __webpack_require__(245),
    TWEEN = __webpack_require__(265),
    geo = void 0,
    controls = void 0,
    countries = void 0,
    overlay = void 0,
    textureCache = void 0,
    earth = void 0,
    cloud = void 0,
    root = new _THREE2.default.Object3D(),
    points = new _THREE2.default.Object3D(),
    clock = new _THREE2.default.Clock();

var segments = 200,
    // number of vertices. Higher = better mouse accuracy
RADIUS = 400;

var tweets = exports.tweets = [];

var App = function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.state = {
      countryName: "",
      countryFlag: "us",
      countryCapital: "",
      countryPopulation: "",
      countrySize: "",
      countryLanguages: "",
      numTweets: 0,
      numCountryTweets: 0,
      isPointHovered: false,
      isCountryClicked: false,
      tweetImage: "src/images/clouds.png",
      tweetName: "",
      tweetText: ""
    };

    _this.timer = null;
    _this.socket = null;
    _this.globeMutex = true;
    _this.countryData = null;
    _this.sphere = new _THREE2.default.SphereGeometry(RADIUS, segments, segments);
    _this.mouseCoordinates = { x: 0, y: 0 };
    _this.lastPoint = {};
    _this.animate = _this.animate.bind(_this);
    _this.initFeed = _this.initFeed.bind(_this);
    _this.onGlobeClick = _this.onGlobeClick.bind(_this);
    _this.onGlobeMouseDown = _this.onGlobeMouseDown.bind(_this);
    _this.onGlobeMousemove = _this.onGlobeMousemove.bind(_this);
    return _this;
  }

  /**
   * Initializer function to set up our scene and all elements within it.
   */


  _createClass(App, [{
    key: 'init',
    value: function init() {
      this.animate();
      this.loadMap();
    }

    /**
     * Creates the socket connection with the server, and uses the data that
     * is sent over to create the map points, text display, etc..
     */

  }, {
    key: 'initFeed',
    value: function initFeed() {
      var self = this;

      this.socket = io.connect();

      // when a new tweet comes in, add it to our array
      this.socket.on('tweet', function (data) {

        if (!self.state.isCountryClicked) {
          tweets.push(data);
        } else {
          self.setState({ numCountryTweets: self.state.numCountryTweets + 1 });
        }
      });

      // add the group of points to the root object so it will rotate with the globe.
      root.add(points);

      // add the latest tweet to the globe every so often.
      this.timer = setInterval(self.addTweet.bind(self), 500);
    }

    /**
     * Adds the next tweet in line to the globe. Called on an interval
     * so that the globe isn't overloaded with tweets/points.
     */

  }, {
    key: 'addTweet',
    value: function addTweet() {
      // Make sure we have some tweets to work with, and a country isn't in view.
      if (tweets[this.state.numTweets] && !this.state.isCountryClicked) {
        var tweet = tweets[this.state.numTweets],
            tweetId = tweet['twid'],
            text = tweet['body'],
            coordinates = tweet['coordinates']['coordinates'],
            avatarURL = tweet['avatar'],
            screenName = tweet['screenName'],
            sentiment = tweet['sentiment'],
            color = (0, _utils.getColor)(sentiment.score);

        this.setState({ numTweets: this.state.numTweets + 1 });

        // create the point and add it to our list group of points
        (0, _createPoint.createPoint)(coordinates[1], coordinates[0], RADIUS, 10, 20, color, points, TWEEN);

        // if there are enough tweets, move the oldest one off
        if (this.state.numTweets > 50) points.children.shift();
      }
    }

    /**
     * Used to load in the data that generates the main map/globe.
     */

  }, {
    key: 'loadMap',
    value: function loadMap() {

      root.scale.set(0.1, 0.1, 0.1);

      var self = this,
          globe = (0, _createEarth.createEarth)(this.sphere, root, TWEEN, this.initFeed);

      _d2.default.json('src/json/world.json', function (err, data) {

        // Setup cache for country textures
        countries = topojson.feature(data, data.objects.countries);
        geo = (0, _geoHelpers.geodecoder)(countries.features);
        earth = globe.earth;
        cloud = globe.cloud;

        textureCache = (0, _utils.memoize)(function (cntryID, color) {
          var country = geo.find(cntryID);
          return (0, _mapTexture.mapTexture)(country, color);
        });

        var worldTexture = (0, _mapTexture.mapTexture)(countries, '#transparent', 'transparent'),
            worldTextureBack = (0, _mapTexture.mapTexture)(countries, '#000', 'transparent');

        var mapMaterialBack = new _THREE2.default.MeshPhongMaterial({
          depthWrite: false,
          map: worldTextureBack,
          side: _THREE2.default.BackSide,
          transparent: true
        });

        var mapMaterialFront = new _THREE2.default.MeshPhongMaterial({
          depthWrite: false,
          map: worldTexture,
          opacity: 0.6,
          transparent: true
        });

        var baseMapBack = new _THREE2.default.Mesh(self.sphere, mapMaterialBack),
            baseMapFront = new _THREE2.default.Mesh(self.sphere, mapMaterialFront);

        baseMapFront.addEventListener('mousedown', self.onGlobeMouseDown, false);
        baseMapFront.addEventListener('mouseup', self.onGlobeClick, false);
        baseMapFront.addEventListener('mousemove', self.onGlobeMousemove, false);
        baseMapFront.receiveShadow = true;
        baseMapFront.name = "front-map";
        baseMapBack.name = "back-map";
        // baseMapBack.rotation.y     = Math.PI;
        // baseMapFront.rotation.y    = Math.PI;

        // set the earth image to be above the colored globe
        earth.renderOrder = 1;

        root.rotation.y = Math.PI;

        // make sure the back is added to the root/scene first
        root.add(earth);
        root.add(cloud);
        root.add(baseMapBack);
        root.add(baseMapFront);

        _scene.scene.add(root);

        controls = new OrbitControls(_scene.camera, _scene.renderer.domElement);

        // Setup the event listeners for the events on the globe.
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mousedown', null);
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mouseup', null);
        (0, _setEvents.setEvents)(_scene.camera, [baseMapFront], 'mousemove', 10, null, null, self.onCountryHoverOff.bind(self));
        (0, _setEvents.setEvents)(_scene.camera, points.children, 'mousemove', 5, TWEEN, self.onPointHover.bind(self), self.onPointHoverOff.bind(self));
      });

      // Load in the country data for later..
      _d2.default.json('src/json/countries.json', function (err, data) {
        if (err) throw err;

        self.countryData = data;
      });
    }

    /**
     * Used to load in the country data (Name, Languages, Population, flag, etc);
     *
     * @param     country     :     String
     *
     */

  }, {
    key: 'setCountryData',
    value: function setCountryData(country) {
      var countryInfo = this.countryData[country];

      this.setCountryImage(countryInfo["countryCode"].toLowerCase());

      // Let the server know a country was clicked.
      this.socket.emit("countryChange", countryInfo);

      this.setState({
        countryFlag: countryInfo["countryCode"].toLowerCase(),
        countryCapital: countryInfo["capital"],
        countryPopulation: countryInfo["population"],
        countrySize: countryInfo["areaInSqKm"],
        countryLanguages: countryInfo["languages"]
      });
    }

    /**
     * Sets the globe material to the flag of the clicked country.
     *
     * @param     countryCode     :     String
     *
     */

  }, {
    key: 'setCountryImage',
    value: function setCountryImage(countryCode) {
      var loader = new _THREE2.default.TextureLoader();

      _scene.scene.getObjectByName("cloud").material.map = loader.load("src/images/flags/" + countryCode + ".png");

      _scene.scene.getObjectByName("cloud").rotation.y = -Math.PI / 2;
    }
  }, {
    key: 'setCountryImageBack',
    value: function setCountryImageBack() {
      var loader = new _THREE2.default.TextureLoader();

      _scene.scene.getObjectByName("cloud").material.map = loader.load("src/images/clouds.png");
    }

    /*
     * Used to compute which point was hovered over and extract
     * the information from the corresponding tweet.
     *
     * @param     obj    :    THREE.Mesh
     * @param     mouse  :    Object
     *
     */

  }, {
    key: 'onPointHover',
    value: function onPointHover(obj, mouse) {
      var index = _createPoint.pointList.indexOf(obj),
          tweet = tweets[index];

      this.mouseCoordinates = mouse;

      // Don't show the tweets when we're in the country view mode.
      if (!this.state.isCountryClicked) {
        this.setState({
          isPointHovered: true,
          tweetImage: tweet["avatar"],
          tweetName: tweet["author"],
          tweetText: tweet["body"]
        }, this.onCountryHoverOff());
      }
    }

    /**
     * Called once a point is hovered off of. Sets the state and the object's
     * material back to what it was before.
     */

  }, {
    key: 'onPointHoverOff',
    value: function onPointHoverOff() {
      this.setState({ isPointHovered: false });
    }

    /**
     * Called when a country is clicked on. Handles moving the globe,
     * removing the points, and setting the state.
     *
     * @param     country    :    String (name of the clicked country)
     *
     */

  }, {
    key: 'onCountryClick',
    value: function onCountryClick(country) {
      root.remove(points);

      // Set the styles back to the default state.
      document.getElementById("wrapper").classList = "active";
      document.body.style.cursor = "auto";

      this.setState({
        isPointHovered: false,
        isCountryClicked: true,
        countryName: country
      }, this.setCountryData(country));
    }

    /**
     * Handles the act of hovering on a country. Sets that country's name
     * and updates the material to show it.
     */

  }, {
    key: 'onCountryHover',
    value: function onCountryHover(country) {
      document.body.style.cursor = "pointer";

      this.setState({ countryName: country });

      if (_scene.scene.getObjectByName('earth').material.opacity > 0.6) {
        overlay.material.opacity = 1;
        (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('earth'), 0.6, 200);
        (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('back-map'), 0.4, 200);
      }
    }

    /**
     * Handles hovering off a country. Sets the materials back.
     */

  }, {
    key: 'onCountryHoverOff',
    value: function onCountryHoverOff() {
      if (!this.state.isCountryClicked) {
        console.log("hovered off country");
        document.body.style.cursor = "auto";

        this.setState({ countryName: "" });

        if (_scene.scene.getObjectByName('earth').material.opacity < 0.99) {
          overlay.material.opacity = 0;
          (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('earth'), 0.99, 200);
          (0, _tweens.fadeObject)(TWEEN, _scene.scene.getObjectByName('back-map'), 1, 200);
        }
      }
    }

    /**
     * Called when the back button is clicked in the country view. Used
     * to reset the state to its original settings.
     */

  }, {
    key: 'onBackButtonClick',
    value: function onBackButtonClick() {
      root.add(points);

      document.getElementById("wrapper").classList = "";

      // Set the cloud image back.
      this.setCountryImageBack();

      // Let the server know a country was clicked.
      this.socket.emit("countryChangeBack");

      this.setState({
        isCountryClicked: false,
        countryName: "",
        numCountryTweets: 0
      });
    }

    /**
     * Called when the mouse is pressed on the globe. Sets the values
     * used to determine if the user moved the globe. 
     *
     * @param    event    :    Object
     *
     */

  }, {
    key: 'onGlobeMouseDown',
    value: function onGlobeMouseDown(event) {
      this.lastPoint = parseInt(event.distance, 10);
    }

    /**
     * Checks to see if the mouse moved during a click. Compares the mouse down
     * location with the mouse up location to see.
     *
     * @param    event    :    Object
     *
     */

  }, {
    key: 'isStaticClick',
    value: function isStaticClick(event) {
      return parseInt(event.distance, 10) === this.lastPoint;
    }

    /**
     * Called when the globe is clicked on. Rotates the camera to face the
     * globe and moves its position.
     */

  }, {
    key: 'onGlobeClick',
    value: function onGlobeClick(event) {
      // Get point, convert to latitude/longitude
      var latlng = _geoHelpers.getEventCenter.call(this.sphere, event),
          country = geo.search(latlng[0], latlng[1]),
          isStatic = this.isStaticClick(event);

      // Don't do anything when a country or point is in view, or if a drag occurred.
      if (!this.state.isCountryClicked && !this.state.isPointHovered && isStatic) {
        // Make sure a country is clicked on
        if (country) {
          this.onCountryClick(country.code);
        }

        // Get new camera position
        var temp = new _THREE2.default.Mesh();
        temp.position.copy((0, _geoHelpers.convertToXYZ)(latlng, 900));
        temp.lookAt(root.position);
        temp.rotateY(Math.PI);

        // Computes the temporary rotation needed to get the country in view
        for (var key in temp.rotation) {
          if (temp.rotation[key] - _scene.camera.rotation[key] > Math.PI) {
            temp.rotation[key] -= Math.PI * 2;
          } else if (_scene.camera.rotation[key] - temp.rotation[key] > Math.PI) {
            temp.rotation[key] += Math.PI * 2;
          }
        }

        // Move the camera to the right location in front of the clicked country.
        var tweenPos = _utils.getTween.call(_scene.camera, 'position', temp.position);
        _d2.default.timer(tweenPos);

        // Rotate the camera after as it moves to face the globe.
        var tweenRot = _utils.getTween.call(_scene.camera, 'rotation', temp.rotation);
        _d2.default.timer(tweenRot);

        // Set the earth's rotation back to 0 so the correct country is in view.
        var tweenRootRot = _utils.getTween.call(root, 'rotation', new _THREE2.default.Euler(0, Math.PI, 0));
        _d2.default.timer(tweenRootRot);
      }
    }

    /**
     * Creates and overlays a map with the hovered country highlighted.
     * Called when the map/globe is hovered on.
     */

  }, {
    key: 'onGlobeMousemove',
    value: function onGlobeMousemove(event) {
      var map = void 0,
          material = void 0,
          latlng = _geoHelpers.getEventCenter.call(this.sphere, event),
          country = geo.search(latlng[0], latlng[1]);

      // Make sure a country, is hovered on and we are not in the country view.
      if (country && !this.state.isCountryClicked && !this.state.isPointHovered) {

        // Only run this if we have the mutex or we moved to a different country.
        if (country.code !== this.state.countryName || this.globeMutex) {

          this.globeMutex = false;

          // Overlay the selected country
          map = textureCache(country.code, 'rgba(0,0,0,0.9)');

          material = new _THREE2.default.MeshPhongMaterial({
            depthWrite: false,
            map: map,
            transparent: true
          });

          // Only add the overlay if it's not there already. Duh..
          if (!overlay) {
            overlay = new _THREE2.default.Mesh(this.sphere, material);
            overlay.renderOrder = 2;
            overlay.name = "overlay";
            root.add(overlay);
          } else {
            overlay.material = material;
          }

          this.onCountryHover(country.code);
        }
      } else {

        if (!this.globeMutex) {
          this.globeMutex = true;
          // Set the pointer back if we aren't on a country
          this.onCountryHoverOff();
        }
      }
    }

    /**
     * Loop used for rendering and updating values
     */

  }, {
    key: 'animate',
    value: function animate() {
      _scene.renderer.render(_scene.scene, _scene.camera);
      this.update();

      requestAnimationFrame(this.animate);
    }

    /**
     * Called by the animation function about 60 times per second. Updates any
     * values that are used for animation or control.
     */

  }, {
    key: 'update',
    value: function update() {
      if (controls && !this.state.isPointHovered) controls.update();

      if (cloud && !this.state.isPointHovered) cloud.rotation.y += 0.000625;

      if (root && !this.state.isPointHovered && !this.state.isCountryClicked) root.rotation.y += 0.0005;

      // update and transitions on existing tweens
      TWEEN.update();
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.init();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      // remove the interval to avoid any leaks
      clearInterval(this.timer);
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'main',
        { className: 'body' },
        _react2.default.createElement(_BackButton2.default, {
          isCountryClicked: this.state.isCountryClicked,
          onButtonClick: this.onBackButtonClick.bind(this) }),
        _react2.default.createElement(_CountryName2.default, { countryName: this.state.countryName }),
        _react2.default.createElement(_CountryInformation2.default, {
          countryName: this.state.countryName,
          countryFlag: this.state.countryFlag,
          countryCapital: this.state.countryCapital,
          countryPopulation: this.state.countryPopulation,
          countrySize: this.state.countrySize,
          countryLanguages: this.state.countryLanguages,
          numCountryTweets: this.state.numCountryTweets }),
        _react2.default.createElement(_TweetCount2.default, { numTweets: this.state.numTweets }),
        _react2.default.createElement(_TweetBox2.default, {
          isPointHovered: this.state.isPointHovered,
          mouseCoordinates: this.mouseCoordinates,
          image: this.state.tweetImage,
          name: this.state.tweetName,
          text: this.state.tweetText })
      );
    }
  }]);

  return App;
}(_react.Component);

exports.default = App;

/***/ })
/******/ ]);
//# sourceMappingURL=bundle.js.map